* Reading group
** Modeling
Ground rule: If you don't understand something, ask as soon as possible -- it's probably my fault for not explaining it well. If there's something that it's OK not to understand, I'll say so, so assume that everything I said, I was trying to make you understand, and if I didn't succeed, I would like to know that.

The Django tutorial I linked to isn't super great for beginners -- it's kind of targeted at experienced web developers. The goal for these first few weeks is to get us to a place where we have *something* up and running, so for now, it's OK not to understand all of that document. That said, I would love for people to learn/get practice with reading technical documentation. It's something of an art!

The first part of building a web application in Django is defining the structure of your database, so we're going to spend some time talking about that today.
*** What is a web application?
At it's most fundamental level, a website is basically some HTML and some images. Some of you have probably already studied a little HTML and it's not really that interesting. In particular, it's static. It will keep staying the same until you write new HTML.

A web application is a program that generates HTML when you visit, so that it can be *dynamic*, or have the potential for change. This makes it something that a user can interact with, without having to write HTML themselves.

Django (and most similar software) anticipate that you will want to base your application on some data, and that application can manipulate that data, and that data is what the user sees and interacts with by interacting with your application. So it's: User <-> Application <-> Data.

In order to make it easy for your application to manipulate data, it's stored in a database.
*** What is a database?
A database is another piece of software which is in charge of storing and organizing data[1]. We are going to be using a kind of database called a "relational" database (specifically we're going to start by using SQLite, but most databases that have "SQL" in the name function similarly).

You can think of a relational database as kind of like an Excel workbook. A relational database has "tables", which are like sheets in a workbook. Each table is a collection of rows, each of which has the same set of columns. So you might have a "people" table that looks like this:

| Person  | Number of pets | Signed up date |
| Ethan   |              1 |     2015-05-01 |
| Rita    |              0 |     2015-05-18 |
| Francis |              1 |     2015-05-08 |

And you might have another table that stores hobbies:

| Person  | Hobby        |
| Ethan   | Chiptune     |
| Rita    | British rock |
| Francis | Death metal  |
| Ethan   | Baking       |
| Francis | Kendo        |
| Rick    | Beer         |

If you had this data stored in a relational database, it would be possible to ask it to "put it together" and generate a table like this:

| Person  | Number of pets | Number of hobbies |
| Ethan   |              1 |                 2 |
| Rita    |              0 |                 1 |
| Francis |              1 |                 2 |

"Relational" is a long word so I'll probably use it interchangeably with "SQL" (pronounced "sequel"), even though technically the two things aren't exactly the same.

[1] This is a wild oversimplification, but "database" is a term that gets used a lot in a lot of contexts with subtly different meanings.
*** Modeling
When you're using Django (and probably when you're developing any kind of application), the first thing you do is think about what are the entities that you're going to have in your application, and how they relate to one another. For example, in a hospital management system, you might have patients and doctors and rooms, and patients stay in rooms and doctors visit patients (but doctors don't stay in rooms). Once you have a clear idea of what the entities are, you structure your database to support that. In Django, you write the structure of your database in a file called "models.py". You translate this structure into your actual database using the "python manage.py migrate" command.

In the tutorial, they take the example of a "poll", which they define as being a "question" with a variable number of "answers". ("Variable" meaning that one question might have two answers, and another question might have three answers.)

[Side note: Let's say I created my table to be like this:

| Question text | Publication date | Choice 1 text | Choice 1 votes | Choice 2 text | Choice 2 votes | Choice 3 text | Choice 3 votes |
| What's up?    |       2015-05-01 | Not much      |              0 | The sky       |              0 | Just hacking  | 0              |

In doing this, I'm asserting that EVERY question have exactly 3 choices! Clearly they can't have more choices because there's no where to put them, but it's also true that they can't have less choices because what will I put in the 3rd choice?

In other words, notice that columns are *constant* in a relational model, so if you want to have a variable number of something, you have to turn those somethings into rows somehow.]
*** Demo
Once you have your models set up, you can create Python objects and make them go into the database, and similarly you can get things out of the database as Python objects. This might not be impressive, but it's the same thing your application is going to do when users interact with it.

You can access the database your program created using the "sqlite3" command (which you might have to install using apt-get or yum or something). This part isn't super important because Django mostly insulates you from it, but I thought it might be interesting to see what's going on "underneath the hood", and sometimes this is useful for debugging.

To open your database in sqlite, you can type "sqlite3 db.sqlite3". In sqlite, you can do .tables to show the tables. A table was created for "polls_question" and another for "polls_choice". You can see what the "schema" (table structure) for a table was using e.g. ".schema polls_question". You can also see what is in your database using a SELECT statement.

#+begin_src
sqlite> select * from polls_question;
1|What's new?|2015-05-18 04:33:32.860786
2|Should I go to work today?|2015-05-18 04:34:51.572901

sqlite> .schema polls_choice
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id"));
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

sqlite> select * from polls_choice;
1|Not much|0|1
2|The sky|0|1
3|Just hacking again|0|1
4|Yes|0|2
5|No|0|2
#+end_src

So, we see that each choice has FOUR attributes -- an ID for itself, a text, a count of votes, and the ID of the question to which it is associated.

Note that each choice uses the question ID -- in my example above, I used people's names, but using an ID is more natural. For one thing, it lets people change their names without having to change it in a lot of places, and I don't have to worry about them being spelled slightly wrong. For another, names aren't unique, but IDs are.
*** Many-to-many relationships
The example in the tutorial defines a many-to-one relationship -- one choice belongs with one question, but one question has many choices. This kind of relationship, as well as the even simpler one-to-one relationship, is generally implemented by putting the ID of the related object in the table.

There's another kind of relationship between entities called a many-to-many relationship. The relationship between people and hobbies is a good example. Each person has many hobbies, and each hobby can be associated with many people. Traditionally, this is implemented using a "join table" -- a table that just tracks the IDs of both objects. So you might have:

A "people" table:

| ID | Name    | Number of Pets |
|  1 | Ethan   |              1 |
|  2 | Rita    |              0 |
|  3 | Francis |              2 |

A "hobbies" table:

| ID | Hobby        |
|  1 | Chiptune     |
|  2 | British rock |
|  3 | Death metal  |

The "person-to-hobbies link table":

| Person ID | Hobby ID |
| 1         | 1        |
| 2         | 2        |
| 3         | 3        |
| 3         | 1        |

Django can handle this for you too, but you'll have to read more documentation: https://docs.djangoproject.com/en/1.8/topics/db/examples/many_to_many/.
*** Homework
- Let's start small -- instead of a whole dollhouse, let's just design a schema for a paper doll application. A paper doll has a name (e.g. "Princess" or "Zoe") and some articles of clothing. Each article of clothing has a filename (e.g. "gloves.png") and a location (e.g. arms, torso, legs, head). What should the tables look like?

- Go through the tutorial again and try to create another application in your existing site. Call it "paperdolls". Try to define the models the same way they do in the tutorial. To test them, try going into the shell and create objects the way they did (although using your models instead of the polls one). Post any error you get to the mailing list, along with the contents of your models.py.
** Views pt 1
*** Homework review
Here are my solutions:

**** Solution 1
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    doll = models.ForeignKey(Doll)

    filename = models.CharField(max_length=200)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Doll ID | Filename      | Location |
|  1 |       1 | gloves.png    |        2 |
|  2 |       1 | red-dress.png |        0 |
|  3 |       1 | sandals.png   |        3 |
|  4 |       2 | tiara.png     |        1 |
|  5 |       2 | lab-coat.png  |        0 |

**** Solution 2
#+begin_src python
class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class Doll(models.Model):
    name = models.CharField(max_length=200)
    torso_item = models.ForeignKey(ClothingItem)
    head_item = models.ForeignKey(ClothingItem)
    arms_item = models.ForeignKey(ClothingItem)
    legs_item = models.ForeignKey(ClothingItem)
#+end_src

Dolls table:
| ID | Name     | Torso | Head | Arms | Legs |
|  1 | Princess |     2 | ???  |    1 |    3 |
|  2 | Zoe      |     5 | 4    |  ??? |  ??? |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

**** Solution 3
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class DollWearsClothing(models.Model):
    doll = models.ForeignKey(Doll)
    clothing_item = models.ForeignKey(ClothingItem)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

Doll Wears Clothing table:

| ID | Clothing ID | Doll ID | Location |
|  1 |           1 |       1 |        2 |
|  2 |           2 |       1 |        0 |
|  3 |           3 |       1 |        3 |
|  4 |           4 |       2 |        1 |
|  5 |           5 |       2 |        0 |
|  6 |           3 |       2 |        3 |
*** Syntax
Syntax refers to the structure of a language. In English, the sentence "The dog bit the man" is well-formed according to English syntax. The sentence "The bit dog man the" has invalid syntax. The sentence "The man bit the dog" has valid syntax but questionable semantics. In programming languages, we sometimes use "syntax" as an umbrella term for all the rules of the language that give it sense to the computer, which also include semantics.

Depending on how far you've gotten in the Django tutorials, you've seen lots of different syntax so far:

- =from foo import bar= at the beginning of a bunch of different files
- =class Foo():= for models
- =blah = models.CharField()= for fields in those models
- =def __str__():= when defining models
- =INSTALLED_APPS = (...)= when "activating" models
- ='words'= and sometimes ="words"=
- =def foo():= for views
- =urlpatterns = [...]= when setting up views
- =url(r'...', foo)= when setting up views
- =%= in some views

I'm going to touch on the essentials of the most important parts of the most important ones of these, and mention a few details about some of the others, because the goal is to get us up and running as fast as possible without wearing you down with details that aren't important yet. These are just simplistic summaries!
*** Django settings: variables
In almost any programming language, you can do stuff like this:

#+NAME: print_variables
#+begin_src python :results output
x = 5
print(x)
print(x + 3)

x = 6
print(x)
print(x + 3)
#+end_src

If I run this program, it will show:

#+RESULTS: print_variables
: 5
: 8
: 6
: 9

What's going on is that when Python sees the line =x = 5=, it creates a thing called =x=. Wherever it sees =x=, it checks the last value it got for =x=, which in this case is 5. =x= is called a variable, and you can think of it as like a box in the computer's memory that has some "value" inside of it. When Python then sees the line =x = 6=, it will take the 5 out of the box and put the 6 in.

There are many different kinds of values that we can put into a variable.[1] In the above example, =x= is an integer (in Python, we say =x= is an =int=). You can also have bits of words and sentences in variables: just do =x = 'hello'= or =x = "hello"= (they're equivalent). These bits of text are called "strings" (in Python, we say they are =str=). You can have truth values =True= and =False=, which are called Booleans (in Python, =bool=). You can also have lists, which are written =x = [1, 2, 3]= (in Python these are called =list=\ s, but in other languages they're called arrays or vectors). There's also something called a tuple, which is written =x = (1, 2, 3)=, but for now we're going to say it's the same as a list.

There are a bunch of places where you get to customize how Django does some things. We've already seen that we need to update =INSTALLED_APPS= when we add a new app. =INSTALLED_APPS= is an ordinary variable that Django gives some special meaning to. Most of these variables are written in all uppercase, but some (like =urlpatterns=) aren't, and you just have to know that they're special.

[1] In some languages, each variable has to be "declared" to hold only some types of values. Python isn't like that; instead it uses "dynamic typing", which means that any variable can hold any value, and even change from one type of value to another. This has advantages and disadvantages.
*** def foo(): functions/methods
Any time you see =def foo(...)=, we are defining a function. A function is a part of a program. Like a program, a function has some operands, which are called parameters or arguments, and outputs, which is called the "return value". Here's an example:

#+begin_src python
def check_password(password):
    if password == 'stairs_are_history!':
        return True
    elif password == 'swordfish':
        return True
    else:
        return False
#+end_src

Here's how you might use it:

#+begin_src python
user_password = input()
password_correct = check_password(user_password)
if password_correct:
    print("Welcome back!!")
else:
    print("Incorrect password")
#+end_src

So when you see the code =check_password(user_password)=, that's saying "Begin doing the stuff under =def check_password=. Also, when doing those things, the variable =password= is going to have the value that =user_password= does.[2][3]" Then, Python goes through line after line, doing what that line says, until it either gets to the end of the =def= or it hits a =return=. If it hits a =return=, the function immediately ends and the value after the =return= is sent to wherever the =check_password()= line was.

Using a function is a nice way to group some commands together and use them many times in different places. For this reason, Django uses them to represent views.

The syntax for a function is:

#+begin_src python
def FUNCTION_NAME(PARAM1, PARAM2, ....):
    STATEMENT1
    STATEMENT2
    ...
#+end_src

N.B. A function definition ALWAYS has a colon (=:=) after the parameter list, and the statements in the function are ALWAYS "indented" by four spaces. Some of those statements might have their own sub-statements, which might be inset by another four spaces, and so on. The function continues until Python sees a non-blank line that isn't indented by four spaces.

To use the function, you write the name of the function, plus the things you want the function to operate on. Then Python will start doing the various statements, one after the other. If the function is going to return something, you can put a variable in front of it, or use it in another function, or whatever.

As a general rule, using a function looks almost exactly like using an entity or a class, but functions usually have lowercase names and entities and classes have Capitalized names.

You can also define functions inside classes; these are called methods and we'll talk more about them several weeks from now.

=__str__()= is a special method that is used whenever an object needs to be displayed. We won't dwell on it right now.

[2] Again, it isn't necessary to specify a type for =password=; like any variable, it can take any value.

[3] =password= is what's called a "local" variable; it will disappear as soon as the function is over.
*** import
In Python, when we want to use models, functions, or variables from another file, we use the =import= command. There are many different ways to import things, none of which we're going to discuss now.
*** Homework
Go through all the files in your site so far. Find examples of the following:
- functions being used
- stuff being imported
- a list
- a tuple

Press on and try to get to the end of part 3 of the tutorial. Hopefully by now we are starting to see how Django lets us build a web application.
** TODO add to email
Solution 1 is what I expected most of you to come up with. It lets you match clothing with dolls. One nice advantage to this system is that we can have multiple articles of clothing on the same doll in the same place. (So, socks and then sneakers, for example.) Similarly, you can have 0 articles of clothing on a part of the doll. Of course, if your requirements don't need/forbid this, that might be a disadvantage.

Solution 2 is kind of like a straw man, devil's advocate thing. Last week I said this isn't really possible because we don't know what to put in the =???= places. In fact, there is a way -- there's a thing called =NULL= which is like an empty space. Some people say =NULL= [[http://c2.com/cgi/wiki?NullsAndRelationalModel]["violates the relational model"]], which might or might not mean anything, but it certainly can make your life difficult if you expect something to never be =NULL= when in fact it sometimes is. For this reason, all fields in Django are not allowed to be =NULL= (this is also enforced by the database). If you want to change this, you can use the [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#blank][blank]] and [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.Field.null][null]] options in your fields.

Solution 2 doesn't let you have multiple articles in the same place, but it does have one nice advantage which is that it's easy to "share" an article of clothing between two dolls -- you just re-use the ID. In Solution 1, this would require duplicating the filename, which is error-prone. (If you move the filename and forget to update it everywhere, you will have a data consistency problem.)

Solution 3 has the advantages of both solution 1 and solution 2 -- you can share clothing, plus you can have multiple clothing in the same place. But there's something weird in it, which is that the location of the same article of clothing can be different for different dolls.

Any of these solutions might be OK depending on what your requirements are, but I'd probably go with solution 3, but move =location= to the Clothing table, and I'd add a column to the Wear table that specifies order (so that socks always go under sneakers).
** Future topics
Local variables
Methods
Dynamic typing
Tuples and how they differ from lists
The "dot" syntax for looking up fields in models or calling methods
