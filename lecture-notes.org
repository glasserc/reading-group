* Reading group
** Modeling
Ground rule: If you don't understand something, ask as soon as possible -- it's probably my fault for not explaining it well. If there's something that it's OK not to understand, I'll say so, so assume that everything I said, I was trying to make you understand, and if I didn't succeed, I would like to know that.

The Django tutorial I linked to isn't super great for beginners -- it's kind of targeted at experienced web developers. The goal for these first few weeks is to get us to a place where we have *something* up and running, so for now, it's OK not to understand all of that document. That said, I would love for people to learn/get practice with reading technical documentation. It's something of an art!

The first part of building a web application in Django is defining the structure of your database, so we're going to spend some time talking about that today.
*** What is a web application?
At it's most fundamental level, a website is basically some HTML and some images. Some of you have probably already studied a little HTML and it's not really that interesting. In particular, it's static. It will keep staying the same until you write new HTML.

A web application is a program that generates HTML when you visit, so that it can be *dynamic*, or have the potential for change. This makes it something that a user can interact with, without having to write HTML themselves.

Django (and most similar software) anticipate that you will want to base your application on some data, and that application can manipulate that data, and that data is what the user sees and interacts with by interacting with your application. So it's: User <-> Application <-> Data.

In order to make it easy for your application to manipulate data, it's stored in a database.
*** What is a database?
A database is another piece of software which is in charge of storing and organizing data[1]. We are going to be using a kind of database called a "relational" database (specifically we're going to start by using SQLite, but most databases that have "SQL" in the name function similarly).

You can think of a relational database as kind of like an Excel workbook. A relational database has "tables", which are like sheets in a workbook. Each table is a collection of rows, each of which has the same set of columns. So you might have a "people" table that looks like this:

| Person  | Number of pets | Signed up date |
| Ethan   |              1 |     2015-05-01 |
| Rita    |              0 |     2015-05-18 |
| Francis |              1 |     2015-05-08 |

And you might have another table that stores hobbies:

| Person  | Hobby        |
| Ethan   | Chiptune     |
| Rita    | British rock |
| Francis | Death metal  |
| Ethan   | Baking       |
| Francis | Kendo        |
| Rick    | Beer         |

If you had this data stored in a relational database, it would be possible to ask it to "put it together" and generate a table like this:

| Person  | Number of pets | Number of hobbies |
| Ethan   |              1 |                 2 |
| Rita    |              0 |                 1 |
| Francis |              1 |                 2 |

"Relational" is a long word so I'll probably use it interchangeably with "SQL" (pronounced "sequel"), even though technically the two things aren't exactly the same.

[1] This is a wild oversimplification, but "database" is a term that gets used a lot in a lot of contexts with subtly different meanings.
*** Modeling
When you're using Django (and probably when you're developing any kind of application), the first thing you do is think about what are the entities that you're going to have in your application, and how they relate to one another. For example, in a hospital management system, you might have patients and doctors and rooms, and patients stay in rooms and doctors visit patients (but doctors don't stay in rooms). Once you have a clear idea of what the entities are, you structure your database to support that. In Django, you write the structure of your database in a file called "models.py". You translate this structure into your actual database using the "python manage.py migrate" command.

In the tutorial, they take the example of a "poll", which they define as being a "question" with a variable number of "answers". ("Variable" meaning that one question might have two answers, and another question might have three answers.)

[Side note: Let's say I created my table to be like this:

| Question text | Publication date | Choice 1 text | Choice 1 votes | Choice 2 text | Choice 2 votes | Choice 3 text | Choice 3 votes |
| What's up?    |       2015-05-01 | Not much      |              0 | The sky       |              0 | Just hacking  | 0              |

In doing this, I'm asserting that EVERY question have exactly 3 choices! Clearly they can't have more choices because there's no where to put them, but it's also true that they can't have less choices because what will I put in the 3rd choice?

In other words, notice that columns are *constant* in a relational model, so if you want to have a variable number of something, you have to turn those somethings into rows somehow.]
*** Demo
Once you have your models set up, you can create Python objects and make them go into the database, and similarly you can get things out of the database as Python objects. This might not be impressive, but it's the same thing your application is going to do when users interact with it.

You can access the database your program created using the "sqlite3" command (which you might have to install using apt-get or yum or something). This part isn't super important because Django mostly insulates you from it, but I thought it might be interesting to see what's going on "underneath the hood", and sometimes this is useful for debugging.

To open your database in sqlite, you can type "sqlite3 db.sqlite3". In sqlite, you can do .tables to show the tables. A table was created for "polls_question" and another for "polls_choice". You can see what the "schema" (table structure) for a table was using e.g. ".schema polls_question". You can also see what is in your database using a SELECT statement.

#+begin_src
sqlite> select * from polls_question;
1|What's new?|2015-05-18 04:33:32.860786
2|Should I go to work today?|2015-05-18 04:34:51.572901

sqlite> .schema polls_choice
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id"));
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

sqlite> select * from polls_choice;
1|Not much|0|1
2|The sky|0|1
3|Just hacking again|0|1
4|Yes|0|2
5|No|0|2
#+end_src

So, we see that each choice has FOUR attributes -- an ID for itself, a text, a count of votes, and the ID of the question to which it is associated.

Note that each choice uses the question ID -- in my example above, I used people's names, but using an ID is more natural. For one thing, it lets people change their names without having to change it in a lot of places, and I don't have to worry about them being spelled slightly wrong. For another, names aren't unique, but IDs are.
*** Many-to-many relationships
The example in the tutorial defines a many-to-one relationship -- one choice belongs with one question, but one question has many choices. This kind of relationship, as well as the even simpler one-to-one relationship, is generally implemented by putting the ID of the related object in the table.

There's another kind of relationship between entities called a many-to-many relationship. The relationship between people and hobbies is a good example. Each person has many hobbies, and each hobby can be associated with many people. Traditionally, this is implemented using a "join table" -- a table that just tracks the IDs of both objects. So you might have:

A "people" table:

| ID | Name    | Number of Pets |
|  1 | Ethan   |              1 |
|  2 | Rita    |              0 |
|  3 | Francis |              2 |

A "hobbies" table:

| ID | Hobby        |
|  1 | Chiptune     |
|  2 | British rock |
|  3 | Death metal  |

The "person-to-hobbies link table":

| Person ID | Hobby ID |
| 1         | 1        |
| 2         | 2        |
| 3         | 3        |
| 3         | 1        |

Django can handle this for you too, but you'll have to read more documentation: https://docs.djangoproject.com/en/1.8/topics/db/examples/many_to_many/.
*** Homework
- Let's start small -- instead of a whole dollhouse, let's just design a schema for a paper doll application. A paper doll has a name (e.g. "Princess" or "Zoe") and some articles of clothing. Each article of clothing has a filename (e.g. "gloves.png") and a location (e.g. arms, torso, legs, head). What should the tables look like?

- Go through the tutorial again and try to create another application in your existing site. Call it "paperdolls". Try to define the models the same way they do in the tutorial. To test them, try going into the shell and create objects the way they did (although using your models instead of the polls one). Post any error you get to the mailing list, along with the contents of your models.py.
** Views pt 1
*** Homework review
Here are my solutions:

**** Solution 1
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    doll = models.ForeignKey(Doll)

    filename = models.CharField(max_length=200)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Doll ID | Filename      | Location |
|  1 |       1 | gloves.png    |        2 |
|  2 |       1 | red-dress.png |        0 |
|  3 |       1 | sandals.png   |        3 |
|  4 |       2 | tiara.png     |        1 |
|  5 |       2 | lab-coat.png  |        0 |

**** Solution 2
#+begin_src python
class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class Doll(models.Model):
    name = models.CharField(max_length=200)
    torso_item = models.ForeignKey(ClothingItem)
    head_item = models.ForeignKey(ClothingItem)
    arms_item = models.ForeignKey(ClothingItem)
    legs_item = models.ForeignKey(ClothingItem)
#+end_src

Dolls table:
| ID | Name     | Torso | Head | Arms | Legs |
|  1 | Princess |     2 | ???  |    1 |    3 |
|  2 | Zoe      |     5 | 4    |  ??? |  ??? |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

**** Solution 3
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class DollWearsClothing(models.Model):
    doll = models.ForeignKey(Doll)
    clothing_item = models.ForeignKey(ClothingItem)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

Doll Wears Clothing table:

| ID | Clothing ID | Doll ID | Location |
|  1 |           1 |       1 |        2 |
|  2 |           2 |       1 |        0 |
|  3 |           3 |       1 |        3 |
|  4 |           4 |       2 |        1 |
|  5 |           5 |       2 |        0 |
|  6 |           3 |       2 |        3 |
*** Syntax
Syntax refers to the structure of a language. In English, the sentence "The dog bit the man" is well-formed according to English syntax. The sentence "The bit dog man the" has invalid syntax. The sentence "The man bit the dog" has valid syntax but questionable semantics. In programming languages, we sometimes use "syntax" as an umbrella term for all the rules of the language that give it sense to the computer, which also include semantics.

Depending on how far you've gotten in the Django tutorials, you've seen lots of different syntax so far:

- =from foo import bar= at the beginning of a bunch of different files
- =class Foo():= for models
- =blah = models.CharField()= for fields in those models
- =def __str__():= when defining models
- =INSTALLED_APPS = (...)= when "activating" models
- ='words'= and sometimes ="words"=
- =def foo():= for views
- =urlpatterns = [...]= when setting up views
- =url(r'...', foo)= when setting up views
- =%= in some views

I'm going to touch on the essentials of the most important parts of the most important ones of these, and mention a few details about some of the others, because the goal is to get us up and running as fast as possible without wearing you down with details that aren't important yet. These are just simplistic summaries!
*** Django settings: variables
In almost any programming language, you can do stuff like this:

#+NAME: print_variables
#+begin_src python :results output
x = 5
print(x)
print(x + 3)

x = 6
print(x)
print(x + 3)
#+end_src

If I run this program, it will show:

#+RESULTS: print_variables
: 5
: 8
: 6
: 9

What's going on is that when Python sees the line =x = 5=, it creates a thing called =x=. Wherever it sees =x=, it checks the last value it got for =x=, which in this case is 5. =x= is called a variable, and you can think of it as like a box in the computer's memory that has some "value" inside of it. When Python then sees the line =x = 6=, it will take the 5 out of the box and put the 6 in.

There are many different kinds of values that we can put into a variable.[1] In the above example, =x= is an integer (in Python, we say =x= is an =int=). You can also have bits of words and sentences in variables: just do =x = 'hello'= or =x = "hello"= (they're equivalent). These bits of text are called "strings" (in Python, we say they are =str=). You can have truth values =True= and =False=, which are called Booleans (in Python, =bool=). You can also have lists, which are written =x = [1, 2, 3]= (in Python these are called =list=\ s, but in other languages they're called arrays or vectors). There's also something called a tuple, which is written =x = (1, 2, 3)=, but for now we're going to say it's the same as a list.

There are a bunch of places where you get to customize how Django does some things. We've already seen that we need to update =INSTALLED_APPS= when we add a new app. =INSTALLED_APPS= is an ordinary variable that Django gives some special meaning to. Most of these variables are written in all uppercase, but some (like =urlpatterns=) aren't, and you just have to know that they're special.

[1] In some languages, each variable has to be "declared" to hold only some types of values. Python isn't like that; instead it uses "dynamic typing", which means that any variable can hold any value, and even change from one type of value to another. This has advantages and disadvantages.
*** def foo(): functions/methods
Any time you see =def foo(...)=, we are defining a function. A function is a part of a program. Like a program, a function has some operands, which are called parameters or arguments, and a result, which is called the "return value". Here's an example:

#+begin_src python
def check_password(password):
    if password == 'stairs_are_history!':
        return True
    elif password == 'swordfish':
        return True
    else:
        return False
#+end_src

Here's how you might use it:

#+begin_src python
user_password = input()
password_correct = check_password(user_password)
if password_correct:
    print("Welcome back!!")
else:
    print("Incorrect password")
#+end_src

So when you see the code =check_password(user_password)=, that's saying "Begin doing the stuff under =def check_password=. Also, when doing those things, the variable =password= is going to have the value that =user_password= does.[2][3]" Then, Python goes through line after line, doing what that line says, until it either gets to the end of the =def= or it hits a =return=. If it hits a =return=, the function immediately ends and the value after the =return= is sent to wherever the =check_password()= line was.

Using a function is a nice way to group some commands together and use them many times in different places. For this reason, Django uses them to represent views.

The syntax for a function is:

#+begin_src python
def FUNCTION_NAME(PARAM1, PARAM2, ....):
    STATEMENT1
    STATEMENT2
    ...
#+end_src

N.B. A function definition ALWAYS has a colon (=:=) after the parameter list, and the statements in the function are ALWAYS "indented" by four spaces. Some of those statements might have their own sub-statements, which might be inset by another four spaces, and so on. The function continues until Python sees a non-blank line that isn't indented by four spaces.[4]

To use the function, you write the name of the function, plus the things you want the function to operate on. Then Python will start doing the various statements, one after the other. If the function is going to return something, you can put a variable in front of it, or use it in another function, or whatever.

As a general rule, using a function looks almost exactly like using an entity or a class, but functions usually have lowercase names and entities and classes have Capitalized names.

You can also define functions inside classes; these are called methods and we'll talk more about them several weeks from now. In the first part of the tutorial, you defined one called =was_published_recently=.

=__str__()= is a special method that is used whenever an object needs to be displayed. We won't dwell on it right now.

[2] Again, it isn't necessary to specify a type for =password=; like any variable, it can take any value.

[3] =password= is what's called a "local" variable; it will disappear as soon as the function is over.

[4] Some of you have been using TABs instead of spaces. In the Python community, this is discouraged -- it should always be 4 spaces. If you're lucky, you can set up your text editor to insert 4 spaces when you press the TAB key. For instance, on =gedit=, I was able to find a thing on the bottom of the window that says "Tab width: 8 spaces"; clicking on it let me set it to 4 spaces and "use spaces instead of tabs".
*** import
In Python, when we want to use models, functions, or variables from another file, we use the =import= command. There are many different ways to import things, none of which we're going to discuss now. If you forget to import something, you'll usually get a =NameError= saying that something wasn't defined.
*** . ("dot")
*** Homework
Go through all the files in your site so far. Find examples of the following:
- functions being used
- stuff being imported
- a list
- a tuple

Press on and try to get to the end of part 3 of the tutorial. Hopefully by now we are starting to see how Django lets us build a web application.
** TODO add to email
Solution 1 is what I expected most of you to come up with. It lets you match clothing with dolls. One nice advantage to this system is that we can have multiple articles of clothing on the same doll in the same place. (So, socks and then sneakers, for example.) Similarly, you can have 0 articles of clothing on a part of the doll. Of course, if your requirements don't need/forbid this, that might be a disadvantage.

Solution 2 is kind of like a straw man, devil's advocate thing. Last week I said this isn't really possible because we don't know what to put in the =???= places. In fact, there is a way -- there's a thing called =NULL= which is like an empty space. Some people say =NULL= [[http://c2.com/cgi/wiki?NullsAndRelationalModel]["violates the relational model"]], which might or might not mean anything, but it certainly can make your life difficult if you expect something to never be =NULL= when in fact it sometimes is. For this reason, all fields in Django are not allowed to be =NULL= (this is also enforced by the database). If you want to change this, you can use the [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#blank][blank]] and [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.Field.null][null]] options in your fields.

Solution 2 doesn't let you have multiple articles in the same place, but it does have one nice advantage which is that it's easy to "share" an article of clothing between two dolls -- you just re-use the ID. In Solution 1, this would require duplicating the filename, which is error-prone. (If you move the filename and forget to update it everywhere, you will have a data consistency problem.)

Solution 3 has the advantages of both solution 1 and solution 2 -- you can share clothing, plus you can have multiple clothing in the same place. But there's something weird in it, which is that the location of the same article of clothing can be different for different dolls.

Any of these solutions might be OK depending on what your requirements are, but I'd probably go with solution 3, but move =location= to the Clothing table, and I'd add a column to the Wear table that specifies order (so that socks always go under sneakers).
** office hours
*** exercise 1: change your index view to say "This is the paper dolls index"
*** exercise 2: make it show your index view when you go to polls/hello
*** exercise 3: create a new view that says "I finished exercise 3!" when you go to /ex3
** urlpattern exercises feedback
- /blog was intentional; the goal was to hammer in the point that the name of the files on-disk don't have to correspond to the names in the URLs.
- In exercise 4, when we want to match any player's name, we can use the dot character ('.') in the pattern to match anything at all.
- You can use the name of a view directly in the site's urlpatterns -- you don't have to include a file if you don't want to. You can just give the path to the view and Django will import it for you. So for example you can write 'polls.views.index'. The last part of the path represents the name of the view; everything else represents the name of the module where to find the view.
- For the last exercise: yes, in fact, you can make this work -- the Drupal CMS is set up like this. Everything is just a "node" and depending on what kind of node you get out of the database, you then do something different with it. Yes, this is kind of backwards, and nobody sane does it. Drupal is written in PHP, so you can safely consider them insane.
** Views pt 2
Outstanding questions: what is this .format() business?

It's a pretty common situation where you want to have a string built from text and variables. Here's the "simple" way to do that in Python:

#+begin_src python
x = 5
y = 10
s = "The sum of " + str(x) + " and " + str(y) + " is " + str(x + y)
#+end_src

Kinda wordy. So most recent languages offer something called "string interpolation", which is a mechanism whereby the language can help "fill in" the string with other bits of text.

Python actually has two string interpolation mechanisms. The tutorial uses this form:

#+begin_src python
x = 5
y = 10
s = "The sum of %s and %s is %s" % (x, y, x+y)
#+end_src

In the exercises, I used this form:

#+begin_src python
x = 5
y = 10
s = "The sum of {} and {} is {}".format(x, y, x+y)
#+end_src

The first format is older, and inspired by older mechanisms like C's ~printf~. The second one is newer and more powerful. For instance, if you forget which one is supposed to be x and which one is supposed to be y, you can do this:

#+begin_src python
x = 5
y = 10
s = "The sum of {x} and {y} is {xplusy}".format(x=x, y=y, xplusy=x+y)
#+end_src

The full details are available in https://docs.python.org/3.5/library/string.html#format-string-syntax.
*** Recap to this point:
We've actually learned a lot of "mini-languages", including SQL, regular expressions and format strings. We're actually going to learn another three or four in the near future -- today's is the Django template system.
*** Templates
So far we've written views that just produce responses. But an actual web page is an enormous blob of HTML, some of which is shared between pages and some of which is completely different. Dumping all of that into your ~views.py~ file would rapidly become unmaintainable.[1] So most web frameworks offer a notion of "templates", which are another mini-language that make it easier to generate HTML.

Here's a template (let's pretend we saved it as ~polls/some-template.html~:

#+begin_src jinja
Hello, {{ thing }}!
#+end_src

In Django, the usual way to use a template is to turn it into an HttpResponse, like this:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

The ~render~ function takes three arguments -- the request, the name of the template, and any arguments for the template. These arguments are sometimes called a /context/. The template can access anything in the context. Together, the above should produce:

#+begin_example
Hello, world!
#+end_example

Templates help institute a division between code and presentation. Typically front-end engineers work on templates (and CSS and JS), and back-end engineers work on code that provides stuff to those templates. We're going to be working a little bit on all of these.

[1] Maintainability refers to the property of software to be maintained, i.e. understood, debugged, updated and changed to do new things or to do them better. Maintainability is a big deal for software engineers. Usually maintainable code beats fast-to-write code, and fast-to-write code usually beats fast-to-run code, but this depends on what section of software you're in.
*** Contexts
A context is just a collection of variables for a template. Like all variables, these variables have a *name* and a *value*. In the example above, we created one variable called "username", whose value was "Ethan". Contexts are usually defined using syntax like:

#+BEGIN_EXAMPLE python
now = timezone.now()
ctx = {"username": "Ethan", "now": now}
#+END_EXAMPLE

This syntax means a "dictionary", which is made up of *keys* (before the colons) and *values* (after the colons).  You can look up the value for a particular key, or look at all values, or all keys.  If you access ~ctx["username"]~, that will produce "Ethan".

A context is a dictionary where all the keys are strings.
*** Template language
**** Default is to output
Most template languages are geared towards producing output. In fact, to produce output, you don't even need to give a command -- you just write text. Anything you write will be copied to the output.

Example:

#+begin_src jinja
This is some text without anything special going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

Produces:

#+begin_example
This is some text without anything special going on.
#+end_example

Note that when you're looking at your template, you're looking at plain text, but the template is being rendered as HTML, which is a bit different. In particular, blank lines in text are just spaces in HTML.
**** You can use variables
To access things from the context, you can write two curly braces, then the name of the thing in the context, and then two curly braces.

Example:

#+begin_src jinja
This is some {{ field }} without anything {{ adjective }} going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "field": "words", "adjective": "unusual", "name": "Ethan"
        })
#+end_src

Produces:

#+begin_example
This is some words without anything unusual going on.
#+end_example

As the example shows, you don't have to use everything in the context. It turns out that in Django's template language, you can try to use variables that *aren't* in the context and they will just silently fail and print nothing. I would encourage you not to rely on this behavior if you can avoid it.

You can also access attributes the same way you do in Python. So let's say you have some object in your context, like this:

#+begin_src python
def my_view(request):
    q = Question(id=1, question_text="What's up?")
    return render(request, "polls/some-template.html", {
        "question": q
        })
#+end_src

You can get the text "What's up" using:

#+BEGIN_EXAMPLE
Please answer the question: {{ q.question_text }}
#+END_EXAMPLE

Of course, you can access attributes of attributes of attributes, more or less the same way you do in Python:

#+BEGIN_EXAMPLE
You chose {{ c.choice_text }} for {{ c.question.question_text }}
#+END_EXAMPLE
**** Conditionals
Sometimes you have two different things you might want to do. For example, if polling has closed on a question, then maybe you don't want to let people vote, but if it hasn't closed yet, then you do.

#+BEGIN_SRC jinja
{% if q.was_published_recently %}
  OK, you can vote on this question.
{% else %}
  Sorry, polling has closed on this question.
{% endif %}
#+END_SRC

This is very similar to if statements in Python, which I think we saw a little bit of already, so I won't dwell on it. As in Python, you can write some (limited expressions) as the "condition". For example, here's how you could check if a choice hadn't received any votes yet.

#+BEGIN_SRC jinja
{% if c.num_votes == 0 %}
  Nobody has voted for this choice yet!
{% endif %}
#+END_SRC

N.B. The ~if~ command in Django templates is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~! Don't confuse the two!
**** Looping
So far we haven't talked much about types, but hopefully you remember that ~[1, 2, 3]~ is a list. If you have a list of things, you can do something with each element. So let's say we have:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "numbers": [1, 1, 2, 3, 5, 8]
        })
#+end_src

And the template:

#+BEGIN_SRC jinja
Do you notice anything about these numbers?

{% for number in numbers %}
  {{ number }} ...
{% endfor %}
#+END_SRC

This will produce:

#+BEGIN_EXAMPLE
Do you notice anything about these numbers?

  1 ...
  1 ...
  2 ...
  3 ...
  5 ...
  8 ...
#+END_EXAMPLE

This structure is called a *loop*. We haven't had to use it in Python, but it exists there and is very similar. Lots of things produce lists or other loop-able structures. How it works is, first ~number~ is set to the first thing in ~numbers~. Then, everything between ~{% for .... %}~ and ~{% endfor %}~ is run. Then, we go back to the top. ~number~ gets set to the *next* thing in ~numbers~, and then everything between ~{% for ... %}~ and ~{% endfor %}~ is run again. And so on, until there's nothing left in ~numbers~.

N.B. The ~for~ command, like the ~if~ command and most other commands in Django templates, is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~.
**** Filters
Certain other operations are allowed using a concept known as a "filter". For example, you can get the length of a list using:

#+BEGIN_SRC jinja
There are {{ numbers|length }} numbers.
#+END_SRC

You can select the first element of a list using:

#+BEGIN_SRC jinja
The first number is {{ numbers|first }}.
#+END_SRC

If you have a string you can convert it to lowercase using:

#+BEGIN_SRC jinja
When I am feeling blue, I sign my name as {{ name|lower }}.
#+END_SRC

There's even a "pluralize" filter that helps apply the rules for English pluralization (use a singular if n = 1, otherwise use plural). This isn't safe for international websites, but it's a useful shortcut otherwise.
#+BEGIN_SRC jinja
Here are your item{{ num_items|pluralize }}:
#+END_SRC

You can chain filters too, so if you want the first letter of a string, converted to lower-case, you can do:

#+BEGIN_SRC jinja
Not everyone's name can begin with {{ name|lower|first }}.
#+END_SRC
**** Summary
Django templates are actually tightly limited in scope. The designers of Django wanted to prevent people writing templates from having the ability to break a site by writing a bad template. However, the operations available in a template are specialized for generating text, so despite the limitations, they are still more useful than writing HTML in Python files.

A complete summary of the "built-in" functionality in the template system is available at https://docs.djangoproject.com/en/1.8/ref/templates/builtins/.
*** Database access
We've already agreed that a web application stores its data in a database, and so Django has to provide some mechanism that our websites can use to get data into and out of our database. We saw some of this in part 1 of the Django tutorial, but now is when we can really apply it. We need objects to give to our templates, and these objects are often going to come from the database, so let's review how we can do that.
**** Retrieving an object
Access to objects in the "database", rather than just a single object, or the model itself, is done through an ~objects~ field. If you have a model called ~Question~ and want to retrieve the one with ID 5, you can do:

#+BEGIN_SRC python
q = Question.objects.get(pk=5)
#+END_SRC
**** All objects
You can get access to all objects using the ~all()~ method:

#+BEGIN_SRC python
qs = Question.objects.all()
#+END_SRC
**** Filters and field lookups
What if you want only some of them? For example, you might want to get all the ~Questions~ that have a ~pub_date~ that is already passed, or you might want to get all the ~Choices~ with no votes. In this case, you add a filter using the ~filter~ method. Some examples:

#+BEGIN_SRC python
now = timezone.now()
qs = Question.objects.filter(pub_date__lte=now)
choices = Choice.objects.filter(votes__exact=0)
#+END_SRC

The parameters to ~filter~ are known as "field lookups". You can add as many as you like in a call to ~filter~. Each one expresses some criteria of the objects you are looking for.  These "lookups" are composed of (1) the field name that you are concerned with, (2) a double underscore (~__~), (3) some comparison you want to make with that field, (4) an equals sign (~=~), and (5) something to compare against. So, in the above, we see ~pub_date__lte=now~; ~pub_date~ is the field, and we are looking for the cases where that is ~lte~ (less than or equal to) whatever we have as ~now~. Similarly, ~votes__exact=0~ means to find all choices where the ~votes~ field is ~exact~ (exactly equal to) the value ~0~.

All fields are the ones we defined as fields in the model. However, if the field you want to use is a foreign key, you have to add a ~_id~ to the field name. So if we want to get all the choices for ~Question~ with ID 5, we write:

#+BEGIN_SRC python
choices = Choice.objects.filter(question_id=5)
#+END_SRC

There's one short-cut with field lookups -- if you don't specify a comparison, it's assumed to be ~exact~. So we can instead write:

#+BEGIN_SRC python
choices = Choice.objects.filter(votes=0)
#+END_SRC

(In fact, this is how the ~pk=5~ example above works too.)
**** Full documentation
A complete reference is available at https://docs.djangoproject.com/en/1.8/topics/db/queries/. Field lookups are also documented more extensively at https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups.
** Comments on the exercises
*** Types of model object
We've seen three different kinds of object:

- Model class. These are usually written in capitals (a.k.a. CamelCase) like ~BlogPost~. Model classes define fields, but don't themselves have those fields, so you can't do ~BlogPost.post_text~.
- An *instance* or object of this model class, like ~BlogPost.objects.get(pk=5)~. These are usually put in variables with lower-case-with-underscores names (a.k.a. snake_case, named for Python). If you have ~blog_post = BlogPost.objects.get(pk=5)~, then you can access its fields using ~blog_post.post_text~.
- There's also a "manager", which is the thing you see at  ~BlogPost.objects~. You go from the model class to the manager, and the manager provides access to the objects.
- There's also another type, which is "list of objects":
~BlogPost.objects.all()~ or ~BlogPost.objects.filter(...)~. If you have a list of blog post objects, each one of them will have those fields, but the list itself won't.

Model classes are like cookie cutters, and instances are like the cookies they've cut out. The model class defines the shape of the objects, and how they get made, but isn't itself one of them.
*** RequestContext
For the purposes of this exercise, we don't really need a ~RequestContext~ -- we could use the simpler ~Context~, which doesn't need access to the request -- but we may as well use the ~RequestContext~ everywhere. It's only actually used in a few cases -- the ~LocaleMiddleware~ tries to guess what language the user speaks, which is used when you use ~{% trans %}~ in a template, and there's a thing called *CSRF* which requires sending something to the user when you render templates.
*** for loops
A for loop repeats some set of operations for each object in a list. So, you have to have a list.

#+BEGIN_SRC jinja
{% for blog_post in my_list_of_blog_posts %}
  {{ blog_post.post_text }}
{% endfor %}
#+END_SRC

This means to take the first object in my_list_of_blog_posts, and then do everything "inside" the for loop, with ~blog_post~ being that object. Then, go back to the top and repeat, with ~blog_post~ being the *second* object, and so on.
*** What goes in a view vs. a template?
Django structures stuff according to a paradigm called "model-view-template" (MVT). (Other frameworks work similarly but with different names for the different layers.) This division allocates responsibilities as follows:

- Models: the one "source of truth" for how your data should look and behave.
- Views: responsible for actually responding to user requests and translating that into access to models
- Templates: responsible for presenting the output of the views to a user -- this is the "user experience" part.

What goes in which area is a little bit inexact, and reasonable people can disagree, but most people agree with this vague division.

In these particular exercises, the question of where to put the logic that fetches a blog post's comments could be argued either way. You could put it in the template if you think it's a user interface concern how, if, and whether we display comment information. You could put it in the view if you believe that the main concern here is deciding what data to fetch and how to fetch it. In particular, there are some optimizations you can make if you do the fetching all at once in the view rather than post-by-post in the template. It's also a little surprising if you "accidentally" do database queries in the template, because that might eventually impact performance.

FIXME: The above isn't 100% since fetching in the view is probably correct but it's an optimization that doesn't change how the template looks.

About templates in particular, a good rule of thumb is that you've done a good job dividing stuff between your view and your template if you only have to change your template when someone comes to you and says "Actually, the way we're presenting this information isn't what we want. Can we present it this other way?" (But don't get dogmatic! It's always better to be inconsistent than to have unmaintainable code.)
*** Limits of Django templates
Because of the above division, Django templates are written to be *very* limited. You can't even call functions in a template! There's one exception to this: if you have a "method" like ~obj.foo()~, you can write that in a Django template like ~{{ obj.foo }}~, without the parentheses. Yes, this is crazy, but you might need this to access all the comments for a blog post.
*** Length of a list
In regular Python, you would write ~len(my_list)~. In Django templates, you have to write ~{{ my_list|length }}~.

Different languages and environments have different names for this operation -- ~size~, ~count~, ~length~ are all common. Python's a little unique in that it writes ~len(my_list)~ instead of ~my_list.len~. (This is for historical reasons.)
*** Formatting/style
Software engineers *love* to argue about formatting of source code, often to the detriment of actual engineering. I try to stay limber about these sorts of things and I'd encourage you to as well, at least until you originate a project from scratch and can bend people to your will.

Some "meta-guidelines":

- When in Rome, do as the Romans do. Your code should look like code in the same file, or the same project, or code that works with the same framework.
- Languages often define standards for how code should look. In Python, the standard to follow is PEP8. I don't know of a standard for Django templates.
- Break the rules if it makes something easier to read.

Some generic guidelines:

- When lines get too long, break them into several. "Too long" varies by taste; I prefer about 120 characters, but a lot of people still prefer 80 characters.
- When you find yourself repeating something, turn it into a variable or a function.
- Naming things is really hard, but really important.
- Similar things should go together. Different things should go apart. (This might mean separate functions, separate parts of a file, separate files, or separate projects.)
** CSS pt 1
Reading for this week:
https://www.girldevelopit.com/materials/html-intro, specifically class 2

https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Color (don't feel obligated to read the rest of the tutorial, or earlier parts)

https://docs.djangoproject.com/en/1.8/intro/tutorial06/, use as a reference to try to get your CSS into a page

http://media.mediatemple.netdna-cdn.com/wp-content/uploads/images/css3-cheat-sheet/css3-cheat-sheet.pdf list of a whole bunch of different CSS properties; see also https://developer.mozilla.org/en-US/docs/Web/CSS/Reference which is linked to good references for them
*** Overview
CSS is yet another language that we use to apply style to our pages.

In CSS, you write *rules* which apply to your HTML elements. Each rule changes some properties of the elements in question.

#+BEGIN_SRC html
  <html>
    <body>
      <p>This is the first paragraph</p>
      <ul>
        <li>This is item 1</li>
        <li class="special-list-item">This is item 2</li>
        <li class="special-list-item warning">This is <em>item</em> 3</li>
      </ul>
      <p class="final-paragraph">This is another paragraph</p>
    </body>
  </html>
#+END_SRC

#+BEGIN_SRC css
  p {
    color: #f00;
  }

  .final-paragraph {
    color: #ff0;
    background-color: #000;
  }

  li {
    text-decoration: underline;
  }

  .special-list-item {
    text-transform: uppercase;
  }

  .warning {
    background-color: #f00;
  }

  em {
    font-style: italic;
  }
#+END_SRC

This will cause the first paragraph to have red text, and the last to have yellow text with a black background; list items will be underlined, and the second and third will be written in uppercase, and the third will have a red background; the last word "item" will be italicized.

CSS rules apply to multiple elements, and each element can be affected by multiple rules. When this happens, there is a "cascade", which merges properties according to certain rules (which we'll get to later; for now, let's just say later rules override earlier rules).

HTML elements can have "classes" and "ids" that serve no purpose other than to "hook up" to CSS rules. Accordingly, you can use whatever classes and IDs you like. Stylistically, classes and IDs are often separated with hyphens (which isn't even possible in Python).

To debug CSS rules, you can use your browser's development tools. For example, you can right click on an element and select "Inspect element" to look at what the browser believes the HTML is and what rules apply to it.

Generally, we try to maintain a consistent "look and feel" throughout our site, which includes consistent templates and style; we'll touch more on that in future weeks.
** CSS part 2
*** Template inheritance
The exercises encouraged you to add some things to every page. Of course, that's bad practice (because it's tedious to add and to change; Don't Repeat Yourself). Django templates include a powerful feature called "template inheritance" that lets us get rid of this. The basic idea is that you set up a "framework" template, and the templates for individual views "inherit" the framework from that template.

The Django docs are pretty good for this, so here's the link: https://docs.djangoproject.com/en/1.8/ref/templates/language/#template-inheritance
*** A warning
I'm not really specialized in front-end stuff, although I can get by in a pinch. I'm not 100% up to date on the hot trends or the cool new things, and I'm not exactly sure what to point you at. Here's the lay of the land re: CSS.

- The Bad Old Days: Layout was done using ~<table>~ s. Styling was done directly as HTML attributes (~<font>~ tags, ~<table bgcolor="#fff">~, etc.). Exceeding these constraints meant going to Flash. IE <5. About these techniques and this worldview I know almost nothing. I know at least one web developer who "got out" before this period ended.

- Antiquity. Introduction of CSS: separation of content from style. Front-end web development means knowing stupid CSS tricks that you could use to make a design work in IE as well as other browsers. See http://www.quirksmode.org/css/csshacks.html. IE 5-6.

- Middle Ages. CSS coming into its own. CSS gradients, rounded corners. IE 7-8.

- The Renaissance. Chrome, Firefox, and Webkit rule the skies, and seize on this position to introduce of a stream of new technologies to enhance the web experience: HTML5. LocalStorage, Canvas, WebGL, Geolocation. IE 9-10, starting to become a real browser.

- The future. Responsive design/mobile browsers. The death of Flash. Flexbox?
*** Block and Inline
Already we've seen two different kinds of elements: ~<p>~ elements, which cause a "break" in the flow of text, and e.g. ~<i>~ which just wraps around some element of text. These two kinds of elements are referred to in the specifications as "block" and "inline" elements. Block elements tend to break text, and inline elements don't. Inline elements can be broken across several lines if they're too long. Text itself is generally inline, although it may be included in a block element. One common surprise is that the ~<img>~ element is also inline by default.

Among other behaviors, inline elements cannot have dimensions set for them using the ~width~ or ~height~ property -- they take their size from the size of their enclosed content. Block elements can; their default ~width~ and ~height~ are ~auto~, which means they take up as much width as they can, and only as much height as they need for their contents.

All of this behavior is controlled by the CSS property ~display:~. Changing an element's ~display~ will have numerous effects, some of which you may not anticipate. The most common values are:

- ~display: none;~ -- completely hides the element
- ~display: inline;~ -- covered above
- ~display: block;~ -- covered above
- ~display: list-item;~
- ~display: inline-block;~ -- like ~display: inline;~, but supporting ~block~ properties like ~width~ and ~height~, and can't be split across several lines
*** <div> and <span>
There are two HTML elements that are extremely important because they don't do anything. Those elements are called ~<div>~ and ~<span>~. Unlike almost every other HTML element, they have no built-in styling or any semantic meaning whatsoever. In order to style them, you use classes and IDs like we saw last session. The only semantics associated with them is that ~<div>~ is, by default, ~display: block;~, and ~<span>~ is, by default, ~display: inline;~.
*** Floats
So far we've just been dropping blobs of stuff in a vertical line down the page. If we want to do fancy stuff like lay things out side by side, we need more techniques. The first one was designed for a specialized use case -- where you have some image that you want to "inset" into some text -- but then that turned out to be the best way to get stuff done in the real world. See https://developer.mozilla.org/en-US/docs/Web/CSS/float.

"Floating" an element has a few interesting consequences:

- it is "removed from normal flow", so wherever it was, now it's like it wasn't there
- it gets placed relative to its "containing box", which is a containing element that is either floating or positioned (see https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context)
- if the element is ~width: auto;~ it will "shrink" to just big enough to contain its content
- other floating elements will get pushed up against it... even if they are in a totally different part of the HTML (because they're removed from normal flow).

The "antidote" to floating is to specify the ~clear: both;~ property. Putting this on an element means it will be pushed down until it can fit without leaving room for the floated element.
*** Positioning
Floating is super useful because you can stack up elements in order without specifying their positions in any way. However, there are a couple of cases where it is useful to specify them more exactly. For that, you can use the ~position~ property. When you use ~position:~, you also have to use ~top~, ~left~, ~bottom~, and ~right~ to specify position exactly.

https://developer.mozilla.org/en-US/docs/Web/CSS/position
*** CSS/HTML Style
**** Semantics vs. presentation
One important idea in modern web design is that HTML elements should dictate what your content is, and how it relates to other content in your file, and not cover styling at all. For example, you shouldn't use ~<p>~ elements to insert spacing -- you should use them to signal that some bit of text is a paragraph (instead of a headline or an element in some list).

Similarly, ~<i>~, ~<b>~, and ~<u>~ (which you might have learned as the elements for italic, bold, and underlined, respectively) don't have semantic meaning of their own, so they're considered deprecated. Instead consider ~<em>~ (emphasized) and ~<strong>~.

This is really the only reason to use any particular HTML element. After all, with CSS, you can make anything look like anything.
**** Measurements
For a while some people were saying you should use percentages and ~em~ instead of ~px~ to measure stuff, but I forget why, so maybe do that?
**** Different window sizes
Be sure your website looks OK if you resize your browser window. Not everyone uses their browser full-screen.
**** Accessibility
Some users of your web page aren't going to be looking at it -- they'll be hearing it through screen readers and tabbing through it with keyboards. To the extent possible, we should support those users too.

http://www.w3.org/WAI/intro/accessibility.php

http://www.w3.org/WAI/intro/wcag.php

Most people and companies don't take this as seriously as they should.
*** More resources
http://caniuse.com/ -- see e.g. http://caniuse.com/#feat=webgl

http://www.w3fools.com/ and associated links
** CSS part 3: random notes
*** Measurements
CSS offers both "absolute" (like px) and "relative" (like %, em) measurements. Relative measurements are computed relative to their parents or containers.
*** Grids
*** Homework
- One view which renders a dollhouse
- Dollhouse (i.e., what background? what elements?) actually fetched from the database
- Dollhouse actually rendered visually -- some background, some elements placed correctly
** Forms and HTTP
I'm not going to cover much about the HTML necessary to write forms, or how to use the Django forms library -- I figure you can probably learn that on your own. But of course, sing out if you have problems.

The thrust of this lesson is about HTTP requests, which are the underlying mechanism for basically everything we've done so far and are especially important in handling forms. This is because the Django forms library is sort of old-fashioned -- modern web applications don't usually submit and refresh the entire page any more, but they still use HTML forms and HTTP requests.
*** Reading
Read one of these two. I think the first one is "better" (it's certainly shorter) but it may be less accessible.
http://www.jmarshall.com/easy/http/
http://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html

This provides some amount of overview of how forms work in HTML and HTTP, but with an emphasis on using them in Django. There's one point about forms in Django that you will need to know in order to get them working, and that's the csrf_token thing that they do in the example. Stop at "More about Django Form classes".
https://docs.djangoproject.com/en/1.8/topics/forms/

Wikipedia's got some sort of light but dense information about forms themselves:

https://en.wikipedia.org/wiki/Form_%28HTML%29

Also, about HTTP request methods:

https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
*** HTTP
A web application is a program that responds to "requests" from web browsers -- these requests are made using a protocol called HTTP. In HTTP, each request has a "method" (sometimes called a verb).

In Django, you can access information about the request by using the "request" variable that your view takes. For example, you can get the method being used by examining ~request.method~. The URL of the request is also available, but it's broken up and parsed. In a URL like http://localhost:8080/blog/index?month=December&author=Ethan, the parts we usually care about are the *path* (~/blog/index~, which is available as ~request.path~) and any *query arguments* (~month=December&author=Ethan~). Note that a request can have the same parameter multiple times, as in http://localhost:8080/blog/index?author=Rick&author=Ethan. What this "means" is up to the application to decide.

The most common and important kind of request is the kind that the web browser makes when it goes to a particular URL. In these requests, the web browser requests the contents of that URL. These requests are called "GET requests" because they use the GET method.

In a GET request, Django provides access to the query parameters as ~request.GET~. So, in the above example, you could do ~request.GET["month"]~ to get ~December~. These parameters are always strings. If you need them to be something else, you'll need to convert them. (See https://docs.djangoproject.com/en/1.8/ref/request-response/#django.http.QueryDict for more.)

HTML forms (which you may have seen before) are often submitted to web applications using the POST method. The POST method is used to send data to the web application. There are several other methods, but web browsers typically don't support them directly, so we'll skip them for now. In a POST request, parameters are accessed using ~request.POST~, which behaves the same as ~request.GET~.

(You may have encountered the HTML attribute ~method~ before. ~method~ goes on ~<form>~ elements and you can have the method ~GET~ or ~POST~. This is what that's about.)

The difference between ~GET~ and ~POST~ is that when you use ~GET~ in your application, you're saying that the request is /safe/. Safe requests shouldn't change the state of the application. RFC 7231 explains that a request is safe "if their defined semantics are essentially read-only".

A request that updates a blog post would not be considered "safe", and should use POST. A request that searches for a blog post probably is "safe" and thus can use GET.

HTTP requests contain a lot of information, and a web browser makes lots of them in normal usage.
*** Demo
Make a GET request with a form as well as a POST request. Log both in Wireshark. Show what they look like.

Requests that contain uploaded files are a tiny bit different from those we saw today, but we won't cover exactly how they look on the wire.
** Functions
A function is a "piece" of a program, or a mini-program. Like a program, a function is a series of instructions. A function is those instructions packaged up and made easy to re-use.

A well-designed function serves as an abstraction -- something that lets you accomplish a task without 100% understanding what's going on inside.

Functions are just one of several mechanisms available to make code packaged up and easy to re-use. We've already seen modules; modules are also sort of like mini-programs.

To define a function, you write:

#+begin_src python
def my_function_name(some_argument):
    """A docstring. This string describes the function."""

    ... here is where you would put the stuff you want to do ...

    return something  # if it makes sense for your function
#+end_src

To use it, you write:

#+begin_src python
my_function_name(123)
#+end_src

#+begin_src python
result = my_function_name(123)
#+end_src
*** Recursion
Week 1: 1 pair of mature rabbits
Week 2: 1 pair of mature rabbits + 1 pair of immature
Week 3: 2 pair of mature rabbits + 1 pair of immature
Week 4: 3 pair of mature rabbits + 2 pair of immature
Week 5: 5 pair of mature rabbits + 3 pair of immature
Week 6: 8 pair of mature rabbits + 5 pair
Week 7: 13 pair of mature + 8 pair
*** Fibonacci series
F_0 = 0
F_1 = 1
F_n = F_{n-1} + F_{n-2}

fib(100) = 1 * fib(99) + 1 * fib(98)
fib(99) = fib(98) + fib(97)
fib(100) = 2 * fib(98) + 1 * fib(97)
fib(98) = fib(97) + fib(96)
fib(100) = 3 * fib(97) + 2 * fib(96)
fib(97) = fib(96) + fib(95)
fib(100) = 5 * fib(96) + 3 * fib(95)
fib(96) = fib(95) + fib(94)
fib(100) = 8 * fib(95) + 5 * fib(94)
*** conversion to loop

*** Homework
#+begin_src python
  def factorial(n):
      """
      Factorial function.

      >>> fact(5)
      120
      >>> fact(6)
      720
      """
      pass
#+end_src

#+begin_src python
  def list_mult(l, n):
      """
      Repeat the list l as many times as n.

      >>> list_mult([1, 2, 3], 2)
      [1, 2, 3, 1, 2, 3]
      >>> list_mult([1, 2], 3)
      [1, 2, 1, 2, 1, 2]
      """
      pass
#+end_src

#+begin_src python
  def reverse_rec(s):
      """Reverse a string, recursively, one character at a time.

      This doesn't really make as much sense in Python, but some
      languages have more recursive structures for strings that make
      this more natural.
      """
      pass
#+end_src

#+begin_src python
  def flatten(lst):
      """Take a deeply nested list and flatten it to a single level.

      >>> flatten([1, 2, 3])
      [1, 2, 3]
      >>> flatten([[1], [2, 3], [4, 5, 6]])
      [1, 2, 3, 4, 5, 6]
      >>> flatten([1, [2, 3], [[4], [5, [6]]]])
      [1, 2, 3, 4, 5, 6]
      """
      pass
#+end_src

#+begin_src python
  def flatten_dict(d):
      """Flatten a nested dictionary, using a period to separate nested keys.

      Only works if nested keys are all strings.

      >>> flatten_dict({'a': 1, 'b': {'foo': 2, 'bar': 3})
      {'a': 1, 'b.foo': 2, 'b.bar': 3}
      """
      pass
#+end_src
** Complexity theory
Complexity theory is a way to compare the efficiency of algorithms. Algorithms can't be compared directly; you end up having to compare implementations. Worse yet, those implementations also include implementations of languages, of compilers, and of computers themselves. Complexity theory is a way to get around this -- to abstract out the essence of the algorithm so it can be looked at directly.

[N.B. Recall that algorithms are just sets of steps that you can follow to solve a problem, i.e. they're one step short of a program. But frequently it's easier to examine the algorithm when it's embodied in a program. Just be careful that you understand the costs of every operation that the programming language offers.]

Frequently we want to estimate the cost of an algorithm, i.e. how many operations it takes to run, or how much memory it uses. Usually we'll estimate this cost using big-O notation (and its dorky relatives, big-theta and big-omega notation, which are a little academic even for academics). If an algorithm takes e.g. 5 n^2 + 3 n + 12 operations, we say it is "big O of n^2" -- that is, we take the biggest function of n, throw away everything else, and discard any constant factors. (Constant factors tend to be controlled by e.g. speed of hardware, programming language, and other non-algorithmy things that are nevertheless very important.) Sometimes it's enough to just estimate "number of operations" -- sometimes we want to compare against something else, such as "number of times we have to read from disk", or "number of network operations", or some other number of specific operations.

Big-O notation tends to give an "upper bound" to the runtime of an algorithm, which is usually good enough for our purposes, but if you want, you can use big-omega to specify a "lower bound" or big-theta which is supposed to be a more exact bound (both upper and lower).

Sometimes people talk about worst-case, best-case or average-case complexity.

Sometimes you need two variables to express the complexity of an algorithm. Lots of graph theory algorithms require O(V+E) to run. (We'll talk more about graph theory later. It's not graphs in the sense of pictures of mathematical functions.)

Remember that when you're implementing an algorithm, runtime is not the only consideration! Readability and maintainability usually trump runtime, because you usually only have one or two "hot spots" which need to go really fast (if any).
*** Example
http://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html test yourself problem 2
*** Underlying data structures and operations
In order to really do big-O notation justice, you have to understand some of how the computer's memory works, because some operations are hidden by the way the programming language works.

Computer memory is random-access. That means you can go to any place in memory with the same speed. It's almost like each byte of memory in RAM has its own telephone number, and all telephone numbers take the same amount of time to dial, so any byte is equally fast. [Note: this is a gross oversimplification that is nevertheless assumed in complexity theory.]

A single Python variable, like say a variable that contains an int, is just 4 bytes of memory. Thus, to read a variable just takes four phone calls (or, we can say that it just takes one phone call, since we're disregarding coefficients (and also because a 32-bit computer reads memory 4 bytes at a time -- this is called a "machine word")).

Simple mathematical operations are also counted as one single operation. [This is part of the same gross oversimplification.] We say that such an operation is constant-time or O(1).

So how fast is this algorithm?

#+begin_src python
def foo(a, b):
    x = 0
    for i in range(b):
        x += a

    return x
#+end_src

A Python "list" is just a big batch of contiguous memory. That means that if the first element of the list is at phone number 1, the second element will be at phone number 2, and the third at phone number 3, and so on. If you know which index you want, you can just dial it directly -- so this is also one operation.

So what's the asymptotic runtime of this program?

#+begin_src python
def elem(x, lst):
    i = 0
    while i < len(lst):
        if x == lst[i]:
            return True
        i += 1
    return False
#+end_src

What about this one?

#+begin_src python
def foo2(x, l):
    i = len(l)    # len(l) ~= O(1)
    while i > 0:
        l[i] = l[i-1]
        i -= 1
    l[0] = x
#+end_src

#+begin_src python
def foo3(x, l):
    i = len(l)
    while i > 0:
        foo2(x, l)
        i -= 1
#+end_src

Lists also store their size. If you add an element to a list that doesn't have space for it, it will have to find a bigger batch of memory and copy everything over. (What's the runtime of that?)

Because this is expensive, we use a trick. Every time we increase the size of the list, we double the size. This way, we get to insert O(n) elements. This means that adding to the end of a list is, on average, O(1). This is called *amortized* constant time -- it's not really constant, but it's constant enough.

How are dictionaries implemented? Basically, they're like lists, except that whatever you use as your key has to be turned into an index. This is called hashing and it's kind of magical. However, the good news is that lookups in a dictionary are constant-time (relative to the size of the dictionary) because you just have to hash the key and then look at that index.

In a homework a few weeks ago, you implemented a "check if an element is in a list" operation. The runtime of that operation is O(n). In general, you can't do better, but if you know your list is sorted, you can. How? You'll probably come up with an algorithm called binary search.

List:
-1, 2,  5,  9,   15, 16,  18, 19, 20,  25, 35

Find: 6.
#+begin_src python
  def flatten(lst):
      new = []
      for i in lst:
          if not isinstance(i, list):
              new.append(i)
          else:
              new.extend(flatten(i))

      return new
#+end_src

*** Homework
Implement the binary search algorithm. This is kind of naturally recursive too. What is its runtime?

Read https://en.wikipedia.org/wiki/Tower_of_Hanoi. Come up with an algorithm to solve it. Implement it. How fast does it run?
** Object-oriented programming
Object-oriented programming is a paradigm or methodology that is found in a lot of modern programming languges. It's one way to conceptually decompose systems and write abstractions. It's not the only way, which is why Python supports a lot of other ways, but it's still an important way.
*** Abstractions
When you write a function, you're writing an abstraction -- you're defining a new kind of operation which is made up of smaller, more basic operations. Knowing how to use the new operation liberates you from having to use the underlying smaller operations.

Programming is very very often about abstractions in one form or another, and choosing good ones to write and writing them well can be very challenging. (The exercises you guys have been doing are all essentially about implementing an abstraction that someone else chose for you.)
*** Classes
When writing functions, the abstraction you're creating is one of behavior. (This function does that.) In object-oriented programming, your abstraction bundles both behavior and state. This is kind of an abstract idea, so here's an example.

Let's say we want to write a program that models some users' reading habits. We might want to do stuff like this:

#+begin_src python
  alexs_book = {'title': "The Wise Man's Fear",
                'current_page': 10}

  my_kindle = {'current_book': "Pride and Prejudice",
               'account': 'ethan@example.com',
               'books': [
                   {'title': "Pride and Prejudice",
                    'current_page': 213},
                   {'title': "So You Want To Be A Wizard",
                    'current_page': 1},
                   {'title': "Furies of Calderon",
                    'current_page': 92}
               ]
  }

  def turn_book_page(book):
      book['current_page'] += 1

  def turn_kindle_page(kindle):
      # FIXME: This code has bugs.
      current_book = kindle['current_book']
      turn_book_page(kindle['books'][current_book])

#+end_src

We've defined some kinds of ad-hoc data structures here that correspond to books and book-like devices. These data structures correspond to *state* -- some kind of mutable information about current reality. A Kindle is more complicated than a book, so it has more (and different) state.

We've also introduced some operations to manipulate these data structures. However, you have to know which data structure you have when you want to use the operation. If you write a program that works for both books AND Kindles, you have a problem. You'd have to be sure never to call a Kindle function on a book, and vice versa, or else your program would break messily.

To make it a little easier, maybe you could write a function like this:

#+begin_src python
  def turn_page(book_or_kindle):
      # What goes here???
      pass
#+end_src

But in order to reliably determine what thing you have, you'd have to add another field to store that it's a book or a Kindle. The whole thing gets very messy -- dicts aren't required to always have the same keys, but books probably do.

Instead we define something called a *class*, which represents the underlying model. We use these to stamp out *objects*, which resemble the class. That might look like this:

#+begin_src python
  class Book(object):
      def __init__(self, title, current_page):
          self.title = title
          self.current_page = current_page

      def turn_page(self):
          self.current_page += 1

  class Kindle(object):
      def __init__(self, account, current_book, books):
          self.account = account
          self.current_book = current_book
          self.books = books

      def turn_page(self):
          self.books[self.current_book].turn_page()

  alexs_book = Book("The Wise Man's Fear", 10)

  my_kindle = Kindle('ethan@example.com', "Pride and Prejudice", [
      Book("Pride and Prejudice", 213),
      Book("So You Want To Be A Wizard", 1),
      Book("Furies of Calderon", 92)
      ])

  my_kindle.turn_page()
#+end_src

This code says to define two classes, which have certain data and
support certain operations. Then, I *instantiate* those classes, which
means to create an object, or instance, of those classes. When I do
this, the ~__init__~ function for those classes is called (this is
called the *constructor*). Both classes also have other operations,
which are called *methods* (a method is just a function defined on a
class).

Both classes have a common ~turn_page~ method. That means I can always call ~turn_page~ without having to care about what object it is.

To access data in an object, you use the ~object.attribute~ syntax we've seen. To call a method on the object, you write ~object.method()~.

To define methods, define a function inside the body of a ~class~ statement. These functions will take an additional ~self~ argument, which refers to the object itself, and can access its data or its methods directly.

The details of this process vary from language to language. Some, like
Java, require you to formally create an *interface* saying what
operations books and booklike things are expected to perform, and what
operations are available to the person using the class or object
(to try to limit misuse). But Python tends to be a bit more permissive here because of the culture of "We're all adults here". Look up "duck typing" for more about this.
*** Inheritance
Sometimes you want to define some new class. It's a lot like a more specialized version of an existing class, and you don't want to copy all the existing code (DRY; because copying is bad). To do this, we define a *subclass*.

#+begin_src python
  class Paperwhite(Kindle):
      def __init__(self, *args, **kwargs):
          super(Paperwhite, self).__init__(*args, **kwargs)
          self.is_backlight_on = False

      def turn_on_backlight(self):
          self.is_backlight_on = True

  moms_paperwhite = Paperwhite('donna@example.com', .....)
  moms_paperwhite.turn_page()
  moms_paperwhite.turn_on_backlight()
#+end_src

[The ~super~ function might behave a little bit differently in Python 3.]

Here, we are defining a new kind of Kindle. A Paperwhite is
automatically a Kindle, although not all Kindles are
Paperwhites. Paperwhites are a kind of Kindle that has a
backlight. Because Paperwhites *inherit* from Kindles, all Kindle
operations are still available in Paperwhites. (So you can still do
~turn_page~ on one.) It also offers some new functionality (a
~turn_on_backlight~ call).

The constructor for the Paperwhite needs to set up the Paperwhite, which means it needs to set up the Kindle part of the Paperwhite. To do this, it calls its *superclass* using the ~super()~ call.

The constructor for the Paperwhite does this neat trick with ~*args~ and ~**kwargs~. What this is saying is, whatever arguments you give me will be collected, whether they are positional (~*args~) or named (~**kwargs~). Then, when calling the superclass, it can un-collect them in the same way.
*** Design
There's a lot of material out there about "proper" object-oriented design and programming. Some essentials:

- What are the subjects of discourse in the domain? What are their relationships? What operations do they support?

- A constructor should ensure that the object is in a coherent state, and operations should always leave the object in a coherent state.

- A subclass should follow an is-a relationship, and never a has-a relationship. A Paperwhite is-a Kindle. (Although some cultures, like that of Java and Go, discourage inheritance and prefer the use of has-a relationships and delegation.)

- If you ever find yourself doing something like

#+begin_src python
  if foo.type == 'book':   # or isinstance(foo, Book)
      # do something with books...
      pass
  elif foo.type == 'kindle':
      # do something with kindles...
      pass
#+end_src

... you should restructure it as a common method.
*** Differences with Django models
Django models have field definitions which have a clear type.

Django models have clear relationships with other objects.
*** TODO exercises for *args, **kwargs
** Modules
The ~import~ statement introduces a "module", which is an object that represents the code loaded from some other file.

Let's say we put this code in a file called file_loader.py:

#+begin_src python
class FileLoader(object):
    pass

def load_file(filename):
    pass
#+end_src

And in another file (let's call it main.py) we put this code:

#+begin_src python
import file_loader
#+end_src

... we create a variable ~file_loader~ which represents a "module". If we print ~file_loader~, it will show us that it is a module and what file the module was loaded from. We can henceforth access the ~FileLoader~ class and the ~load_file~ function using the syntax ~file_loader.FileLoader~ and ~file_loader.load_file~. If we get tired of typing these things, we can also make them available directly using:

#+begin_src python
from file_loader import FileLoader, load_file
#+end_src

Now we can just use ~FileLoader~ and ~load_file~.

If you have lots of modules together, you can group them in a "package". A package is just a directory with a ~__init__.py~ file in it. See https://docs.python.org/3.5/tutorial/modules.html#packages for more info.
** Return of the Django
*** Review
Django, on startup, examines your site to discover its main application. Then it *imports* that application's settings file and URLs file (i.e. modules you wrote). Then it looks at your settings to identify the other applications in your site and imports all their models. Finally, it begins listening for requests from a browser. When a request comes in, it uses the rules from ~urls.py~ to decide what view will handle it.

Defining a model in Django is done by defining a subclass of ~django.db.models.Model~. Unlike normal Python classes, models tend to have explicit lists of fields and types. Like normal Python classes, they can have their own methods.

Defining a view in Django is done by defining a function (or callable object). This function must take at least one argument, which is a ~Request~ object, but it can take more if it wants to use parts of the URL. This function must also return a ~Response~ object. Normally a ~Response~ is produced by rendering a template, but it doesn't have to be. It's traditional to put views in a ~views.py~ module, but they don't have to be.

Django forms can be defined by defining a subclass of ~django.forms.Form~. Like models, you define all fields that your form needs and what type they are. A form needs access to a ~POST~ or ~GET~ from a real ~Request~ and it will tell you if the data was valid.

Defining a template is done by putting a file in a templates directory. Templates are usually kept in files like ~templates/appname/viewname.html~. Templates use the Django template format. To put a variable in a template, use ~{{ variable }}~. You can do some processing of variables using filters like ~{{ x | first }}~. You also get some other commands like ~{% if %}~ and ~{% for %}~. Templates can *extend* other templates. The "parent template" defines blocks and structure, and the child template fills in those parts.

To add CSS (or eventually, JavaScript) to a page, you'll use the ~staticfiles~ application. In templates, you'll use the ~{% load staticfiles %}~ command to get access to it, and ~{% static "appname/file.css" %}~ to create a link to the file.

CSS is a set of rules that change the appearance of HTML elements. Each rule has a selector that determines what elements it will apply to:

- ~foo~ applies to any HTML element with the tag ~<foo>~
- ~.foo~ applies to any HTML element with ~foo~ among its ~class~ attribute. Note that this kind of class is not like an OOP class!
- ~#foo~ applies to any HTML element with ~foo~ as its ID. IDs are supposed to be globally unique, and classes need not be.
- If ~X~ is a selector, and ~Y~ is a selector, the selector ~X Y~ matches any element who matches ~Y~ that is inside an element matched by ~X~.
- ~X > Y~ matches any ~Y~ child of a node matching ~X~.
- ~X, Y~ matches any node matching ~X~ or any node matching ~Y~.

A rule also has a bunch of properties, which are written inside braces. A property has a name and a value, e.g. ~color: blue;~. Each property allows different kinds of values. Of particular interest are ~float~ and ~position~ properties, which help you put together more complicated layouts. (Although it seems like the forward-looking thing is to use something called flexbox.)

Git is a system that tracks the content of your code, and thus their changes. It can be hosted on Github for free if you don't mind your code being public. You create a new project using ~git init~, choose what changes to record using ~git add~, and then record them with ~git commit~. Some files (like a Django database or a virtualenv!) shouldn't be tracked, so you can put their names in a file called ~.gitignore~.
*** Class-based views
Because most Django views are pretty similar, there is a mechanism to reduce boilerplate in views. You can define a class which is a subclass of an existing Django built-in view class, and customize it. See https://docs.djangoproject.com/en/1.9/topics/class-based-views/intro/.
** JavaScript
JavaScript is another language used in the web stack. A JavaScript interpreter is embedded in the browser and it executes JavaScript loaded on a web page. You can use JavaScript to make a web page interactive without requiring more requests back to the server. You can also use it to do graphical and animation stuff if you want to do something that you can't do in CSS (although CSS tends to expand to swallow these tasks).

JavaScript originally started out as a toy language that was stuffed into the browser, and JavaScript code was written by people who didn't really know much about programming, but over time it's grown more and more sophisticated and "cool" until real people started writing code in it. In particular, JavaScript has escaped the confines of the browser and can be run on the server now using a thing called NodeJS. Now there's an incredible amount of energy and technology in the JavaScript scene despite the fact that pretty much everyone still agrees that it's actually a pretty crappy language. In particular, because of its peculiar history:

- There are some things that don't have an accepted "technique" yet -- the equivalent of Python's ~import~ statements and modules don't exist in the core JavaScript language, and for a few years we've been in a period of development of possible alternatives and tools. I only know a little bit about these and can't offer deep wisdom about them.

- There are some things that you can do in multiple ways, some of which are just bad or discouraged. Compare with "The Zen of Python", which says "There should be one -- and preferably only one -- obvious way to do it." I'm going to tend to cover the ways that I consider "most correct", although I'll also try to follow up with other "less correct" ways and explain why I think they're less correct, so that you can be prepared if you see them in the field.

- Like HTML, JavaScript is designed to be forgiving of errors. So often, when you do something wrong, the program will just try to make the best of it and continue, as though it were better to do anything at all instead of signal an error. What this means is that sometimes you will get an error with your program far after the actual error happened, so keep an eye out for that. In Python, of course, "Errors should not pass silently, unless explicitly silenced".

- Sometimes language features combine to do bizarre things. See e.g. http://wtfjs.com/ when you're a little more familiar with the language.

What I am covering is meant to get you up and running with basic tools for client-side programming. I haven't kept up to date with all the hot new tech. I'd encourage you to look at/experiment with other technologies if you want to see more about what's out there. In particular, there seem to be a bunch of frameworks for "reactive programming", which promises to make the sorts of things that we're going to do here seem very clumsy. Additionally, there are a few client-side programming languages which offer improvements to JavaScript, and they "compile down" to JavaScript to run in the browser. In particular I'm thinking of PureScript and TypeScript. In five years' time, any of these might be the thing to know, and this lesson may look like cave scratches by Neanderthals.

Most importantly, the goal of this lesson is to get you up and running with JavaScript and maybe also a library called jQuery. The goal of this "unit" is to get you to be able to add a drag-and-drop functionality for items in the dollhouse to allow a user to position them directly (rather than specifying an x/y coordinate).
*** Adding JavaScript to a webpage
The "correct" way is going to be to add a ~<script>~ tag to your HTML. This is going to be very similar to how you added CSS. In your generated output HTML, you want to have the tag: ~<script type="text/javascript" src="path-to-file.js"></script>~. (You'll have to use the ~static~ plugin the same way we did in CSS.) (Note that if you try to use a self-closing ~<script/>~, the browser may not understand it.)

Once you get to a certain size of webpage, you'll probably need to start developing libraries that depend on each other and you'll need to pick a mechanism for importing libraries (I think everyone has standardized on something called "AMD modules" and "require" by now). You'll also eventually need to figure out a mechanism to turn lots of small JavaScript files into one compressed JavaScript file to reduce page load times. That's outside the scope of this course, but be aware that what we're doing isn't the most correct thing forever.

Less correct is to just slap JavaScript into the HTML directly. Sometimes you'll see this when using third-party JavaScript, like for Google Analytics. This looks like:

#+BEGIN_SRC html
<script type="text/javascript">
  // ... code goes here
</script>
#+END_SRC

Either way, your JavaScript will be run every time you refresh the page. You can use your browser's web development tools to verify that the JS is getting loaded.
*** Output in JavaScript
The closest thing to ~print~ in JavaScript is called ~console.log~. You use it like this:

#+BEGIN_SRC javascript
console.log("Hello world!");
#+END_SRC

Any output sent to ~console.log~ will go to your web browser's "console", which should be available also in development tools. When you refresh the page, the console is wiped clean and your program is rerun.

If you're debugging and want to show variables, you can also do that:

#+BEGIN_SRC javascript
console.log("Showing a variable", x);
#+END_SRC

There is also a command called ~alert~ which will show an annoying little pop-up message. You can also use this to output stuff if you're debugging.

There's also a command called ~document.write()~ which will "write" stuff to your HTML. Sometimes ad network code will do this. Don't do this, because it can really screw up your HTML.
*** Overview of JavaScript syntax
#+BEGIN_SRC javascript
// this is a comment
// all statements should end in semicolons
var x = 1;  // this is a variable; you should declare all variables
var y = 2, z = 3; // you can declare multiple variables on the same line
var options = {  // this is an "object", which is like a Python dict
    name: "Ethan",    // keys must be strings and need not be quoted
    course: "Computer Science Reading Group"
};  // N.B. semicolon here!
var myName = options.name; // "object" access
var alsoMyName = options["name"]; // same as above
var numbers = [1, 2, 4]; // array literal
var howManyNumbers = numbers.length; // array length
var someNumber = numbers[0]; // array access
f(x, y);  // function calls are basically the same, but no keyword arguments
obj.meth(x, y); // method calls are also basically the same

var showText = function(x, y){  // defining functions
    console.log("text!");
};  // N.B. semicolon here!

if (x == 5) {
    console.log("x = 5!!!");
}
else if (x == 6) {
    console.log("x = 6!!!");
}
else {
    console.log("x was something else!");
}

// while loop
var i = 0;
while (i < numbers.length) {
    var thisNumber = numbers[i];
    console.log("number " + i + " was " + thisNumber);
    ++i;
}

// for loop in JS is not much different from a while loop
for (var i = 0; i < numbers.length; ++i) {
    var thisNumber = numbers[i];
    // do something with a number
}

// The most elegant way to iterate over an array in JS is the forEach() function
// which takes a function as an argument.
numbers.forEach(function(thisNumber, i) {
    console.log("number " + i + " was " + thisNumber);
});

// you can also iterate over properties of an object using for .. in
// Be careful with this because it also gets properties of "parent" objects!
for (var key in options) {
    var option = options[key];
    console.log("option " + key + " was " + option);
}
#+END_SRC

Some things to note:

- Although the JavaScript language says that statements must end in semicolons, if you leave them out, there is a process called Automatic Semicolon Insertion (ASI) which happens, and often makes your program behave correctly. For this reason, some practitioners prefer not to explicitly put semicolons in. I don't have strong feelings on the subject, but basically follow the school of thought that says "ASI is explicitly about fixing an incorrect program, so if you don't put semicolons, your program is incorrect". See http://inimino.org/~inimino/blog/javascript_semicolons for more about this.

- In Python, variables are local by default, and can be made global using the ~global~ keyword. In JavaScript, variables are global by default, and have to be made local using the ~var~ keyword. You almost always want your variables to be local, so you should always declare them using ~var~.

- I keep writing JavaScript "object" in quotes because these are not like the objects from object oriented programming we've seen in Python. They're really more like dicts or hash tables. Object oriented programming in JS is quite a bit different than in Python. In particular, there's no particular way to define a class, and inheritance functions differently in JS than in Python. For these reasons, most practitioners avoid OOP when doing JS.

- In a JavaScript "object", keys don't have to be quoted, so JavaScript ~{name: "Ethan"}~ is the same as Python ~{"name": "Ethan"}~. However, in Python, keys can be full expressions, so you can have e.g. ~x = "name"; return {x: "Ethan"}~ . You can't do this in JavaScript; you'd have to do ~var x = "name"; var tmp = {}; tmp[x] = "Ethan"; return tmp;~ .

- If you access something in an "object" that doesn't exist, you don't get an error, but rather you get a special value called ~undefined~. Trying to do anything with ~undefined~ is an error.

- In JavaScript, lists are called Arrays. Many things seem like they should be arrays but aren't.

- Arrays behave basically like you expect, but without any of the useful functionality you might be used to from Python. For example, if you want to get the last element, you can't just do ~array[-1]~ -- you have to do ~array[array.length-1]~.

- Despite the fact that we don't really do OOP in JS, there are still methods. Writing a method is very strange in JS, but using them is usually pretty much what you'd expect.

- In Python, you can put a comma at the end of a dictionary or list declaration, but generally this isn't done in JS.

- Defining a function is done using the ~function~ keyword. Note that in JS, it's very common to create an anonymous function by using the ~function~ expression, without putting it in any variable. The ~function~ keyword is like the ~lambda~ in Python, except without any of the restrictions on the Python version. Arguments to the function go in the parentheses, and the body goes in the braces, like you'd expect.

- Note that in JS, you can call a function with different numbers of arguments than it was defined with. Any arguments that don't get values get set to ~undefined~. Any extra arguments are ignored (but can be accessed if you want -- more about this later).

Other people sometimes define functions using this syntax:

#+BEGIN_SRC javascript
function showText(x, y) {
    console.log("text!");
} // N.B. No semicolon
#+END_SRC

I don't like this syntax as much because it makes it less obvious whether the function is global or local. Additionally, sometimes I don't want to just define a function called ~showText~, but sometimes I want to call it ~someObject.showText~ -- with the style that I use, it's easy to change ~var showText =~ to ~someObject.showText =~, whereas with this style, I have to remove the name ~showText~ and move it to the beginning of the line.
*** The DOM
When we were talking about CSS, we talked a little bit about the DOM -- the structure of HTML elements on your web page. Besides writing stuff to the console and popping up message boxes, the main thing you do in JavaScript is manipulate the DOM. You can add classes to a page, add CSS styles to an element, or replace page content entirely. This lets you make a web page that can change.

The way you find DOM elements to manipulate is very similar to the ways we identify elements for CSS rules. First, you can select an element with a given ID using ~var someElem = document.getElementById("some-id")~. Then, you can:

#+BEGIN_SRC javascript
  console.log(someElem.className);  // access its "class" attribute
  someElem.className = "class1 class2"; // replace its "class" attribute
  // pop quiz.. how do we add a class to the element without replacing the existing ones?

  // you can also replace an element's content
  someElem.innerHTML = '<div class="some-class">New content</div>';

  // this adds "inline styles" to an element, the same as if you used
  // the "style" attribute on the element
  someElem.style.color = "blue";
  // this is the same as adding style="color: blue;" to the element
#+END_SRC

You can also fetch a bunch of elements that match a CSS selector. You can use ~var someNodes = document.querySelectorAll("div.some-class");~. This returns a ~NodeList~, which is one of several things in JavaScript that are sort of array-like but not really Arrays. It has a ~length~ and numeric elements from ~0~ to ~length-1~. See also https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll.

This ought to change all ~div~ nodes with the ~some-class~ class to have only the ~new-class~ class.

#+BEGIN_SRC javascript
var someNodes = document.querySelectorAll("div.some-class");
for (var i = 0; i < someNodes.length; i++) {
    var node = someNodes[i];
    node.className = "new-class";
}
#+END_SRC
*** jQuery
Despite the fact that JavaScript is a pretty craptacular language, underneath all its terrible design choices and perplexing behavior, there's actually the germ of a pretty decent language. With this language, it's possible to do clever and beautiful things. One of these things is the jQuery library. jQuery is like a Swiss army knife for client-side JavaScript programming. It contains lots of utilities to find and modify DOM elements as well as more basic stuff like operating on elements of array-like things. jQuery also helps you in the case where you have to support old libraries that don't support all the functionality that you need -- it provides *polyfills*, which are just a fancy way of saying they provide implementations of missing stuff so that your code can work even if the browser doesn't provide everything you need.

[N.B. Old versions of IE used to make our life the hardest, but in version 9 and up, it seems like it's getting acceptable.]

[N.B. Of course, if someone is using NodeJS, which is server-side, a client-side library like jQuery doesn't make sense!]

To use jQuery, put another ~script~ tag before your ~script~ tag, like: ~<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>~. We're using Google's hosted jQuery (see https://developers.google.com/speed/libraries/), but in a real site we'd probably host our own and/or come up with a more sophisticated loading strategy. Anyhow, the browser will load and run the jQuery library, which will define a global variable called ~$~. Then, it will load and run yours, which can use it to do e.g.

#+BEGIN_SRC javascript
$('div.some-class').each(function(i, elem) {
    $(elem).attr('class', 'new-class');
});
#+END_SRC

or even

#+BEGIN_SRC javascript
$('div.some-class').attr('class', 'new-class');
#+END_SRC

See http://learn.jquery.com/ and http://api.jquery.com/ for more info.

As time has gone on, more and more of the functionality that you used to need jQuery for has been moved into browsers themselves. For example, you can use CSS animations where previously you had to use jQuery animations, and ~document.querySelectorAll~ is basically the same as jQuery's ~find~ function. Because of this, and because jQuery is such a big library, some practitioners have always avoided it, either by replacing it with other libraries or with no library at all. See also http://youmightnotneedjquery.com/ for comparisons of how to do tasks with jQuery and with "vanilla JavaScript". Although the central premise of the website is that jQuery isn't really needed, I think almost all of the jQuery operations look way easier to read and maintain than the vanilla JS ones. This is a point of contention in the community, with some people jokingly responding to JavaScript questions with "just use jQuery", and others making fun of noobs who use jQuery even when they don't have to.

[N.B. The function given to the .each() method on jQuery objects gets arguments in a different order from the JS Array.forEach() method! This has tripped me up a number of times.]
*** Events
JavaScript is also good at listening for and responding to events. Using jQuery, you can do:

#+BEGIN_SRC javascript
$(".some-selector").on("click", function() {
    // do something
    // "this" is available to refer to the element on which the event happened
});
#+END_SRC
*** Page load event
Although you will normally put your scripts in the ~<head>~ block of your page, the rest of the document hasn't loaded yet. Usually it's a good idea to set up code to run after the page is loaded using e.g. the jQuery ~ready~ function.

#+BEGIN_SRC javascript
$(document).ready(function() {
    alert("OK, rock and roll!!");
});
#+END_SRC
*** Reading list
http://ejohn.org/blog/html-5-data-attributes/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference is a good reference
** Data modeling
"Show me your [functions] and conceal your [data structures], and I shall continue to be mystified. Show me your [data structures], and I won’t usually need your [functions]; they’ll be obvious." -- Fred Brooks

When developing a system to represent some problem or some information, you will have to choose a representation from among many that seem viable. This set of notes focuses on modeling your data in a way that is the most "correct". Correct means that it is easiest to understand and maintain, and that in particular it does the most to "make illegal states unrepresentable" (in the words of Yaron Minsky).

I'm not calling this section "data structures" because "data structures" is a field of computer science that focuses in minute detail on the efficiency of a particular mechanism. Data structures people care about things like whether you store a matrix by rows or by columns. That field of study can be interesting, but this set of notes is not concerned with such minute detail or even efficiency except in the vaguest of terms. We care more about "abstract data types", which define a set of operations supported by some structure.

By the same token, I'm going to focus on modeling your data for correctness assuming some sort of abstract memory in some sort of pure conceptual domain. I'll touch on translating these data models into specific programming language types, but translating them into e.g. a relational system is beyond the scope of this set of notes. There's usually some well-known way to "encode" what you want into the tool that you're using (or to "decode" that tool's structures into the original author's semantics).

Another related topic is about dividing up a system into smaller systems and components. This is called system architecture and I'm not super good at it. There are much fewer hard-and-fast rules about architecture, and a lot depends on the business context you're operating in. The same system can be described as "enterprise" or "industrial strength" or "heavyweight" or "baroque" or "overengineered". Architecture is not the emphasis of this set of notes.

Some amount of this will vary a little bit from language to language, but not too much. What seems to vary more is the lengths that people will go to in the pursuit of correctness, and how much they are willing to compromise correctness in exchange for efficiency (or even for convenience).
*** Basic types
Some "fundamental" types that you might use to model an individual datum.
**** Integer
A good starting point for data modeling is the "integer" type. Integers are familiar from mathematics; they represent numbers like -5, 1, 17, but nothing "fractional". Integers are discrete. They support addition, subtraction, multiplication, division, and "modulo".

Some languages distinguish between "signed" and "unsigned" integers. Signed integers can be positive or negative (i.e. they have a plus sign or a minus sign in front of them). Unsigned integers can only be non-negative, i.e. 0 or greater. (If you need a non-positive number, you can just use an unsigned integer and assume it's always the opposite, i.e. additive inverse, of the number you want.)

Some languages force you to choose a "size" for your integer, usually measured in bytes, but for most web development, this doesn't matter all that much.

Integers are a good choice for modeling:

- Numeric quantities.
- "Scores", i.e. ratings of things like priorities or rank. When doing this, be clear about whether higher is better or lower is better.
- "Enums", i.e. mutually exclusive categories, especially if they have an implicit "order". More about this later.

Integers are a bad choice for:

- Anything that "seems" numeric but doesn't behave numerically. As a good example, the book "Programming Perl" points out that the ZIP code of Cambridge, MA is 02140, but unlike numeric values, 02140 isn't the same as 2140, which isn't a valid ZIP code.
**** Float
For cases where your numeric quantity has fractional parts, one option is to use a "float", or a floating-point number. "Floating-point" means that although your data has a fixed amount of precision, that precision can be used to represent very small numbers (i.e. 0.00000000000000000000005) or very large ones (i.e. 50000000000000000000000.0). That is, the decimal point can "float" around within the precision you are allowed.

Most languages offer floating point numbers implemented directly using the processor's built-in floating point capacity, which usually follows a standard called IEEE 754. IEEE 754 mandates a standard where numbers are represented as decimals in base-2. This means that it's possible to represent 0.5 (which is 0.1 in base 2), but 0.2 is 1/5, which isn't possible to represent exactly in base 2 (it would be 0.0011 repeating). That means that when you try to represent 0.2 as a float, what you actually "get" might be either 0.19999999999999999999.... or 0.2000000000000000000000000001, depending on what floats are possible and which ones are closest to what you wanted. See https://docs.python.org/2/faq/design.html?highlight=floating%20point#why-are-floating-point-calculations-so-inaccurate for more.

JavaScript has the unusual property that there is one "type" for both integers and floats, called "number". That means that e.g. modular arithmetic "works" on floating point numbers (it does not in Python).

Floats are a good choice for:

- Approximate numerical quantities requiring a very large range (but relatively small precision).
- Or generally any kind of numeric quantity where you want to do math but don't really care how precise the math is.

Floats are a bad choice for:

- Money. Seeing something like "$5.01" may make you think of a floating-point quantity, but because floating point arithmetic isn't "exact", you can accumulate "error" of fractional cents, which can be scary. In this case, one trick is to store integer numbers of cents instead, and just convert them to dollars on input/output. Otherwise you could use Decimal, below.
- More generally, if you "only" need a specific range and precision isn't really negotiable, you can use an integer number of something that's very large (years) or very small (microseconds).
**** Bignum/Decimal
In many languages, normal "integers" only have a certain range -- for example, a common one is up to 2^64. This is the "natural" size of the processor and operations on such integers are very fast. Beyond this, someone has to do work to translate "bigger" integers into integers of this size when doing math. This works similarly to how humans learn their multiplication tables up to e.g. 10 x 10, and bigger multiplication problems are "decomposed" into smaller ones. In this way, you can store arbitrarily large integers, which are called "arbitrary precision" or (sometimes, more casually) "bignums". Ideally they work exactly the same as regular integers, but sometimes special syntax is needed to use them.

In Python, bignums are called ~long~, although ~long~ can mean other things in C-like languages. Also in Python, integer math will "gracefully" return longs if you exceed the capacity of an int.

Once you have arbitrarily-large integers, it's possible to have arbitrary-precision floating-point by just using a bignum + some information saying where the decimal point goes. In Python, arbitrary-precision floating-points are called ~Decimal~ and they are available in the ~decimal~ module.

Both bignums and decimals are less efficient than "pure" integers and floats, but are usually fast enough.

Bignums are a good choice for:

- Very large numbers for which mathematical operations nevertheless need to be completely precise. (This is common in cryptography, for instance.)

Decimals are a good choice for:

- Numbers with digits after the decimal place that you nevertheless want to represent exactly. A good example is when you want to store a number like "0.2" and don't want it to come back out as "0.20000000000000000000001" (although sometimes you don't care).
**** Booleans
Booleans are central to a lot of computer science. They can be represented using a single bit of memory and only have two values (true and false).

Booleans are a good choice for:

- Individual attributes which can only be true or false (there are no "unknown" or "n/a" or "ask" option).
- "Flags", i.e. a bunch of on-off information that isn't mutually exclusive. For example, a file might have can_read, can_write, and can_execute flags, and each might be true regardless of the other two. (If it *is* mutually exclusive, i.e. if you can only write things you can also read, then you want an enum; see below.)

Note that you can combine a lot of flags into an integer using bitwise AND, OR, NOT, and XOR operations. This used to be a thing people would do in low-level languages to save a few bytes of memory; these days it's more likely a way to combine arguments to a function. I'd generally consider this bad practice these days, both because individual bytes of memory aren't so precious and most languages offer some better way to pass in a wide variety of arguments (for instance, Python has keyword arguments, or you can pass in a struct of all possible arguments (see below)).
**** Enum
A Boolean is a type that can either be true or false, but not both at the same time, and not anything else. Sometimes you also want to define a type that can only be one of a small set of possible values. I'm calling this an "enum", which is the name it's given in C/C++. It stands for "enumerated type", i.e. you've enumerated all possible values for this type.

For example, my microwave can be standing by (not cooking), or it can be cooking, or it can have finished cooking (in which case it displays "end"). Because the microwave cannot be both cooking and finished cooking at the same time, this can be an enum.

Enums are good candidates for anything that seems kind-of-Boolean-y, but isn't quite Boolean, or any other kind of mutually exclusive state.

For a while, Python didn't have a "standard" enum functionality built-in, and people had differences of opinion about what it should actually do and how it should actually work. However, Python 3.4 offers https://docs.python.org/3/library/enum.html.

Some more modern languages offer something that might be called "enum" but is a little more complicated. I'll cover these in "Tagged unions", below.
**** String
A string represents a piece of text, meant to be shown to or received from a human.

In Python 3, this is called ~str~. In Python 2, this is called ~unicode~. (This is the major difference between Python 2 and Python 3.)

Some systems (SQL) require you to know ahead of time how much text you are going to store, the same way that you need to know the size of your integers.

Strings are a good choice for:

- Names. (But be aware of https://www.w3.org/International/questions/qa-personal-names)
- Addresses.
- Other actual human text.
- Sometimes, as a serialization format for other, more complicated data, like dates or enums. Note that one danger with strings is that they can become a kind of default unstructured type whenever something is too complicated to represent or someone is too lazy to do things "right". See http://wiki.c2.com/?StringlyTyped. This tendency isn't necessarily bad, just something to be aware of.
**** Bytestrings
A bytestring is a sequence of bytes. Unlike a string, a bytestring is not usually shown to a human. Instead, a bytestring represents something that needs to be sent to an input or output device, without human understanding being necessary.

In Python 3, this is called ~bytes~. In Python 2, this is called ~str~, which is a bad name for it and a major reason why Python 3 exists.

It's pretty rare to need bytestrings in modeling data, but they are worth a mention because a lot of systems get them wrong, and even when they don't, it can be helpful to understand how they're supposed to be used. If you ever encounter bytestrings, I recommend this presentation by Ned Batchelder: https://nedbatchelder.com/text/unipain.html.
**** Optional/nullable
Sometimes you want to talk about a datum that is always there or necessary. Other times you want to talk about one that may be present or absent. The latter is sometimes called a "nullable" type, with "null" representing the absent value. Nullability isn't a type itself, but it's a thing that modifies other types.

Being clear about whether something is nullable or not, and what null means, can be very important. Going from a place where "null" is allowed to a place where "null" is forbidden is an accident waiting to happen. For this reason, "null" has been called "the billion-dollar mistake". (See https://en.wikipedia.org/wiki/Null_pointer#History.)

In some languages and/or for some contexts, nullable types are the default; in others, nullability is something that is explicitly mentioned. In Python, the equivalent of "null" is called ~None~, and any variable can usually be ~None~. (In Django models, nulls are forbidden by default.) JavaScript, of course, has two null-esque values, ~null~ and ~undefined~. In C and a lot of related languages (C++, Java, Go), there are "primitive" types which can never be ~NULL~ (you can't have a nullable int) and "pointer" types which are always nullable (you can't insist on a non-nullable object). A couple languages let you choose between nullable or non-nullable versions of any type (for example, in C#, you can have ~int?~ to describe a nullable int, although it seems all pointers can still be null).

In a language where things can be null, some people will "null-check" incoming arguments of every function and throw an exception if they're null. I personally don't like doing this, since:

- It adds a lot of boilerplate to all functions.
- You have to do it not just on incoming arguments, but anything returned from any function, unless you're sure that the function will never return a null (including in the future if someone modifies it).
- You're already going to get a ~NullPointerException~, even without code to explicitly check for nulls; you just get to change the ~NullPointerException~ into something that tells you *what* was null.

The "cutting edge" approach is called an "option" type, which is a tagged union (about which see below) where you either have ~Some(value)~ or ~Nothing~. See also https://en.wikipedia.org/wiki/Option_type. Because ~Some(value)~ is different from ~value~, you can never accidentally use an "optional" thing as though it were guaranteed to be present.

Nullable types are often used for:

- Data that might be missing.
- Functions that can "fail" in a soft way -- where no answer is possible.
*** Compound
These are choices for when you need to model something more complicated than a single datum. Note that these structures are all composed, themselves, of structures, so you can "nest" them, or combine them like Legos into ever more complicated possibilities. (For example, "a list of departments, each of which is a map of strings to people records".)
**** Record
A record type lets you define a new kind of "data", usually by putting together existing kinds of "data". A record type defines a "format" which consists of several fields, each with its own type. You can then create records of this type which necessarily conform to this format.

In a procedural language like C, this is called a struct. In a classical object-oriented language, these are your classes and your instances. In some languages, tuples can be considered a kind of simplistic record type. (In Python, tuples are more like lists, which are collections -- about which see below.) In a database system, record types are like tables, and records themselves are the rows in that table.

A classic example of structs would be something like a two-dimensional point on the screen, which could be defined as something like:

#+begin_src c
struct Point {
    int x;
    int y;
}
#+end_src

In other words, a point has an (integer) x coordinate and an (integer) y coordinate. You can't have a point without both, and a point can't be created with any additional information.

Records are good for:

- Combining related data together.
- Combining data of different types together. If you have a fixed number of different things, you have a record. If you have lots of the same kind of thing, you don't have a record, you have a list.
- Combining data with the set of operations that can be performed on it. A common use of records is to let you "encapsulate" some kind of internal state while exposing only well-defined operations to other code.

Records are one of the main ways to define new abstractions, letting you create a thing closer to some real-world or domain-specific concept rather than always considering the nitty-gritty of what has to happen. For this reason, they are also sometimes overused; the Gang-of-Four book "Design Patterns" describes mechanisms you can use to solve lots of different problems in a language like Java that has nothing but classes. Many of these "patterns" are foreign or disappear completely in other languages. Many of the problems that these patterns try to solve are solved simpler using e.g. functions.

Instead of records, you can equivalently store data in "parallel arrays". In this scheme, you don't define e.g. an array of people, each of which has a name, an address, and an age, but instead you define an array of names, an array of addresses and an array of ages. Although this is equivalent, it's very rare that this is a good idea.
**** Tagged union
Some modern languages (Rust, Haskell, Swift) have a kind of enum-esque functionality where you define not only the possible cases, but additional information that goes with it. Sometimes these are referred to as "tagged unions" or "tagged constructors". As an example, let's say we let our users specify colors using either a "named" color like ~blue~, or a hex-encoded color like ~#00ff00~, or an RGBA color like ~rgba(0, 255, 0, 0.1)~. You might represent this using something like:

#+begin_src rust
enum CSSColor {
  NamedColor(String),
  HexEncoded(i32, i32, i32),
  RGBA(i32, i32, i32, f32)
}
#+end_src

These kinds of structures are like a fusion of a record and an enum, and they're super neat when you have them available. Usually, to examine them and extract the useful data, you need some kind of "pattern-matching" operation.

If your language has tagged unions, odds are good that it has an option type instead of nullability (see above).
**** List
A list represents an ordered group of zero or more elements. A list does not have a fixed size and can grow or shrink over the course of a program.

In Python, this is the ~list~ class. In JavaScript, this is called ~Array~ (although it isn't a true array, about which more in a second). In C++ it's called a vector and in Rust it's called ~Vec~.

Some languages also expose a more basic ordered collection called an array which corresponds to a large block of computer memory with a fixed size. Unlike lists, arrays cannot grow or shrink. However, a list can be implemented using arrays -- when you need to grow the list, you copy everything to a new, bigger, array.

It's generally a good idea for all the elements in your list to be the same type (or offer some common functionality). If you have elements of different types, you probably want a record type.

Although a list has relatively few constraints, you can always try to use a list in a more restrictive way. As an example, you can maintain a sorted list by being careful where you insert elements. Having a sorted list may be valuable for certain kinds of algorithms (i.e. binary search).

Lists are a good fit when:

- You want to say "several" of something without saying anything else.
- You want to process a bunch of items in a uniform way.
***** List-like variations
Stacks and queues are a restricted version of lists where you can only insert and remove elements in certain places. In a stack, you insert ("push") and remove ("pop") only from one end, which creates a "last-in-first-out" order. In a queue, you insert ("enqueue") only at one end and remove ("dequeue") only from the other end, which creates a "first-in-first-out" order. These can be useful if you want to process elements in a certain constrained order. A good example is tracking nested elements, where a stack is almost always what you want.

A dequeue ("double-ended queue") is a list that supports inserts and removals from both ends and can be used as either a stack or a queue, depending on which ends you use for what.

A priority queue is a list where each element has a "priority". Removal of the "next" element produces the element with the lowest priority. This means that unlike a regular queue, elements that are added later might get removed (and thus processed) earlier.

Because all of these types are just lists but with fewer operations, they are mainly useful in code/architecture and not in data modeling (you'd just use a list instead).
**** Set
A set represents an unordered group of elements, with no element being repeated. You can use a set if you want to enforce that elements are unique (usually duplicate elements are silently dropped).

Mathematical "sets" also have certain popular operations which may be present -- union, intersection, subtraction -- but these operations can often be present on lists as well.

In Python, there is a built-in ~set~ class. If your language doesn't have a set type, the usual way to implement it is using a map (see below).
**** Map (associative array)
An associative array is a collection of key-value pairs. The key serves as an ID for the value: given a key, you can look up the value, but you may not be able to go from the value back to the key. In other words, it associates a value with a key. "Associative array" is kind of an unwieldy term, so this abstract data type is usually called a map or hash table instead. Each key can only be associated with one value -- inserting a second key-value pair with the same key will overwrite the first.

Python is unusual in that it calls this class ~dict~ or dictionary. (An English dictionary associates words, which are the keys, with definitions, which are the values.) In most other languages, "map" or "hash table" is used.

For most of JavaScript's history, an "Object" type was the closest thing available to a map. An Object is more correctly used in JavaScript to represent records, but because the syntax is very convenient, people still sometimes use "objects" as maps that can only have string keys. (These days, JavaScript also has a Map class.)

Maps are very versatile structures:

- Instead of a list, you can always use a map with an integer key. For this reason, some languages don't bother building lists or arrays but go straight to maps. PHP's "array" type is a map for this reason.
- If you don't have a "set" type in your language, you can use just the "keys" part of a map, ignoring the values.

Maps are a good idea when:

- You want to be able to look up a given value based on its ID.
- No two items can have the same ID. If you need to have key-value pairs where the key isn't unique, i.e. not really a key, then you can just use a list of pairs.
- You have keys of some type and values of some possibly different type. If your values are of different types, you might have a record. (N.B. Django template "contexts" are maybe an exception to this rule, where values are all just string-esque things.)
- You're using some record type and you want to add information to it, but you can't because it's an external library or otherwise "closed". You can use the record as the key, and the value can be whatever supplemental information you want to track. (N.B. Some languages have restrictions on what kinds of things can be keys, like they have to be hashable or orderable or whatever.)
**** Intermission: IDs
When your data model contains any kind of collection, you'll often need to find or refer to an element in that collection. In other words, you'll need to take some information and use it to uniquely identify some element. What you're doing is defining a thing that refers to an element, or a reference.

A reference must be permanent (it should never change, no matter what happens to the thing it refers to), and it must be unique (it should only ever identify one thing), and you almost always want every item to be "referable".

It might be possible that some element of the data uniquely identifies it, but this is vanishingly rare or maybe even impossible. Much more common is for a developer to think some field is guaranteed to be permanent until someone in Customer Satisfaction needs to edit it, or for some field to be "pretty unique" until management wants to be able to track the old owner AND the new owner of that phone number, or everyone needs to have a social security number until someone doesn't. For these reasons, when designing a way to refer to things, you almost always want to have an arbitrary ID as the reference. If you control the arbitrary ID and don't let it be a property of the data in any way, you can ensure that it is permanent (because why would you change it?), unique (because you control its generation), and mandatory (because you can assign one to everything).

If you're referring to an element in a list, you might be tempted to use its index as its ID. Be careful with this, because lists almost always change, which invalidates all the IDs. If you need permanent IDs into a structure, you probably want a map, using some kind of arbitrary ID as the key.

Most relational databases default to generating arbitrary IDs using integers that increase starting at 1. This has a certain convenience, but has some weaknessess too. In a distributed system, two machines could choose the "next" ID at the same time, which would cause a collision. Additionally, sometimes having IDs be predictable is a security weakness -- imagine SnapChat where you could see any post by starting at 1 and increasing until you ran out! So other systems use random numbers, or strings, or UUIDs, or something else.

On the other hand, IDs are also one of the most "internal" parts of a system that users will still interact with, so choosing a good scheme for them can be a critical user interface decision.

Note that if you have a relatively small fixed set of IDs, you basically have an ~enum~. In that case, there may not be a need for an arbitrary ID.
**** Trees
A tree is a collection of nodes that has a certain recursive structure. A tree can be either an empty collection of nodes, or one node that has "children" trees (which themselves can be either empty or nodes that have trees, which themselves etc.). Trees show up in lots of places in computing -- a filesystem is a tree where folders can contain folders which contain folders, etc., and HTML elements contain children which are themselves HTML elements.

Trees are the focus of a lot of exercises in a data structures and algorithms course, and occasionally you will have a problem which is appropriate to model as a tree. The most common ones involve "folder"-like structures, or language-like structures (for example, a Python expression is either a number, or the addition of two expressions, which themselves are either numbers, or etc.).
**** Graphs
Graphs are probably the most complicated data structure that you might actually still use. A graph is a collection of nodes (usually called "vertices") plus a collection of connections ("edges") between those nodes. Sometimes these edges have additional information associated with them (a "label", "cost" or "weight").

Graphs are really useful for modeling networks of things. For example, the Interstate system is a network of roads connecting cities. The World Wide Web is a network of pages with links to other pages.

Graphs are also quite generic. A tree is just a graph with no cycles. Sometimes you will think you see a graph only to discover that because of some property of your data, you don't need something as complicated as a graph, but can instead get away with a list or something simpler.

Graph algorithms are usually quite specialized and relatively complicated (there are entire courses on "graph theory"), so we won't discuss them here, merely to point out that they exist in case you need them.
*** Bonus: Functions
Although we usually think of code and data as fundamentally different, in some ways they're two sides to the same coin. Code is just data that is interpreted by a processor, and data is code which produces information.

Sometimes your code needs input that is so open-ended that there isn't any way to encode it using any number of options. For example, maybe you want to write code that reads integers from a file and "does something" with them. Sometimes that "something" might be to take the biggest, sometimes it might be the smallest, sometimes it might be the one that occurs the most often, sometimes it might be the average. One way to implement this would be to encode each of these possibilities as ~enum~ s, but this limits you to supporting only the options you anticipated, and forces your code to handle all of them at once, which can add a lot of complexity to your code.

Another alternative is to let the user give you code that says what to do with the integers. The natural way to do this in most languages is for them to pass a function. Your function can call the user's function and use what it returns. If you can get yourself in the right mindset, this a very powerful technique.

This technique works in both directions -- rather than write a function "with a hole in it" that does a whole task, you can write several functions that contain the pieces, and let the user call them in whatever order they want. If you write code that a user calls, you've written a library; if you are calling code that a user wrote, you've written a framework.

When functions are part of an interface, you're inherently limiting the use of that interface to people who can write code. For this reason, it's pretty rare that you use functions to represent anything that an end user interacts with. But functions do turn up in the interfaces that programmers use (and offer to other programmers).

Functions don't go under "Basic" data structures because in a theoretical sense, they are the most complicated possible data structure. But in another sense, they're also very fundamental. There's a whole school of thought (called "functional programming") emphasizing this pattern and its use in structuring programs.
*** See also
- https://en.wikipedia.org/wiki/Abstract_data_type
- https://en.wikipedia.org/wiki/Collection_(abstract_data_type)
- https://www.youtube.com/watch?v=IcgmSRJHu_8 (This is Elm, but a great talk. Between 18m-21m or so, it becomes very Elm-specific, but the basic ideas are cross-language.)
- https://www.slideshare.net/ScottWlaschin/domain-driven-design-with-the-f-type-system-functional-londoners-2014/93 and subsequent slides
** Asynchrony in JS
We use a lot of anonymous functions in JavaScript, but there's no real reason they *need* to be anonymous. For example, let's say I have the following (synchronous) code:

let flour = getEggs();
let water = getWater();
let yeast = getYeast();
let dough = mix(flour, water, yeast);
let risenDough = allowRise(4, dough);
let bread = bake(risenDough, 425);

Let's say getEggs, getWater, and all the rest are asynchronous. They can't return their results immediately, but have to go get them for a while first. So they need to know what to do when they have the results. How do we express "a thing to do"? As code. How do we pass code as an argument? Wrap it in a function. So maybe we write something like this:

function bakeRisenDough(risenDough) {
  bake(risenDough, 425);
}

function allowRiseAndThenBakeDough(dough) {
  allowRise(4, dough, bakeRisenDough);
}

function getWaterAndYeastAndMixAndAllowRiseAndThenBakeDough(flour) {
  function getYeastAndMixAndAllowRiseAndThenBakeDough(water) {
    function mixAndAllowRiseAndThenBakeDough(yeast) {
      mix(flour, water, yeast, allowRiseAndThenBakeDough);
    }
    getYeast(mixAndAllowRiseAndThenBakeDough);
  }
  getWater(getYeastAndMixAndAllowRiseAndThenBakeDough);
}

getFlour(getWaterAndYeastAndMixAndAllowRiseAndThenBakeDough);

Kind of a drag, isn't it? We have all these meaningless functions that only exist to string together other meaningless functions. When you have functions like this, you might consider whether the names of the functions are really adding that much. If they aren't, then maybe we can do without them. Since each function is only used once, we might not define them inline instead:

getFlour(function(flour) {
  getWater(function(water) {
    getYeast(function(yeast) {
      mix(flour, water, yeast, function(dough) {
        allowRise(4, dough, function(risenDough) {
          bake(risenDough, 425);
        });
      });
    });
  });
});

This kind of sucks too, but this is the best we've got with the tools we've seen so far. This is how asynchronous programming in JS was done for a long time. Given these tools, I'd probably write a mix of these two things -- maybe extract allowRiseAndBakeDough, but leave the rest the same.

This isn't the only approach to expressing asynchrony in computer languages. In some languages, there's a concept of "threads", which sort of allow the possibility of continuing to write straightforward synchronous-looking code, but with execution happening in multiple spots at once. The problem is that different threads can interact in many different ways, and a programmer may not always have anticipated all of them.

JavaScript decided not to include threads. The next mechanism they introduced for asynchronous programming was called promises, and they're a little nicer than this kind of "callback hell". We'll talk about them a bit more next time.
** Low-level code refactors
To refactor code means to change its structure while preserving its behavior. You refactor code when it works but it doesn't support what you want to do. This might happen after you've bashed out some code for the first time, or when you come back to it after learning more about the project the code belongs to. Some refactors can be quite involved and intense where responsibilities move from one section of code to another, or things are separated out from other things. Make sure you have a good test suite before you embark on these!

There are also a bunch of simple "micro-refactors" which are relatively obvious. To get you to start thinking in these terms, here is a list with a few. I've named each one, but I'm not really clear on which names might make sense to other people and which might not. (However, the term "extract" does seem to be relatively well-understood.) I'm hoping that once you start to see them, you'll see them everywhere.

The ones in these list mostly focus on small code-level changes. Maybe later we can talk about those more involved refactors that talk about moving functions from one place to another, changing the relationship between two pieces of code, changing the arguments given to functions, etc.
*** Extract constant
Before:

#+BEGIN_SRC javascript
let x = 5 * 8;
console.log("An octagon with radius 5 has perimeter", x);
#+END_SRC

After:

#+BEGIN_SRC javascript
const RADIUS = 5;
const SIDES = 8;
let x = RADIUS * SIDES;
console.log("An octagon with radius", RADIUS, "has perimeter", x);
#+END_SRC

You almost always want to name "magic numbers" like this!
*** Extract constant/variable as parameter
Before:

#+BEGIN_SRC javascript
function greetUser() {
  const username = "George";
  console.log("Hello, " + user);
}

greetUser();
#+END_SRC

After:

#+BEGIN_SRC javascript
function greetUser(username) {
  console.log("Hello, " + user);
}

const username = "George";
greetUser(username);
#+END_SRC

This can make a function more flexible, analogously to extracting the constant/variable itself.

Sometimes it's important to move the source of information into/out of a function based on what part of the codebase should be "responsible" for it. This particular transformation moves the responsibility for the username outside of the function (~username~ is now provided to the function), and reversing the transformation moves the responsibility back into the function. (This is still true even if, say, ~greetUser~ calls a function to get ~username~.)
*** Extract expression as variable
Before:

#+BEGIN_SRC javascript
const LENGTH = 10;
const WIDTH = 20;
console.log("The area of the rectangle is", LENGTH * WIDTH);
#+END_SRC

After:

#+BEGIN_SRC javascript
const LENGTH = 10;
const WIDTH = 20;
const AREA = LENGTH * WIDTH;
console.log("The area of the rectangle is", AREA);
#+END_SRC

Any expression you repeat more than once should probably be a function or a variable. Some compilers can notice when you re-use an expression and only compute it once -- this is called common subexpression elimination, or CSE.

If something is only used once, it can sometimes be valuable to do the reverse of this refactor, i.e. put the expression in directly and get rid of the variable.

Other examples:

Before:

#+BEGIN_SRC javascript
console.log("The area of the rectangle is", 15 * 2);
console.log("The area of the rectangle is", 3 * 9);
#+END_SRC

After:

#+BEGIN_SRC javascript
function logRectangle(length, width) {
  console.log("The area of the rectangle is", length * width);
}
logRectangle(15, 2);
logRectangle(3, 9);
#+END_SRC

Normally, a repeated expression produces the same value, which means it can be stored in a variable. However, in the general case, you may have repeated code. Code can't be extracted as a variable, but it can be extracted as a function.

Before:

#+BEGIN_SRC javascript
button1.addEventHandler('click', function() {
  console.log("Click received:", this.value);
});
button2.addEventHandler('click', function() {
  console.log("Click received:", this.value);
});
#+END_SRC

After:

#+BEGIN_SRC javascript
const myButtonHandler = function() {
  console.log("Click received:", this.value);
}
button1.addEventHandler('click', myButtonHandler);
button2.addEventHandler('click', myButtonHandler);
#+END_SRC

Drawn from a real-life situation! Here is an interesting example where although it "feels" like we are extracting code, in actual fact we can get away with extracting a "variable", which is just a function.
*** Rename variable or function
Before:

#+BEGIN_SRC javascript
let controller = {};
controller.ethan = "trustno1";
#+END_SRC

After:

#+BEGIN_SRC javascript
let passwords = {};
passwords.ethan = "trustno1";
#+END_SRC

Naming things well is very hard. It can be very helpful to change names when you think of a better one.

Changing a local variable's name should always be safe. (By definition, if it's local, it can't be seen outside the function.) Renaming a global variable, a member variable, or a function means renaming it in every place it's being used. In more dynamic languages (like JavaScript!) it may not be possible to know definitively if something is being used or not (because things can be looked up dynamically at runtime), so you may have to test to make sure everything still works OK.
*** Several Boolean refactors
These are usually most useful when targeting the condition of an ~if~ statement or a loop, but can apply to any expression that manipulates Booleans:

- Negating a negation cancels out. So, ~!(!x)~ is the same as ~x~ -- if ~x~ is truthy, then ~!(!x)~ will have the same truthiness value as x. N.B. However, in JS, sometimes ~!!x~ is used as a shorthand way to convert something to a Boolean.

- De Morgan's laws: ~!(x && y)~ is ~!x || !y~, and ~!(x || y)~ is ~!x && !y~.

- ~x && true~ is the same as ~x~. ~x && false~ is the same as ~false~.

- ~x || false~ is the same as ~x~. ~x || true~ is the same as ~true~.

- More at https://en.wikipedia.org/wiki/Boolean_algebra.

- Also keep in mind the opposites of common comparisons: ~!(x > y)~ is the same as ~x <= y~, and vice versa.

Before:

#+BEGIN_SRC javascript
let userIsNew = ....;
let emailIsValid = ....;
if (!(emailIsValid || !userIsNew)) {
  console.log("Can't register as new user with invalid email");
} else {
  // User is old so email doesn't have to be valid
}
#+END_SRC

After:

#+BEGIN_SRC javascript
if (!emailIsValid && userIsNew) {
  console.log("Can't register as new user with invalid email");
} else {
  // User is old so email doesn't have to be valid
}
#+END_SRC

Sometimes it also helps to reframe your variables -- instead of having ~let emailIsValid = whatever;~, consider doing ~let emailIsInvalid = !whatever;~. Or the other way around.

*** Flipping if/then
Before:

#+BEGIN_SRC javascript
if (condition) {
  // Do something
} else {
  // Do something else
}
#+END_SRC

After:

#+BEGIN_SRC javascript
if (!condition) {
  // Do something else
} else {
  // Do something
}
#+END_SRC

This can be handy in combination with the Boolean refactoring laws above. Or sometimes you find yourself with something like:

#+BEGIN_SRC javascript
if (condition) {
} else {
  console.log("OK, this is a thing we want to handle somehow");
}
#+END_SRC

If the ~then~ part is completely empty, you don't actually care about the condition -- you're checking for the inverse of the condition, and you can switch it around into:

#+BEGIN_SRC javascript
if (!condition) {
  console.log("OK, this is a thing we want to handle somehow");
} else {
}
#+END_SRC

And then drop the ~else~ entirely (as with other refactors, below):

#+BEGIN_SRC javascript
if (!condition) {
  console.log("OK, this is a thing we want to handle somehow");
}
#+END_SRC

N.B. Some languages (most notably Perl) offer some interesting control flow statements, such as ~unless (condition)~, which is the same as ~if (! condition)~, and ~until (condition)~, which is the same as ~while (! condition)~.
*** Collapse if
Before:

#+BEGIN_SRC javascript
f(1);
if (condition) {
}
f(2);
#+END_SRC

After:

#+BEGIN_SRC javascript
f(1);
f(2);
#+END_SRC

An empty ~if~ statement can simply be left out!

Similarly:

Before:

#+BEGIN_SRC javascript
f(1);
if (condition) {
  f(2);
} else {
}
#+END_SRC

After:

#+BEGIN_SRC javascript
f(1);
if (condition) {
  f(2);
}
#+END_SRC

An empty ~else~ block can also just be dropped.
*** Combine branches
Before:

#+BEGIN_SRC javascript
if (condition) {
  f();
  // Other stuff..
} else {
  f();
  // More stuff..
}
#+END_SRC

After:

#+BEGIN_SRC javascript
f();
if (condition) {
  // Other stuff..
} else {
  // More stuff..
}
#+END_SRC

You can also pop stuff out at the end of the ~then~ / ~else~:

#+BEGIN_SRC javascript
if (condition) {
  // Other stuff..
  f();
} else {
  // More stuff..
  f();
}
#+END_SRC

Becomes:

#+BEGIN_SRC javascript
if (condition) {
  // Other stuff..
} else {
  // More stuff..
}
f();
#+END_SRC

Using this sometimes lets you shrink either the ~then~ or the ~else~ case down to nothing, at which point you can drop it (as above).

Sometimes it can be helpful to reverse this refactor -- split something into two different branches to make them behave slightly differently, or do them in different orders.
*** Unconditional conditions
Before:

#+BEGIN_SRC javascript
if (true) {
  // True then
} else {
  // True else
}

if (false) {
  // False then
} else {
  // False else
}
#+END_SRC

After:

#+BEGIN_SRC javascript
// True then
// False else
#+END_SRC

N.B. Sometimes you'll see something like this:

#+BEGIN_SRC javascript
const DEBUG = false;
if (DEBUG) {
  // Some stuff
}
#+END_SRC

This is set up so that if you want more debugging output, you can just change the DEBUG constant at the top of the file. In this case, don't go to the trouble of taking out all the ~if~ blocks -- usually a compiler or something like that will do it for you, and/or it won't hurt anything to leave them in.
*** Early exit
This is kind of a combination of the "flipping if/then" and "collapse if" refactors (above), but in the context of a function.

Before:

#+BEGIN_SRC javascript
function doSomething(c) {
  if (condition) {
    // Do stuff
    // Sometimes this is really long stuff
    // and it takes up lines and lines
    // to the point where you don't even
    // remember what condition you were in
    // or if it's still relevant...
    // Oh OK I guess we're done
  }
}
#+END_SRC

After:

#+BEGIN_SRC javascript
function doSomething(c) {
  if (!condition) {
    return;
  }

  // Do stuff
  // Sometimes this is really long stuff
  // and it takes up lines and lines
  // to the point where you don't even
  // remember what condition you were in
  // or if it's still relevant...
  // Oh OK I guess we're done
}
#+END_SRC

Lots of times you'll have some kind of condition which you need to check. If the condition isn't true, your whole function (or a large fraction of it) doesn't make sense. I like to return early in these kinds of cases. I find that the code tends to read clearer as "here is an invalid case; abort when this happens" instead of "here's the only valid case". I sometimes lose track of the conditional, so when we get to the end of the function I'm like "wait, two closing brackets, why?? what were we in the middle of? do I need to handle something else now that the if statement is done?" Also pulling the body outside of the if statement lets you save a layer of indentation, which I usually prefer.

N.B. Some grognards insist that functions should only have one exit point, so prefer the "before" form. This may be a leftover habit from C, where you need to explicitly clean up anything you allocated as part of your function. See [[http://wiki.c2.com/?SingleFunctionExitPoint][SingleFunctionExitPoint]] on Wiki Wiki Web. As with most stylistic quirks you encounter on the job, it's best to "do what the Romans do", even if you don't necessarily agree with it.
*** Unrolling a loop
Before:

#+BEGIN_SRC javascript
for (let i = 0; i < n; i++) {
  f(i);
}
#+END_SRC

After:

#+BEGIN_SRC javascript
f(0);
f(1);
f(2);
f(3);
f(4);
// ...
f(n);
#+END_SRC

You probably won't actually see this in your day-to-day work. It sometimes comes up when optimizing code that has to be very very fast. It has come up enough that there's a name for it: https://en.wikipedia.org/wiki/Loop_unrolling . Much more likely is that you'll be doing the reverse of this transformation.
*** Extending a loop
Before:

#+BEGIN_SRC javascript
for (let i = 0; i < n; i++) {
  f(i);
}
f(n);
#+END_SRC

After:

#+BEGIN_SRC javascript
for (let i = 0; i < n + 1; i++) {
  f(i);
}
#+END_SRC

If you see some code that looks similar to code inside a loop, you can sometimes incorporate it into the loop itself. The reverse can also be useful sometimes if you need to make the bounds line up for whatever reason.

Variation (extend at the beginning):

Before:

#+BEGIN_SRC javascript
f(-1);
for (let i = 0; i < n; i++) {
  f(i);
}
#+END_SRC

After:

#+BEGIN_SRC javascript
for (let i = -1; i < n; i++) {
  f(i);
}
#+END_SRC

An example from a real linked list problem:

Before:

#+BEGIN_SRC javascript
f(head);
let p = head.next;
while (p !== null) {
  f(p);
  p = p.next;
}
#+END_SRC

This turned out to cause a bug because sometimes ~head~ was null (so ~head.next~ was crashing).

After:

#+BEGIN_SRC javascript
let p = head;
while (p !== null) {
  f(p);
  p = p.next;
}
#+END_SRC
*** Anti-patterns
Don't do these -- people online will make fun of you.

The "[[http://thedailywtf.com/articles/Switched_on_Loops][for-case loop]]" a.k.a. the "[[https://en.wikipedia.org/wiki/Loop-switch_sequence][loop-switch sequence]]":

#+BEGIN_SRC javascript
for (let i = 0; i < 10; i++) {
  if (i == 0) {
    // Do something interesting for 0
  } else if (i == 1) {
    // Use 1 to do something interesting
  } else if (i == 2) {
    // .. and so on ..
  } else {
    // Do the 9th interesting thing
  }
}
#+END_SRC

The "loop" here isn't actually repeating any action. This is actually a sequential process that's been forced into a strange looping construct. Instead do:

#+BEGIN_SRC javascript
// Do something interesting for 0
// Use 1 to do something interesting
// .. and so on ..
// Do the 9th interesting thing
#+END_SRC

There's no crime in writing out a sequence of operations if they really are sequential and have nothing to do with each other.

If at first you don't succeed, try, try, and then stop:

#+BEGIN_SRC javascript
let success = doSomething();
if (! success) {
  success = doSomething();
  if (! success) {
    success = doSomething();
  }
}
#+END_SRC

Obviously this could conceptually go on forever. But there's no real reason these things need to be nested like this -- this is actually a looping process that's been written out as a strange nested if-then.

#+BEGIN_SRC javascript
let success = false;
while (! success) {
  success = doSomething();
}
#+END_SRC

N.B. From a theoretical perspective, there's only ever two ways failure can be handled: by trying forever, or by aborting. Be sure you are OK with whichever one you choose. (There are lots of other options that boil down into one of the two options. For example, "Try five times, then give up" just means "Try and on failure give up, except that 'failure' is defined as a sequence of five specific failures.")
*** Exercises for the reader
Try to clean up this messy function. It's meant to be part of a banking system. You can certainly clean up the first if-then-else statement by straightening out the condition and merging common stuff between the two branches. For the second if statement, use an early-exit to clarify. Consider renaming the parameters (which I chose to be deliberately obtuse).

#+BEGIN_SRC javascript
let balance = 1000;
function cashCashCash(x, t) {
  if (!(x > balance || !t)) {
    console.log("Sending", x, "to", t);
    balance -= x;
  } else {
    balance -= x;
  }
  if (balance < 0) {
    console.log("Currently in debt", -balance);
    if (transferDest) {
      console.log("Maybe you shouldn't have sent that money to", t);
    }
    sendEmail();
  }
}
#+END_SRC

Try to condense the two similar-looking code blocks below into a single function being called twice. Then, try to clean up the conditional inside the ~for~ loop (it isn't really needed).

#+BEGIN_SRC javascript
console.log("Calculating results for George");
for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) {
    f(i, "George");
  } else {
    g(i);
  }
}

console.log("Calculating results for Henry");
for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) {
    f(i, "Henry");
  } else {
    g(i);
  }
}
#+END_SRC
** Future topics
Local variables
Dynamic typing
Tuples and how they differ from lists
Why I hate CSS
** Future refactors
*** "Switch" into dynamic dispatch
Before:

#+BEGIN_SRC javascript
function doSomethingForTypeOne() {
  // ...
}

function doSomethingForTypeTwo() {
  // ...
}

if (obj.type == 1) {
  doSomethingForTypeOne();
} else if (obj.type == 2) {
  doSomethingForTypeTwo();
}
#+END_SRC

After:

#+BEGIN_SRC javascript
typeOne.prototype.doSomething = function() {
  // ...
}

typeTwo.prototype.doSomething = function() {
  // ...
}

obj.doSomething();
#+END_SRC

This is a classic object-oriented refactor -- see e.g. [[https://refactoring.guru/replace-conditional-with-polymorphism][replace conditional with polymorphism]]. There's also another style where you look up the functions yourself:

#+BEGIN_SRC javascript
const doSomethingByType = {
  1: doSomethingForTypeOne,
  2: doSomethingForTypeTwo
};

doSomethingByType[obj.type]();
#+END_SRC

The object-oriented version of this is sort of hiding the hash table in the dynamic dispatch.
*** "before"/"end" into wrapper function
This shades into "design pattern" territory.

Before:

#+BEGIN_SRC javascript
setUp();
doSomething1();
cleanUp();

setUp();
doSomething2();
cleanUp();
#+END_SRC

After:

#+BEGIN_SRC javascript
function withResource(f) {
  setUp();
  f();
  cleanUp();
}

withResource(doSomething1);
withResource(doSomething2);
#+END_SRC

If you have some kind of "resource" that needs to be cleaned up, or some kind of logic that absolutely needs to be run "after" certain things, and you're afraid people will forget it, you can write a wrapper function to enforce that it gets called. This is most powerful when the result of the set up is somehow required for the ~doSomething~ functions. Some languages have other mechanisms for enforcing cleanup that don't require closures like this: in C++, there's a technique called [[https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii][RAII]] ([[http://wiki.c2.com/?ResourceAcquisitionIsInitialization][RAII on Wiki Wiki Web]]) and in Python there's [[https://en.wikibooks.org/wiki/Python_Programming/Context_Managers][context managers]].
** Linked lists
*** Disclaimer
This is one of those topics you tend to learn in an undergraduate computer science curriculum and use rarely afterwards. My covering it in this reading group does not constitute an endorsement of its importance or the choice to include it in a typical curriculum. We're covering it because:

- For pedagogical reasons. Linked lists are a useful "jumping off point" for studying certain data structures and algorithms topics. (Although, typically we start with sorting algorithms, because those let you explore the same topics without having to talk about data structures on top of it.)
- They're a useful "shibboleth", a concept that interviewers will use as a shorthand to verify that you have computing knowledge. It's not fair, but being able to talk knowledgeably on this specific subject can convince someone that you know a lot about computer programming more generally.
- It happens to be a topic around which lots of Codewars problems are written.
- Some programming languages use linked lists a lot and it's good to recognize them.
- Linked lists happen to be an interesting application of recursion (which is probably why they are also relevant to a lot of Codewars problems).
- Under certain somewhat rare cases, linked lists are actually useful. (Any time you want to remove stuff from the middle or the beginning.)
*** Background
In order to understand linked lists, it's probably best to start with some systems-level stuff about your computer's memory. Memory is like a giant rack of cubbies, like the PO boxes at a post office. Each one is small enough to hold one thing, and you can go into any of them equally easily (at least, from the back; PO boxes are usually locked). Each cubby has a number on it, so you can talk about the cubbies with your friends ("check out what's in #108") and find the one you want without having to count them one at a time. This kind of memory is called "random-access". (Some kinds of memory are sequential-access, but they're outside the scope of this discussion. Think of old-school cassette tapes. These kinds of memory are not in as much use these days.) Each PO box has a number inside it -- nothing more or less.

This PO box metaphor corresponds to bytes of RAM. Each byte of RAM has an "address". Addresses start at zero and increase linearly. Each byte can only hold a number. Any byte can be accessed directly.

Sometimes you'll need to store a bunch of things next to each other. One way is to try to reserve a block of PO boxes, say numbers 104-132. This gives you room for 29 items. This is basically how arrays work. If you want to get the 5th item, you can use your knowledge of the block of PO boxes to say "Well, the first one is 104, so the fifth one must be 108", and jump directly there.

This is great until you need to add or remove items. Our block of PO boxes is exactly 29 items long. If we need to store more items than this, we need a bigger chunk of boxes. So when we add the 30th item, we have to find a bigger block of boxes, and (once we find it) copy everything over, one item at a time. This "resize" operation is relatively expensive, so we'd like to not do it that often.

What if we have *less* than 29 things? Do we need to resize here too? Well, actually, there's a trick. If you can afford to give up a PO box, you can use the first PO box to keep track of how many things you have, and know that only that many of them are in use, and the ones after are empty. (So, for instance, if box 104 says "10", then we know that boxes 105-114 are in use.) In this way, we can have an array that "grows" a little bit, until it can't grow any more, and then it resizes. Sometimes this is called a "vector" (which is a confusing name, I know).

All the PO boxes contain numbers. But the PO boxes are themselves numbered! So one PO box can store the number of another PO box (or, again, in the lingo, its "address"). The term for this is a "pointer". We'll see why this is useful in a minute.
*** Linked list
Instead of blocking off a giant chunk of PO boxes for your array of numbers, you can allocate just two. The first box (say, #104) will store the first number in your array (let's say it's 15). The second box (#105) will store the number of some other box (let's say it's #258), at which there are another pair of boxes, storing again another number in the array, and then another address. So you end up with something that looks like:

| Box | Contents    |
| ... |             |
|  24 | 4           |
|  25 | 0           |
|  26 | [unrelated] |
|  27 | [unrelated] |
|  28 | 1           |
|  29 | 38          |
|  30 | 3           |
|  31 | 24          |
|  32 | [unrelated] |
|  33 | [unrelated] |
|  34 | [unrelated] |
|  35 | [unrelated] |
|  36 | [unrelated] |
|  37 | [unrelated] |
|  38 | 2           |
|  39 | 30          |
| ... |             |

Our linked list starts at PO box 28-29. 28 is the first element, the number 1. 29 points to the next PO box, which is #38. 38 contains the next element of the list, 2, and 39 points to the next PO box. 30 contains the next element, 3, and #31 points to the next PO box, which is 24. 24 contains the next and final element of the list, 4, and #25 points to the next PO box. We use 0 to represent "no further elements". Our linked list contains the numbers 1, 2, 3, and 4, but spread out throughout memory.

Each pair of boxes is a "node" in the linked list, and by jumping from node to node, you can retrieve all its elements. The linked list is a chain organized by "next" pointers. Note that PO boxes do not have to be next to each other or indeed even "in order" (from the perspective of its contents)!

Sometimes this same list is drawn as a series of boxes, something like https://commons.wikimedia.org/wiki/File:Linked_list_data_format.jpg. Each box represents a node, which has two parts -- its actual data (in this case, the numbers 1 through 4) and the pointer to the next node.
*** Implementation in JS
You can think of a node in the linked list as a pair of things: some "data", and a pointer to the next node, usually called "next". In JavaScript, we can represent a node as an object, something like this:

#+BEGIN_SRC javascript
let linkedList = {
  data: 1,
  next: ...
};
#+END_SRC

Some languages (such as C) include the concept of pointers directly. JavaScript isn't one of those languages, but actually almost every variable in JavaScript is secretly a pointer. So we could do this:

#+BEGIN_SRC javascript
let secondNode = {
  data: 2,
  next: null
};

let linkedList = {
  data: 1,
  next: secondNode
};
#+END_SRC

Or more concisely:

#+BEGIN_SRC javascript
let linkedList = {
  data: 1,
  next: {
    data: 2,
    next: null
  }
};
#+END_SRC

When we write it like this, it stops looking like a chain of things pointing to other things, and starts to look more like one thing contained inside another thing, but rest assured that it's all pointers internally.

Note that a "linked list" is just represented as its first node! We could add other stuff, but this is the essence of it.

We can write the "abstract definition" of a linked list as something like (N.B. pseudocode)

#+BEGIN_SRC javascript
class Node {
  data,     //  number, for instance
  next      //  Node
}
#+END_SRC

In other words, it's a recursive structure! But don't forget to account for the possibility of an "empty" linked list, which contains no elements. Pop quiz: how is that represented? You can work backwards -- a linked list with one element must be a Node, followed by an "empty" linked list.

A more complete definition in a language like Haskell would be something like:

#+BEGIN_SRC haskell
data List = Node a List | Null
#+END_SRC

Because recursion and functional programming are such a natural pairing, there's a long history of linked lists in functional programming languages (even though they are often less efficient -- see below). Sometimes you'll encounter the terms "nil" to mean the end of a linked list, and a "cons cell" for the "node" (for instance, see https://stackoverflow.com/a/2689376/6107066).

[In a language like C, recursive structures have to use pointers because the compiler needs to know how much space to reserve for each Node. If a Node can truly contain another Node, then that means each Node takes up as much space as a Node does, plus some bytes -- but that means Nodes are either inconsistently sized, or infinitely big. So instead we make the "next" a pointer, which is always a fixed size.]
*** Operations
Stop and think about these basic operations, and how you might do them in linked lists or arrays:
- Insert an element in the middle of the sequence
- Remove an element from the middle of the sequence
- Add an element to the end of the sequence
- Access the 10th element of the sequence

Some of these operations are cheaper in linked lists rather than arrays. However, one hidden consequence of arrays is that they're good for what is called "locality". If you're going to operate on one element of the array, the processor may guess that you are going to operate on others, and start to preload surrounding memory, which will make subsequent operations faster. With a linked list, the processor may still guess this and preload memory, but it will contain stuff you don't care about. For this reason, in practice, arrays are often faster (which is why Python lists and JavaScript arrays are implemented internally with arrays). But this could change if the balance between processor and memory speed changes.

Note also that this "optimization" came at a cost -- linked lists require twice as much memory to store the same stuff! This is because the "next" pointers take up space (whereas in an array, the "next" element is just the next box over). On the other hand, we didn't have to find a big block of contiguous memory, which can be useful sometimes.

http://www.codewars.com/kata/linked-lists-push-and-buildonetwothree is a Codewars problem for implementing a specific implementation of linked lists. It links (hah!) to a bunch of other problems where you get to implement the standard sorts of operations for linked lists. https://www.codewars.com/collections/fun-with-lists is similar. https://www.codewars.com/kata/convert-a-linked-list-to-a-string is another little linked list one. https://www.codewars.com/kata/zipwith-ii-lists is a bit more advanced, requiring you to implement "zipWith", which is a common higher-order function, on linked lists (rather than just arrays).

[Spoilers for the above: With this linked list structure, it's quite easy to insert or remove elements anywhere in the chain (you just have to change a couple pointers). This is very different from arrays, where you have to copy lots of elements around in order to operate in the middle (or even the beginning). However, this structure is not random access -- if I want to get to the 5th element, I have to follow 5 "next" pointers.]
*** Variations
If you take a data structures and algorithms class, you'll hear about differen flavors of linked list -- the kind that we describe here is a "singly linked" list, with each node pointing to the next. Other kinds include "doubly linked", which include pointers both forwards and backwards, and "circular", where the "next" pointer at the end goes back to the start. There aren't really major distinctions, but you can read about them a little bit on Wikipedia.
** Templates
*** Motivating example
Someone designed our website. They hand us HTML for two pages -- a "landing" page that looks like this:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <h1>Welcome to the jungle!</h1>
    <p>
      Welcome to the jungle.com design refresh. We hope you like it!
    </p>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

And a page for individual blog articles which looks like this:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li>Some blog article title</li>
      </ul>
    </header>
    <h3>Some blog article title</h3>
    <h4>by Fred Bloggs on August 12th, 2018</h4>
    <p>
      Blog content goes here. This is an article about some topic.
    </p>
    <p>
      Blog articles can have a lot of content. Here's more content.
    </p>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

Our job is to write a server program that renders both types of HTML depending on what page it is.
*** Raw code
Let's try just writing code that assembles HTML out of strings.

#+BEGIN_SRC javascript
function renderMainPage() {
  let output = [];
  output.push("<html>");
  output.push("  <head>");
  output.push("    <link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" />");
  output.push("  </head>");
  output.push("  <body>");
  output.push("    <h1>Welcome to the jungle!</h1>");
  output.push("    <p>");
  output.push("      Welcome to the jungle.com design refresh. We hope you like it!");
  output.push("    </p>");
  output.push("    <footer>Copyright 2018 The Jungle.com.</footer>");
  output.push("  </body>");
  output.push("</html>");
  return output.join("\n");
}

function renderBlogPost(blogPost) {
  let output = [];
  output.push("<html>");
  output.push("  <head>");
  output.push("    <link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" />");
  output.push("  </head>");
  output.push("  <body>");
  output.push("    <header>");
  output.push("      You are here:");
  output.push("      <ul>");
  output.push("        <li><a href=\"/\">Home</a></li>");
  output.push("        <li>" + blogPost.title + "</li>");
  output.push("      </ul>");
  output.push("    </header>");
  output.push("    <h3>" + blogPost.title + "</h3>");
  output.push("    <h4>by " + blogPost.author.name + " on " + blogPost.publishDate + "</h4>");
  let paragraphs = blogPost.content.split("\n\n");
  for (let i = 0; i < paragraphs.length; i++) {
    output.push("<p>" + paragraphs[i] + "</p>");
  }
  output.push("    <footer>Copyright 2018 The Jungle.com.</footer>");
  output.push("  </body>");
  output.push("</html>");
  return output.join("\n");
}
#+END_SRC

Ugh! This is super gross. We had to mix HTML and JS. The HTML is encoded as JS strings which makes it almost unreadable. Not only that, there's a JS indentation which can be different from the HTML indentation so again it's really hard to match up what's supposed to close what. Front-end developers can often do some great stuff if they have access to the HTML and CSS, but here they can only touch "their" code by going through "our" code. This makes it much harder for them to do their work. What a disaster!
*** JSP/ASP/PHP
So instead let's define a kind of "template language". It will look mostly like HTML and it will have certain special non-HTML commands that we can use to embed code. In the late 90s, Microsoft came out with Active Server Pages, and in Java there was something called Java Server Pages, and around the same time PHP was starting to get popular, and it uses a similar style (although in PHP, *everything* is HTML, whereas in JSP-based applications, most things are Java, and JSP files are the exceptions).

Converting the "blog post" function above, we'd get something like this:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li><%= blogPost.title %></li>
      </ul>
    </header>
    <h3><%= blogPost.title %></h3>
    <h4>by <%= blogPost.author.name %> on <%= blogPost.publishDate %></h4>
    <% let paragraphs = blogPost.content.split("\n\n"); %>
    <% for (let i = 0; i < paragraphs.length; i++) { %>
    <p>
      <%= paragraphs[i] %>
    </p>
    <% } %>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

OK, this looks a little better. A web designer who is only familiar with HTML could probably work with this. There are some variables and stuff that would only get filled in later, but they could probably just work around that. It looks much more like HTML with a little bit of code sprinkled in.

How does it work? We can translate this kind of JSP into the previous function just by copying everything that isn't "special" into the function, and storing it in an output variable, like we did above. There are only two "special" constructs: ~<% foo %>~, which represents code that we put into the function directly, and ~<%= foo %>~, which represents an expression whose output we will concatenate into our function's rendered output.

Note that the JSP refers to a variable called ~blogPost~, but (unlike the function) there's no explicit "argument" to the JSP. Instead, templates like this have what's called a /context/, a set of variables which are made available to the template.

In the early '00s there were a proliferation of different template languages. Some are tied very tightly to rendering HTML, for example https://en.wikipedia.org/wiki/Template_Attribute_Language. Most aren't really used any more.
*** DRY
Unfortunately, we have a bunch of repetition in these pages, and (as you know) repetition hurts our souls. For example, on January 1st, we have to change the copyright date in the footer, which means we have to change every single JSP. So maybe we need to figure out a way to start sharing some of this code.

Let's imagine we had a function called ~render()~. This function could take the name of a template and return the rendered output of the template. In other words, it's a way to include one template in another template. Then we could define a ~header.jsp~ file like this:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
#+END_SRC

And a ~footer.jsp~:

#+BEGIN_SRC jsp
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

Now we can share those pieces in other templates. For example, our ~blogpost.jsp~ file might now look something like this:

#+BEGIN_SRC jsp
<%= render("header.jsp") %>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li><%= blogPost.title %></li>
      </ul>
    </header>
    <h3><%= blogPost.title %></h3>
    <h4>by <%= blogPost.author.name %> on <%= blogPost.publishDate %></h4>
    <% let paragraphs = blogPost.content.split("\n\n"); %>
    <% for (let i = 0; i < paragraphs.length; i++) { %>
    <p>
      <%= paragraphs[i] %>
    </p>
    <% } %>
<%= render("footer.jsp") %>
#+END_SRC

Now when we edit the footer, it takes effect everywhere, because the footer is actually shared.

Exercise: convert the home page to a JSP that uses the header and footer in the same way.

There are some problems with the above approach. For example, you could forget to include the footer and everything will "seem" fine. (You won't have the closing ~</body>~ and ~</html>~, but most browsers will automatically figure out that these tags should be closed, and will insert closing tags for you.) This means you have to check every page to remember to include the footer.

What about page titles? The ~<title>~ element has to go into the ~<head>~, which is defined in ~header.jsp~. One option might be to add the "context" to the ~render~ call:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
    <title><%= title || "Home page" %>
  </head>
  <body>
#+END_SRC

#+BEGIN_SRC jsp
<%= render("header.jsp", {title: "Blog: " + blogPost.title}) %>
... rest of the page ...
#+END_SRC

OK, but what about other stuff that we might want to add to the ~<head>~ element, like other CSS files or ~<meta>~ tags? Maybe we can add another "extra code" variable to the header:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
    <title><%= title || "Home page" %>
    <%= extraCode || "" %>
  </head>
  <body>
#+END_SRC

#+BEGIN_SRC jsp
<%= render("header.jsp", {
      title: "Blog: " + blogPost.title,
      extraCode: "<link rel=\"stylesheet\" type=\"text/css\" href=\"blog.css\">",
    }) %>
... rest of the page ...
#+END_SRC

This is starting to get us back to where we started, with HTML embedded in code, only now it's almost worse because we have HTML embedded in code embedded in HTML! Yuck.
*** Django style
Django templates were invented for the Django web framework and seem to have influenced lots of other systems (such as Twig and Nunjucks; Mustache and Handlebars also look a little similar but are apparently inspired by another system called ctemplates which was invented at Google). The ideas here were that we want to minimize the amount of actual code that happens in the template -- it should be (as much as possible) just pure layout and design, with the bare minimum of code permitted to allow the HTML to be written correctly. Django templates also introduced a new feature, called template inheritance, which helps us with the kinds of problems we were facing before of extensibility.

The syntax of Django templates is a little different from other languages. Instead of ~<%= expression %>~, you write ~{{ expression }}~. Also, you can have filters, which are sort of like functions that the template language provides: ~{{ expression|filter }}~. Instead of ~<% code; %>~, you write ~{% code %}~, but be careful because Django templates don't let you write arbitrary code -- only certain commands are allowed. So a simple definition of our blog post template might look like this:

#+BEGIN_SRC django-html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li>{{ blogPost.title }}</li>
      </ul>
    </header>
    <h3>{{ blogPost.title }}</h3>
    <h4>by {{ blogPost.author.name }} on {{ blogPost.publishDate }}</h4>
    {% for paragraph in blogPost.content.split("\n\n") %}
    <p>
      {{ paragraph }}
    </p>
    {% endfor %}
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

Seems straightforward enough. What about the re-use problem (sharing the header and footer), like we saw before? For that, we have template inheritance. Template inheritance works a little bit like object-oriented programming does. First, someone defines a "layout", which is like a parent class. For our case, we might write a ~layout.dhtml~ file that looks like this:

#+NAME: layout.dhtml
#+BEGIN_SRC django-html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    {% block body %}
      This is the default content.
    {% endblock %}
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

We see that this is a "complete" Django template -- nothing is missing, nothing indicates in any way that this is a "parent" template. We can even render this template, and if we do, the ~{% block %}~ will render its contents, so we'll get:

#+BEGIN_SRC django-html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    This is the default content.
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

We can think of this "layout" template as turning into object-oriented like this:

#+BEGIN_SRC javascript
function Layout() {
}
Layout.prototype.render = function() {
  let output = [];
  output.push("<html>");
  output.push("  <head>");
  output.push("    <link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" />");
  output.push("  </head>");
  output.push("  <body>");
  output.push(this.renderBlockBody());
  output.push("    <footer>Copyright 2018 The Jungle.com.</footer>");
  output.push("  </body>");
  output.push("</html>");
  return output.join("\n");
};
Layout.prototype.renderBlockBody = function() {
  let output = [];
  output.push("This is the default content.");
  return output.join("\n");
};
#+END_SRC

In other words, each block becomes a method, but also simultaneously becomes a place where the method is called. This makes the block a "hook", something that we can attach to if we want to change the behavior of the template.

So how do we hook into it? We ~extend~ the template. We might write a ~homepage.dhtml~ file that looks like this:

#+NAME: homepage.dhtml
#+BEGIN_SRC django-html
{% extends "layout.dhtml" %}

{% block body %}
    <h1>Welcome to the jungle!</h1>
    <p>
      Welcome to the jungle.com design refresh. We hope you like it!
    </p>
{% endblock %}
#+END_SRC

This gets translated into something like this:

#+BEGIN_SRC javascript
function HomePage() {
}
HomePage.prototype.renderBlockBody = function() {
  let output = [];
  output.push("<h1>Welcome to the jungle!</h1>");
  output.push("<p>");
  output.push("  Welcome to the jungle.com design refresh. We hope you like it!");
  output.push("</p>");
  return output.join("\n");
};
#+END_SRC

So now, when we render the home page, we start by rendering the parent template (in this case ~layout.dhtml~). That means we get the overall structure of the page first:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <!-- SPACE left here because this is where block body goes -->
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

But then, because the home page "overrode" the body block, we get its content instead of the content from ~layout.dhtml~. So we end up with:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <h1>Welcome to the jungle!</h1>
    <p>
      Welcome to the jungle.com design refresh. We hope you like it!
    </p>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

... which is where we started.

So why is this better?

- One problem we had before was that it was possible to ~render~ the header and forget to ~render~ the footer. Here, that's not possible -- if you extend a template, it surrounds you completely.

- Another problem we had was that we had very little flexibility in our templates. ~header.jsp~ could provide a way to set a title, but not much more than that. It was impossible to add HTML code to a "helper" template like ~header.jsp~. But now that we have blocks, it's easy to put empty blocks wherever we like and child templates can pick and choose the ones that make sense for them to override. Additionally, overriding a block takes place in the template, so we are free to directly add HTML rather than writing it as strings.

- Another nicety is that we can see the whole layout in one file, rather than having to piece it together between the ~header.jsp~ and ~footer.jsp~. If we forget to close a tag, it's more obvious, because both the opening and closing are in the same file.

This style of templating is very powerful! A parent can define blocks, and then a child can "fill in" those blocks, and it can even define its own blocks, that can be then filled in by grand-children, and so on.

Exercise: convert the blog post template to extend the layout we've defined.

Exercise: the home page should have a title of "Welcome to the Jungle", and the blog post pages should have a title of "Jungle Blog: Some Blog Post Title". How can we modify the templates to make this happen?

Exercise: what do we have to add to allow blog post pages to have an additional CSS file (~blogpost.css~) without it being present on the home page?
*** Next steps: client-side templating
These templating systems are typically used in server-side systems. In these systems, a request comes in, a bunch of information gets looked up, and we render that information to a response. That response contains HTML that's relatively static. We can sprinkle some JS on it for small stuff, but very complicated web applications that involve updating HTML will often go back to the server, since that's where the templates are.

Let's say we wanted to design an application that let us add elements to a shopping list. As we add each item, we need to add more HTML to the page. But we want the application to be AJAX. One possibility is to have the HTML on the client side instead of the server side. Then, we can render each item as we add it without having to consult the server.

This leads us to libraries like Mustache and Handlebars, which are designed to render templates in the browser.

Another nice thing would be to track changes to our variables in JS and automatically update the DOM. If the DOM is generated by the templates, then it should be easy to render them again with our data. This idea leads us to libraries like React and Vue.

React templates are usually written in a language called JSX, which is embedded in JS. A page might look like this:

#+BEGIN_SRC javascript
class HomePage extends React.Component {
  render() {
    return (
      <html>
        <head>
          <link rel="stylesheet" type="text/css" href="site.css">
        </head>
        <body>
          Welcome to the {location}!
          <MyFooter />
        </body>
      </html>
    );
  }
}

class MyFooter extends React.Component {
  function render() {
    return (
      <footer>Copyright 2018 The Jungle.com.</footer>
    );
  }
}
#+END_SRC

In JSX, elements are just written straight into the JavaScript code. Wait, isn't this where we started, and what we tried to get away from? Basically, yes. But in the meantime, the culture has changed -- instead of getting enormous blocks of HTML from some guy using Dreamweaver, the expectation is now that the front-end is code that is every bit as powerful and important as the stuff happening on the back-end.

A full treatment of React is outside the scope of this document, but it's worth pointing out some features of the syntax:

- Each React "component" defines its own ~render()~ function explicitly.
- The render function returns something like the DOM (specifically, it returns a tree of elements).
- A component can use other components by including it directly in its tree of elements.
- It's not possible to forget to "close" an element because the syntax reflects an HTML fragment, which means opening and closing tags are balanced.
- Instead of using ~{{ expression }}~, we do ~{expression}~.
- We can also use expressions as "attributes" to our elements, which is how we pass arguments to them.

If your application feels like it's too interactive for the old-fashioned "server-side framework which renders HTML which has some JS sprinkled on top", then you might end up using something like React. This ecosystem is still very young, though, and there are enough complications that it's not a decision to be made lightly. If you aren't sure whether your project is a good fit for something like React, ask a senior engineer.
