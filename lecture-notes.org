#+HTML_HEAD: <style type="text/css">pre.src { background-color: #333; color: #fff; }</style>
* Reading group
** Modeling
Ground rule: If you don't understand something, ask as soon as possible -- it's probably my fault for not explaining it well. If there's something that it's OK not to understand, I'll say so, so assume that everything I said, I was trying to make you understand, and if I didn't succeed, I would like to know that.

The Django tutorial I linked to isn't super great for beginners -- it's kind of targeted at experienced web developers. The goal for these first few weeks is to get us to a place where we have *something* up and running, so for now, it's OK not to understand all of that document. That said, I would love for people to learn/get practice with reading technical documentation. It's something of an art!

The first part of building a web application in Django is defining the structure of your database, so we're going to spend some time talking about that today.
*** What is a web application?
At it's most fundamental level, a website is basically some HTML and some images. Some of you have probably already studied a little HTML and it's not really that interesting. In particular, it's static. It will keep staying the same until you write new HTML.

A web application is a program that generates HTML when you visit, so that it can be *dynamic*, or have the potential for change. This makes it something that a user can interact with, without having to write HTML themselves.

Django (and most similar software) anticipate that you will want to base your application on some data, and that application can manipulate that data, and that data is what the user sees and interacts with by interacting with your application. So it's: User <-> Application <-> Data.

In order to make it easy for your application to manipulate data, it's stored in a database.
*** What is a database?
A database is another piece of software which is in charge of storing and organizing data[1]. We are going to be using a kind of database called a "relational" database (specifically we're going to start by using SQLite, but most databases that have "SQL" in the name function similarly).

You can think of a relational database as kind of like an Excel workbook. A relational database has "tables", which are like sheets in a workbook. Each table is a collection of rows, each of which has the same set of columns. So you might have a "people" table that looks like this:

| Person  | Number of pets | Signed up date |
| Ethan   |              1 |     2015-05-01 |
| Rita    |              0 |     2015-05-18 |
| Francis |              1 |     2015-05-08 |

And you might have another table that stores hobbies:

| Person  | Hobby        |
| Ethan   | Chiptune     |
| Rita    | British rock |
| Francis | Death metal  |
| Ethan   | Baking       |
| Francis | Kendo        |
| Rick    | Beer         |

If you had this data stored in a relational database, it would be possible to ask it to "put it together" and generate a table like this:

| Person  | Number of pets | Number of hobbies |
| Ethan   |              1 |                 2 |
| Rita    |              0 |                 1 |
| Francis |              1 |                 2 |

"Relational" is a long word so I'll probably use it interchangeably with "SQL" (pronounced "sequel"), even though technically the two things aren't exactly the same.

[1] This is a wild oversimplification, but "database" is a term that gets used a lot in a lot of contexts with subtly different meanings.
*** Modeling
When you're using Django (and probably when you're developing any kind of application), the first thing you do is think about what are the entities that you're going to have in your application, and how they relate to one another. For example, in a hospital management system, you might have patients and doctors and rooms, and patients stay in rooms and doctors visit patients (but doctors don't stay in rooms). Once you have a clear idea of what the entities are, you structure your database to support that. In Django, you write the structure of your database in a file called "models.py". You translate this structure into your actual database using the "python manage.py migrate" command.

In the tutorial, they take the example of a "poll", which they define as being a "question" with a variable number of "answers". ("Variable" meaning that one question might have two answers, and another question might have three answers.)

[Side note: Let's say I created my table to be like this:

| Question text | Publication date | Choice 1 text | Choice 1 votes | Choice 2 text | Choice 2 votes | Choice 3 text | Choice 3 votes |
| What's up?    |       2015-05-01 | Not much      |              0 | The sky       |              0 | Just hacking  | 0              |

In doing this, I'm asserting that EVERY question have exactly 3 choices! Clearly they can't have more choices because there's no where to put them, but it's also true that they can't have less choices because what will I put in the 3rd choice?

In other words, notice that columns are *constant* in a relational model, so if you want to have a variable number of something, you have to turn those somethings into rows somehow.]
*** Demo
Once you have your models set up, you can create Python objects and make them go into the database, and similarly you can get things out of the database as Python objects. This might not be impressive, but it's the same thing your application is going to do when users interact with it.

You can access the database your program created using the "sqlite3" command (which you might have to install using apt-get or yum or something). This part isn't super important because Django mostly insulates you from it, but I thought it might be interesting to see what's going on "underneath the hood", and sometimes this is useful for debugging.

To open your database in sqlite, you can type "sqlite3 db.sqlite3". In sqlite, you can do .tables to show the tables. A table was created for "polls_question" and another for "polls_choice". You can see what the "schema" (table structure) for a table was using e.g. ".schema polls_question". You can also see what is in your database using a SELECT statement.

#+begin_src
sqlite> select * from polls_question;
1|What's new?|2015-05-18 04:33:32.860786
2|Should I go to work today?|2015-05-18 04:34:51.572901

sqlite> .schema polls_choice
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id"));
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

sqlite> select * from polls_choice;
1|Not much|0|1
2|The sky|0|1
3|Just hacking again|0|1
4|Yes|0|2
5|No|0|2
#+end_src

So, we see that each choice has FOUR attributes -- an ID for itself, a text, a count of votes, and the ID of the question to which it is associated.

Note that each choice uses the question ID -- in my example above, I used people's names, but using an ID is more natural. For one thing, it lets people change their names without having to change it in a lot of places, and I don't have to worry about them being spelled slightly wrong. For another, names aren't unique, but IDs are.
*** Many-to-many relationships
The example in the tutorial defines a many-to-one relationship -- one choice belongs with one question, but one question has many choices. This kind of relationship, as well as the even simpler one-to-one relationship, is generally implemented by putting the ID of the related object in the table.

There's another kind of relationship between entities called a many-to-many relationship. The relationship between people and hobbies is a good example. Each person has many hobbies, and each hobby can be associated with many people. Traditionally, this is implemented using a "join table" -- a table that just tracks the IDs of both objects. So you might have:

A "people" table:

| ID | Name    | Number of Pets |
|  1 | Ethan   |              1 |
|  2 | Rita    |              0 |
|  3 | Francis |              2 |

A "hobbies" table:

| ID | Hobby        |
|  1 | Chiptune     |
|  2 | British rock |
|  3 | Death metal  |

The "person-to-hobbies link table":

| Person ID | Hobby ID |
| 1         | 1        |
| 2         | 2        |
| 3         | 3        |
| 3         | 1        |

Django can handle this for you too, but you'll have to read more documentation: https://docs.djangoproject.com/en/1.8/topics/db/examples/many_to_many/.
*** Homework
- Let's start small -- instead of a whole dollhouse, let's just design a schema for a paper doll application. A paper doll has a name (e.g. "Princess" or "Zoe") and some articles of clothing. Each article of clothing has a filename (e.g. "gloves.png") and a location (e.g. arms, torso, legs, head). What should the tables look like?

- Go through the tutorial again and try to create another application in your existing site. Call it "paperdolls". Try to define the models the same way they do in the tutorial. To test them, try going into the shell and create objects the way they did (although using your models instead of the polls one). Post any error you get to the mailing list, along with the contents of your models.py.
** Views pt 1
*** Homework review
Here are my solutions:

**** Solution 1
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    doll = models.ForeignKey(Doll)

    filename = models.CharField(max_length=200)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Doll ID | Filename      | Location |
|  1 |       1 | gloves.png    |        2 |
|  2 |       1 | red-dress.png |        0 |
|  3 |       1 | sandals.png   |        3 |
|  4 |       2 | tiara.png     |        1 |
|  5 |       2 | lab-coat.png  |        0 |

**** Solution 2
#+begin_src python
class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class Doll(models.Model):
    name = models.CharField(max_length=200)
    torso_item = models.ForeignKey(ClothingItem)
    head_item = models.ForeignKey(ClothingItem)
    arms_item = models.ForeignKey(ClothingItem)
    legs_item = models.ForeignKey(ClothingItem)
#+end_src

Dolls table:
| ID | Name     | Torso | Head | Arms | Legs |
|  1 | Princess |     2 | ???  |    1 |    3 |
|  2 | Zoe      |     5 | 4    |  ??? |  ??? |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

**** Solution 3
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class DollWearsClothing(models.Model):
    doll = models.ForeignKey(Doll)
    clothing_item = models.ForeignKey(ClothingItem)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

Doll Wears Clothing table:

| ID | Clothing ID | Doll ID | Location |
|  1 |           1 |       1 |        2 |
|  2 |           2 |       1 |        0 |
|  3 |           3 |       1 |        3 |
|  4 |           4 |       2 |        1 |
|  5 |           5 |       2 |        0 |
|  6 |           3 |       2 |        3 |
*** Syntax
Syntax refers to the structure of a language. In English, the sentence "The dog bit the man" is well-formed according to English syntax. The sentence "The bit dog man the" has invalid syntax. The sentence "The man bit the dog" has valid syntax but questionable semantics. In programming languages, we sometimes use "syntax" as an umbrella term for all the rules of the language that give it sense to the computer, which also include semantics.

Depending on how far you've gotten in the Django tutorials, you've seen lots of different syntax so far:

- =from foo import bar= at the beginning of a bunch of different files
- =class Foo():= for models
- =blah = models.CharField()= for fields in those models
- =def __str__():= when defining models
- =INSTALLED_APPS = (...)= when "activating" models
- ='words'= and sometimes ="words"=
- =def foo():= for views
- =urlpatterns = [...]= when setting up views
- =url(r'...', foo)= when setting up views
- =%= in some views

I'm going to touch on the essentials of the most important parts of the most important ones of these, and mention a few details about some of the others, because the goal is to get us up and running as fast as possible without wearing you down with details that aren't important yet. These are just simplistic summaries!
*** Django settings: variables
In almost any programming language, you can do stuff like this:

#+NAME: print_variables
#+begin_src python :results output
x = 5
print(x)
print(x + 3)

x = 6
print(x)
print(x + 3)
#+end_src

If I run this program, it will show:

#+RESULTS: print_variables
: 5
: 8
: 6
: 9

What's going on is that when Python sees the line =x = 5=, it creates a thing called =x=. Wherever it sees =x=, it checks the last value it got for =x=, which in this case is 5. =x= is called a variable, and you can think of it as like a box in the computer's memory that has some "value" inside of it. When Python then sees the line =x = 6=, it will take the 5 out of the box and put the 6 in.

There are many different kinds of values that we can put into a variable.[1] In the above example, =x= is an integer (in Python, we say =x= is an =int=). You can also have bits of words and sentences in variables: just do =x = 'hello'= or =x = "hello"= (they're equivalent). These bits of text are called "strings" (in Python, we say they are =str=). You can have truth values =True= and =False=, which are called Booleans (in Python, =bool=). You can also have lists, which are written =x = [1, 2, 3]= (in Python these are called =list=\ s, but in other languages they're called arrays or vectors). There's also something called a tuple, which is written =x = (1, 2, 3)=, but for now we're going to say it's the same as a list.

There are a bunch of places where you get to customize how Django does some things. We've already seen that we need to update =INSTALLED_APPS= when we add a new app. =INSTALLED_APPS= is an ordinary variable that Django gives some special meaning to. Most of these variables are written in all uppercase, but some (like =urlpatterns=) aren't, and you just have to know that they're special.

[1] In some languages, each variable has to be "declared" to hold only some types of values. Python isn't like that; instead it uses "dynamic typing", which means that any variable can hold any value, and even change from one type of value to another. This has advantages and disadvantages.
*** def foo(): functions/methods
Any time you see =def foo(...)=, we are defining a function. A function is a part of a program. Like a program, a function has some operands, which are called parameters or arguments, and a result, which is called the "return value". Here's an example:

#+begin_src python
def check_password(password):
    if password == 'stairs_are_history!':
        return True
    elif password == 'swordfish':
        return True
    else:
        return False
#+end_src

Here's how you might use it:

#+begin_src python
user_password = input()
password_correct = check_password(user_password)
if password_correct:
    print("Welcome back!!")
else:
    print("Incorrect password")
#+end_src

So when you see the code =check_password(user_password)=, that's saying "Begin doing the stuff under =def check_password=. Also, when doing those things, the variable =password= is going to have the value that =user_password= does.[2][3]" Then, Python goes through line after line, doing what that line says, until it either gets to the end of the =def= or it hits a =return=. If it hits a =return=, the function immediately ends and the value after the =return= is sent to wherever the =check_password()= line was.

Using a function is a nice way to group some commands together and use them many times in different places. For this reason, Django uses them to represent views.

The syntax for a function is:

#+begin_src python
def FUNCTION_NAME(PARAM1, PARAM2, ....):
    STATEMENT1
    STATEMENT2
    ...
#+end_src

N.B. A function definition ALWAYS has a colon (=:=) after the parameter list, and the statements in the function are ALWAYS "indented" by four spaces. Some of those statements might have their own sub-statements, which might be inset by another four spaces, and so on. The function continues until Python sees a non-blank line that isn't indented by four spaces.[4]

To use the function, you write the name of the function, plus the things you want the function to operate on. Then Python will start doing the various statements, one after the other. If the function is going to return something, you can put a variable in front of it, or use it in another function, or whatever.

As a general rule, using a function looks almost exactly like using an entity or a class, but functions usually have lowercase names and entities and classes have Capitalized names.

You can also define functions inside classes; these are called methods and we'll talk more about them several weeks from now. In the first part of the tutorial, you defined one called =was_published_recently=.

=__str__()= is a special method that is used whenever an object needs to be displayed. We won't dwell on it right now.

[2] Again, it isn't necessary to specify a type for =password=; like any variable, it can take any value.

[3] =password= is what's called a "local" variable; it will disappear as soon as the function is over.

[4] Some of you have been using TABs instead of spaces. In the Python community, this is discouraged -- it should always be 4 spaces. If you're lucky, you can set up your text editor to insert 4 spaces when you press the TAB key. For instance, on =gedit=, I was able to find a thing on the bottom of the window that says "Tab width: 8 spaces"; clicking on it let me set it to 4 spaces and "use spaces instead of tabs".
*** import
In Python, when we want to use models, functions, or variables from another file, we use the =import= command. There are many different ways to import things, none of which we're going to discuss now. If you forget to import something, you'll usually get a =NameError= saying that something wasn't defined.
*** . ("dot")
*** Homework
Go through all the files in your site so far. Find examples of the following:
- functions being used
- stuff being imported
- a list
- a tuple

Press on and try to get to the end of part 3 of the tutorial. Hopefully by now we are starting to see how Django lets us build a web application.
** TODO add to email
Solution 1 is what I expected most of you to come up with. It lets you match clothing with dolls. One nice advantage to this system is that we can have multiple articles of clothing on the same doll in the same place. (So, socks and then sneakers, for example.) Similarly, you can have 0 articles of clothing on a part of the doll. Of course, if your requirements don't need/forbid this, that might be a disadvantage.

Solution 2 is kind of like a straw man, devil's advocate thing. Last week I said this isn't really possible because we don't know what to put in the =???= places. In fact, there is a way -- there's a thing called =NULL= which is like an empty space. Some people say =NULL= [[http://c2.com/cgi/wiki?NullsAndRelationalModel]["violates the relational model"]], which might or might not mean anything, but it certainly can make your life difficult if you expect something to never be =NULL= when in fact it sometimes is. For this reason, all fields in Django are not allowed to be =NULL= (this is also enforced by the database). If you want to change this, you can use the [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#blank][blank]] and [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.Field.null][null]] options in your fields.

Solution 2 doesn't let you have multiple articles in the same place, but it does have one nice advantage which is that it's easy to "share" an article of clothing between two dolls -- you just re-use the ID. In Solution 1, this would require duplicating the filename, which is error-prone. (If you move the filename and forget to update it everywhere, you will have a data consistency problem.)

Solution 3 has the advantages of both solution 1 and solution 2 -- you can share clothing, plus you can have multiple clothing in the same place. But there's something weird in it, which is that the location of the same article of clothing can be different for different dolls.

Any of these solutions might be OK depending on what your requirements are, but I'd probably go with solution 3, but move =location= to the Clothing table, and I'd add a column to the Wear table that specifies order (so that socks always go under sneakers).
** office hours
*** exercise 1: change your index view to say "This is the paper dolls index"
*** exercise 2: make it show your index view when you go to polls/hello
*** exercise 3: create a new view that says "I finished exercise 3!" when you go to /ex3
** urlpattern exercises feedback
- /blog was intentional; the goal was to hammer in the point that the name of the files on-disk don't have to correspond to the names in the URLs.
- In exercise 4, when we want to match any player's name, we can use the dot character ('.') in the pattern to match anything at all.
- You can use the name of a view directly in the site's urlpatterns -- you don't have to include a file if you don't want to. You can just give the path to the view and Django will import it for you. So for example you can write 'polls.views.index'. The last part of the path represents the name of the view; everything else represents the name of the module where to find the view.
- For the last exercise: yes, in fact, you can make this work -- the Drupal CMS is set up like this. Everything is just a "node" and depending on what kind of node you get out of the database, you then do something different with it. Yes, this is kind of backwards, and nobody sane does it. Drupal is written in PHP, so you can safely consider them insane.
** Views pt 2
Outstanding questions: what is this .format() business?

It's a pretty common situation where you want to have a string built from text and variables. Here's the "simple" way to do that in Python:

#+begin_src python
x = 5
y = 10
s = "The sum of " + str(x) + " and " + str(y) + " is " + str(x + y)
#+end_src

Kinda wordy. So most recent languages offer something called "string interpolation", which is a mechanism whereby the language can help "fill in" the string with other bits of text.

Python actually has two string interpolation mechanisms. The tutorial uses this form:

#+begin_src python
x = 5
y = 10
s = "The sum of %s and %s is %s" % (x, y, x+y)
#+end_src

In the exercises, I used this form:

#+begin_src python
x = 5
y = 10
s = "The sum of {} and {} is {}".format(x, y, x+y)
#+end_src

The first format is older, and inspired by older mechanisms like C's ~printf~. The second one is newer and more powerful. For instance, if you forget which one is supposed to be x and which one is supposed to be y, you can do this:

#+begin_src python
x = 5
y = 10
s = "The sum of {x} and {y} is {xplusy}".format(x=x, y=y, xplusy=x+y)
#+end_src

The full details are available in https://docs.python.org/3.5/library/string.html#format-string-syntax.
*** Recap to this point:
We've actually learned a lot of "mini-languages", including SQL, regular expressions and format strings. We're actually going to learn another three or four in the near future -- today's is the Django template system.
*** Templates
So far we've written views that just produce responses. But an actual web page is an enormous blob of HTML, some of which is shared between pages and some of which is completely different. Dumping all of that into your ~views.py~ file would rapidly become unmaintainable.[1] So most web frameworks offer a notion of "templates", which are another mini-language that make it easier to generate HTML.

Here's a template (let's pretend we saved it as ~polls/some-template.html~:

#+begin_src jinja
Hello, {{ thing }}!
#+end_src

In Django, the usual way to use a template is to turn it into an HttpResponse, like this:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

The ~render~ function takes three arguments -- the request, the name of the template, and any arguments for the template. These arguments are sometimes called a /context/. The template can access anything in the context. Together, the above should produce:

#+begin_example
Hello, world!
#+end_example

Templates help institute a division between code and presentation. Typically front-end engineers work on templates (and CSS and JS), and back-end engineers work on code that provides stuff to those templates. We're going to be working a little bit on all of these.

[1] Maintainability refers to the property of software to be maintained, i.e. understood, debugged, updated and changed to do new things or to do them better. Maintainability is a big deal for software engineers. Usually maintainable code beats fast-to-write code, and fast-to-write code usually beats fast-to-run code, but this depends on what section of software you're in.
*** Contexts
A context is just a collection of variables for a template. Like all variables, these variables have a *name* and a *value*. In the example above, we created one variable called "username", whose value was "Ethan". Contexts are usually defined using syntax like:

#+BEGIN_EXAMPLE python
now = timezone.now()
ctx = {"username": "Ethan", "now": now}
#+END_EXAMPLE

This syntax means a "dictionary", which is made up of *keys* (before the colons) and *values* (after the colons).  You can look up the value for a particular key, or look at all values, or all keys.  If you access ~ctx["username"]~, that will produce "Ethan".

A context is a dictionary where all the keys are strings.
*** Template language
**** Default is to output
Most template languages are geared towards producing output. In fact, to produce output, you don't even need to give a command -- you just write text. Anything you write will be copied to the output.

Example:

#+begin_src jinja
This is some text without anything special going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

Produces:

#+begin_example
This is some text without anything special going on.
#+end_example

Note that when you're looking at your template, you're looking at plain text, but the template is being rendered as HTML, which is a bit different. In particular, blank lines in text are just spaces in HTML.
**** You can use variables
To access things from the context, you can write two curly braces, then the name of the thing in the context, and then two curly braces.

Example:

#+begin_src jinja
This is some {{ field }} without anything {{ adjective }} going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "field": "words", "adjective": "unusual", "name": "Ethan"
        })
#+end_src

Produces:

#+begin_example
This is some words without anything unusual going on.
#+end_example

As the example shows, you don't have to use everything in the context. It turns out that in Django's template language, you can try to use variables that *aren't* in the context and they will just silently fail and print nothing. I would encourage you not to rely on this behavior if you can avoid it.

You can also access attributes the same way you do in Python. So let's say you have some object in your context, like this:

#+begin_src python
def my_view(request):
    q = Question(id=1, question_text="What's up?")
    return render(request, "polls/some-template.html", {
        "question": q
        })
#+end_src

You can get the text "What's up" using:

#+BEGIN_EXAMPLE
Please answer the question: {{ q.question_text }}
#+END_EXAMPLE

Of course, you can access attributes of attributes of attributes, more or less the same way you do in Python:

#+BEGIN_EXAMPLE
You chose {{ c.choice_text }} for {{ c.question.question_text }}
#+END_EXAMPLE
**** Conditionals
Sometimes you have two different things you might want to do. For example, if polling has closed on a question, then maybe you don't want to let people vote, but if it hasn't closed yet, then you do.

#+BEGIN_SRC jinja
{% if q.was_published_recently %}
  OK, you can vote on this question.
{% else %}
  Sorry, polling has closed on this question.
{% endif %}
#+END_SRC

This is very similar to if statements in Python, which I think we saw a little bit of already, so I won't dwell on it. As in Python, you can write some (limited expressions) as the "condition". For example, here's how you could check if a choice hadn't received any votes yet.

#+BEGIN_SRC jinja
{% if c.num_votes == 0 %}
  Nobody has voted for this choice yet!
{% endif %}
#+END_SRC

N.B. The ~if~ command in Django templates is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~! Don't confuse the two!
**** Looping
So far we haven't talked much about types, but hopefully you remember that ~[1, 2, 3]~ is a list. If you have a list of things, you can do something with each element. So let's say we have:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "numbers": [1, 1, 2, 3, 5, 8]
        })
#+end_src

And the template:

#+BEGIN_SRC jinja
Do you notice anything about these numbers?

{% for number in numbers %}
  {{ number }} ...
{% endfor %}
#+END_SRC

This will produce:

#+BEGIN_EXAMPLE
Do you notice anything about these numbers?

  1 ...
  1 ...
  2 ...
  3 ...
  5 ...
  8 ...
#+END_EXAMPLE

This structure is called a *loop*. We haven't had to use it in Python, but it exists there and is very similar. Lots of things produce lists or other loop-able structures. How it works is, first ~number~ is set to the first thing in ~numbers~. Then, everything between ~{% for .... %}~ and ~{% endfor %}~ is run. Then, we go back to the top. ~number~ gets set to the *next* thing in ~numbers~, and then everything between ~{% for ... %}~ and ~{% endfor %}~ is run again. And so on, until there's nothing left in ~numbers~.

N.B. The ~for~ command, like the ~if~ command and most other commands in Django templates, is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~.
**** Filters
Certain other operations are allowed using a concept known as a "filter". For example, you can get the length of a list using:

#+BEGIN_SRC jinja
There are {{ numbers|length }} numbers.
#+END_SRC

You can select the first element of a list using:

#+BEGIN_SRC jinja
The first number is {{ numbers|first }}.
#+END_SRC

If you have a string you can convert it to lowercase using:

#+BEGIN_SRC jinja
When I am feeling blue, I sign my name as {{ name|lower }}.
#+END_SRC

There's even a "pluralize" filter that helps apply the rules for English pluralization (use a singular if n = 1, otherwise use plural). This isn't safe for international websites, but it's a useful shortcut otherwise.
#+BEGIN_SRC jinja
Here are your item{{ num_items|pluralize }}:
#+END_SRC

You can chain filters too, so if you want the first letter of a string, converted to lower-case, you can do:

#+BEGIN_SRC jinja
Not everyone's name can begin with {{ name|lower|first }}.
#+END_SRC
**** Summary
Django templates are actually tightly limited in scope. The designers of Django wanted to prevent people writing templates from having the ability to break a site by writing a bad template. However, the operations available in a template are specialized for generating text, so despite the limitations, they are still more useful than writing HTML in Python files.

A complete summary of the "built-in" functionality in the template system is available at https://docs.djangoproject.com/en/1.8/ref/templates/builtins/.
*** Database access
We've already agreed that a web application stores its data in a database, and so Django has to provide some mechanism that our websites can use to get data into and out of our database. We saw some of this in part 1 of the Django tutorial, but now is when we can really apply it. We need objects to give to our templates, and these objects are often going to come from the database, so let's review how we can do that.
**** Retrieving an object
Access to objects in the "database", rather than just a single object, or the model itself, is done through an ~objects~ field. If you have a model called ~Question~ and want to retrieve the one with ID 5, you can do:

#+BEGIN_SRC python
q = Question.objects.get(pk=5)
#+END_SRC
**** All objects
You can get access to all objects using the ~all()~ method:

#+BEGIN_SRC python
qs = Question.objects.all()
#+END_SRC
**** Filters and field lookups
What if you want only some of them? For example, you might want to get all the ~Questions~ that have a ~pub_date~ that is already passed, or you might want to get all the ~Choices~ with no votes. In this case, you add a filter using the ~filter~ method. Some examples:

#+BEGIN_SRC python
now = timezone.now()
qs = Question.objects.filter(pub_date__lte=now)
choices = Choice.objects.filter(votes__exact=0)
#+END_SRC

The parameters to ~filter~ are known as "field lookups". You can add as many as you like in a call to ~filter~. Each one expresses some criteria of the objects you are looking for.  These "lookups" are composed of (1) the field name that you are concerned with, (2) a double underscore (~__~), (3) some comparison you want to make with that field, (4) an equals sign (~=~), and (5) something to compare against. So, in the above, we see ~pub_date__lte=now~; ~pub_date~ is the field, and we are looking for the cases where that is ~lte~ (less than or equal to) whatever we have as ~now~. Similarly, ~votes__exact=0~ means to find all choices where the ~votes~ field is ~exact~ (exactly equal to) the value ~0~.

All fields are the ones we defined as fields in the model. However, if the field you want to use is a foreign key, you have to add a ~_id~ to the field name. So if we want to get all the choices for ~Question~ with ID 5, we write:

#+BEGIN_SRC python
choices = Choice.objects.filter(question_id=5)
#+END_SRC

There's one short-cut with field lookups -- if you don't specify a comparison, it's assumed to be ~exact~. So we can instead write:

#+BEGIN_SRC python
choices = Choice.objects.filter(votes=0)
#+END_SRC

(In fact, this is how the ~pk=5~ example above works too.)
**** Full documentation
A complete reference is available at https://docs.djangoproject.com/en/1.8/topics/db/queries/. Field lookups are also documented more extensively at https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups.
** Comments on the exercises
*** Types of model object
We've seen three different kinds of object:

- Model class. These are usually written in capitals (a.k.a. CamelCase) like ~BlogPost~. Model classes define fields, but don't themselves have those fields, so you can't do ~BlogPost.post_text~.
- An *instance* or object of this model class, like ~BlogPost.objects.get(pk=5)~. These are usually put in variables with lower-case-with-underscores names (a.k.a. snake_case, named for Python). If you have ~blog_post = BlogPost.objects.get(pk=5)~, then you can access its fields using ~blog_post.post_text~.
- There's also a "manager", which is the thing you see at  ~BlogPost.objects~. You go from the model class to the manager, and the manager provides access to the objects.
- There's also another type, which is "list of objects":
~BlogPost.objects.all()~ or ~BlogPost.objects.filter(...)~. If you have a list of blog post objects, each one of them will have those fields, but the list itself won't.

Model classes are like cookie cutters, and instances are like the cookies they've cut out. The model class defines the shape of the objects, and how they get made, but isn't itself one of them.
*** RequestContext
For the purposes of this exercise, we don't really need a ~RequestContext~ -- we could use the simpler ~Context~, which doesn't need access to the request -- but we may as well use the ~RequestContext~ everywhere. It's only actually used in a few cases -- the ~LocaleMiddleware~ tries to guess what language the user speaks, which is used when you use ~{% trans %}~ in a template, and there's a thing called *CSRF* which requires sending something to the user when you render templates.
*** for loops
A for loop repeats some set of operations for each object in a list. So, you have to have a list.

#+BEGIN_SRC jinja
{% for blog_post in my_list_of_blog_posts %}
  {{ blog_post.post_text }}
{% endfor %}
#+END_SRC

This means to take the first object in my_list_of_blog_posts, and then do everything "inside" the for loop, with ~blog_post~ being that object. Then, go back to the top and repeat, with ~blog_post~ being the *second* object, and so on.
*** What goes in a view vs. a template?
Django structures stuff according to a paradigm called "model-view-template" (MVT). (Other frameworks work similarly but with different names for the different layers.) This division allocates responsibilities as follows:

- Models: the one "source of truth" for how your data should look and behave.
- Views: responsible for actually responding to user requests and translating that into access to models
- Templates: responsible for presenting the output of the views to a user -- this is the "user experience" part.

What goes in which area is a little bit inexact, and reasonable people can disagree, but most people agree with this vague division.

In these particular exercises, the question of where to put the logic that fetches a blog post's comments could be argued either way. You could put it in the template if you think it's a user interface concern how, if, and whether we display comment information. You could put it in the view if you believe that the main concern here is deciding what data to fetch and how to fetch it. In particular, there are some optimizations you can make if you do the fetching all at once in the view rather than post-by-post in the template. It's also a little surprising if you "accidentally" do database queries in the template, because that might eventually impact performance.

FIXME: The above isn't 100% since fetching in the view is probably correct but it's an optimization that doesn't change how the template looks.

About templates in particular, a good rule of thumb is that you've done a good job dividing stuff between your view and your template if you only have to change your template when someone comes to you and says "Actually, the way we're presenting this information isn't what we want. Can we present it this other way?" (But don't get dogmatic! It's always better to be inconsistent than to have unmaintainable code.)
*** Limits of Django templates
Because of the above division, Django templates are written to be *very* limited. You can't even call functions in a template! There's one exception to this: if you have a "method" like ~obj.foo()~, you can write that in a Django template like ~{{ obj.foo }}~, without the parentheses. Yes, this is crazy, but you might need this to access all the comments for a blog post.
*** Length of a list
In regular Python, you would write ~len(my_list)~. In Django templates, you have to write ~{{ my_list|length }}~.

Different languages and environments have different names for this operation -- ~size~, ~count~, ~length~ are all common. Python's a little unique in that it writes ~len(my_list)~ instead of ~my_list.len~. (This is for historical reasons.)
*** Formatting/style
Software engineers *love* to argue about formatting of source code, often to the detriment of actual engineering. I try to stay limber about these sorts of things and I'd encourage you to as well, at least until you originate a project from scratch and can bend people to your will.

Some "meta-guidelines":

- When in Rome, do as the Romans do. Your code should look like code in the same file, or the same project, or code that works with the same framework.
- Languages often define standards for how code should look. In Python, the standard to follow is PEP8. I don't know of a standard for Django templates.
- Break the rules if it makes something easier to read.

Some generic guidelines:

- When lines get too long, break them into several. "Too long" varies by taste; I prefer about 120 characters, but a lot of people still prefer 80 characters.
- When you find yourself repeating something, turn it into a variable or a function.
- Naming things is really hard, but really important.
- Similar things should go together. Different things should go apart. (This might mean separate functions, separate parts of a file, separate files, or separate projects.)
** CSS pt 1
Reading for this week:
https://www.girldevelopit.com/materials/html-intro, specifically class 2

https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Color (don't feel obligated to read the rest of the tutorial, or earlier parts)

https://docs.djangoproject.com/en/1.8/intro/tutorial06/, use as a reference to try to get your CSS into a page

http://media.mediatemple.netdna-cdn.com/wp-content/uploads/images/css3-cheat-sheet/css3-cheat-sheet.pdf list of a whole bunch of different CSS properties; see also https://developer.mozilla.org/en-US/docs/Web/CSS/Reference which is linked to good references for them
*** Overview
CSS is yet another language that we use to apply style to our pages.

In CSS, you write *rules* which apply to your HTML elements. Each rule changes some properties of the elements in question.

#+BEGIN_SRC html
  <html>
    <body>
      <p>This is the first paragraph</p>
      <ul>
        <li>This is item 1</li>
        <li class="special-list-item">This is item 2</li>
        <li class="special-list-item warning">This is <em>item</em> 3</li>
      </ul>
      <p class="final-paragraph">This is another paragraph</p>
    </body>
  </html>
#+END_SRC

#+BEGIN_SRC css
  p {
    color: #f00;
  }

  .final-paragraph {
    color: #ff0;
    background-color: #000;
  }

  li {
    text-decoration: underline;
  }

  .special-list-item {
    text-transform: uppercase;
  }

  .warning {
    background-color: #f00;
  }

  em {
    font-style: italic;
  }
#+END_SRC

This will cause the first paragraph to have red text, and the last to have yellow text with a black background; list items will be underlined, and the second and third will be written in uppercase, and the third will have a red background; the last word "item" will be italicized.

CSS rules apply to multiple elements, and each element can be affected by multiple rules. When this happens, there is a "cascade", which merges properties according to certain rules (which we'll get to later; for now, let's just say later rules override earlier rules).

HTML elements can have "classes" and "ids" that serve no purpose other than to "hook up" to CSS rules. Accordingly, you can use whatever classes and IDs you like. Stylistically, classes and IDs are often separated with hyphens (which isn't even possible in Python).

To debug CSS rules, you can use your browser's development tools. For example, you can right click on an element and select "Inspect element" to look at what the browser believes the HTML is and what rules apply to it.

Generally, we try to maintain a consistent "look and feel" throughout our site, which includes consistent templates and style; we'll touch more on that in future weeks.
** CSS part 2
*** Template inheritance
The exercises encouraged you to add some things to every page. Of course, that's bad practice (because it's tedious to add and to change; Don't Repeat Yourself). Django templates include a powerful feature called "template inheritance" that lets us get rid of this. The basic idea is that you set up a "framework" template, and the templates for individual views "inherit" the framework from that template.

The Django docs are pretty good for this, so here's the link: https://docs.djangoproject.com/en/1.8/ref/templates/language/#template-inheritance
*** A warning
I'm not really specialized in front-end stuff, although I can get by in a pinch. I'm not 100% up to date on the hot trends or the cool new things, and I'm not exactly sure what to point you at. Here's the lay of the land re: CSS.

- The Bad Old Days: Layout was done using ~<table>~ s. Styling was done directly as HTML attributes (~<font>~ tags, ~<table bgcolor="#fff">~, etc.). Exceeding these constraints meant going to Flash. IE <5. About these techniques and this worldview I know almost nothing. I know at least one web developer who "got out" before this period ended.

- Antiquity. Introduction of CSS: separation of content from style. Front-end web development means knowing stupid CSS tricks that you could use to make a design work in IE as well as other browsers. See http://www.quirksmode.org/css/csshacks.html. IE 5-6.

- Middle Ages. CSS coming into its own. CSS gradients, rounded corners. IE 7-8.

- The Renaissance. Chrome, Firefox, and Webkit rule the skies, and seize on this position to introduce of a stream of new technologies to enhance the web experience: HTML5. LocalStorage, Canvas, WebGL, Geolocation. IE 9-10, starting to become a real browser.

- The future. Responsive design/mobile browsers. The death of Flash. Flexbox?
*** Block and Inline
Already we've seen two different kinds of elements: ~<p>~ elements, which cause a "break" in the flow of text, and e.g. ~<i>~ which just wraps around some element of text. These two kinds of elements are referred to in the specifications as "block" and "inline" elements. Block elements tend to break text, and inline elements don't. Inline elements can be broken across several lines if they're too long. Text itself is generally inline, although it may be included in a block element. One common surprise is that the ~<img>~ element is also inline by default.

Among other behaviors, inline elements cannot have dimensions set for them using the ~width~ or ~height~ property -- they take their size from the size of their enclosed content. Block elements can; their default ~width~ and ~height~ are ~auto~, which means they take up as much width as they can, and only as much height as they need for their contents.

All of this behavior is controlled by the CSS property ~display:~. Changing an element's ~display~ will have numerous effects, some of which you may not anticipate. The most common values are:

- ~display: none;~ -- completely hides the element
- ~display: inline;~ -- covered above
- ~display: block;~ -- covered above
- ~display: list-item;~
- ~display: inline-block;~ -- like ~display: inline;~, but supporting ~block~ properties like ~width~ and ~height~, and can't be split across several lines
*** <div> and <span>
There are two HTML elements that are extremely important because they don't do anything. Those elements are called ~<div>~ and ~<span>~. Unlike almost every other HTML element, they have no built-in styling or any semantic meaning whatsoever. In order to style them, you use classes and IDs like we saw last session. The only semantics associated with them is that ~<div>~ is, by default, ~display: block;~, and ~<span>~ is, by default, ~display: inline;~.
*** Floats
So far we've just been dropping blobs of stuff in a vertical line down the page. If we want to do fancy stuff like lay things out side by side, we need more techniques. The first one was designed for a specialized use case -- where you have some image that you want to "inset" into some text -- but then that turned out to be the best way to get stuff done in the real world. See https://developer.mozilla.org/en-US/docs/Web/CSS/float.

"Floating" an element has a few interesting consequences:

- it is "removed from normal flow", so wherever it was, now it's like it wasn't there
- it gets placed relative to its "containing box", which is a containing element that is either floating or positioned (see https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context)
- if the element is ~width: auto;~ it will "shrink" to just big enough to contain its content
- other floating elements will get pushed up against it... even if they are in a totally different part of the HTML (because they're removed from normal flow).

The "antidote" to floating is to specify the ~clear: both;~ property. Putting this on an element means it will be pushed down until it can fit without leaving room for the floated element.
*** Positioning
Floating is super useful because you can stack up elements in order without specifying their positions in any way. However, there are a couple of cases where it is useful to specify them more exactly. For that, you can use the ~position~ property. When you use ~position:~, you also have to use ~top~, ~left~, ~bottom~, and ~right~ to specify position exactly.

https://developer.mozilla.org/en-US/docs/Web/CSS/position
*** CSS/HTML Style
**** Semantics vs. presentation
One important idea in modern web design is that HTML elements should dictate what your content is, and how it relates to other content in your file, and not cover styling at all. For example, you shouldn't use ~<p>~ elements to insert spacing -- you should use them to signal that some bit of text is a paragraph (instead of a headline or an element in some list).

Similarly, ~<i>~, ~<b>~, and ~<u>~ (which you might have learned as the elements for italic, bold, and underlined, respectively) don't have semantic meaning of their own, so they're considered deprecated. Instead consider ~<em>~ (emphasized) and ~<strong>~.

This is really the only reason to use any particular HTML element. After all, with CSS, you can make anything look like anything.
**** Measurements
For a while some people were saying you should use percentages and ~em~ instead of ~px~ to measure stuff, but I forget why, so maybe do that?
**** Different window sizes
Be sure your website looks OK if you resize your browser window. Not everyone uses their browser full-screen.
**** Accessibility
Some users of your web page aren't going to be looking at it -- they'll be hearing it through screen readers and tabbing through it with keyboards. To the extent possible, we should support those users too.

http://www.w3.org/WAI/intro/accessibility.php

http://www.w3.org/WAI/intro/wcag.php

Most people and companies don't take this as seriously as they should.
*** More resources
http://caniuse.com/ -- see e.g. http://caniuse.com/#feat=webgl

http://www.w3fools.com/ and associated links
** CSS part 3: random notes
*** Measurements
CSS offers both "absolute" (like px) and "relative" (like %, em) measurements. Relative measurements are computed relative to their parents or containers.
*** Grids
*** Homework
- One view which renders a dollhouse
- Dollhouse (i.e., what background? what elements?) actually fetched from the database
- Dollhouse actually rendered visually -- some background, some elements placed correctly
** Forms and HTTP
I'm not going to cover much about the HTML necessary to write forms, or how to use the Django forms library -- I figure you can probably learn that on your own. But of course, sing out if you have problems.

The thrust of this lesson is about HTTP requests, which are the underlying mechanism for basically everything we've done so far and are especially important in handling forms. This is because the Django forms library is sort of old-fashioned -- modern web applications don't usually submit and refresh the entire page any more, but they still use HTML forms and HTTP requests.
*** Reading
Read one of these two. I think the first one is "better" (it's certainly shorter) but it may be less accessible.
http://www.jmarshall.com/easy/http/
http://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html

This provides some amount of overview of how forms work in HTML and HTTP, but with an emphasis on using them in Django. There's one point about forms in Django that you will need to know in order to get them working, and that's the csrf_token thing that they do in the example. Stop at "More about Django Form classes".
https://docs.djangoproject.com/en/1.8/topics/forms/

Wikipedia's got some sort of light but dense information about forms themselves:

https://en.wikipedia.org/wiki/Form_%28HTML%29

Also, about HTTP request methods:

https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
*** HTTP
A web application is a program that responds to "requests" from web browsers -- these requests are made using a protocol called HTTP. In HTTP, each request has a "method" (sometimes called a verb).

In Django, you can access information about the request by using the "request" variable that your view takes. For example, you can get the method being used by examining ~request.method~. The URL of the request is also available, but it's broken up and parsed. In a URL like http://localhost:8080/blog/index?month=December&author=Ethan, the parts we usually care about are the *path* (~/blog/index~, which is available as ~request.path~) and any *query arguments* (~month=December&author=Ethan~). Note that a request can have the same parameter multiple times, as in http://localhost:8080/blog/index?author=Rick&author=Ethan. What this "means" is up to the application to decide.

The most common and important kind of request is the kind that the web browser makes when it goes to a particular URL. In these requests, the web browser requests the contents of that URL. These requests are called "GET requests" because they use the GET method.

In a GET request, Django provides access to the query parameters as ~request.GET~. So, in the above example, you could do ~request.GET["month"]~ to get ~December~. These parameters are always strings. If you need them to be something else, you'll need to convert them. (See https://docs.djangoproject.com/en/1.8/ref/request-response/#django.http.QueryDict for more.)

HTML forms (which you may have seen before) are often submitted to web applications using the POST method. The POST method is used to send data to the web application. There are several other methods, but web browsers typically don't support them directly, so we'll skip them for now. In a POST request, parameters are accessed using ~request.POST~, which behaves the same as ~request.GET~.

(You may have encountered the HTML attribute ~method~ before. ~method~ goes on ~<form>~ elements and you can have the method ~GET~ or ~POST~. This is what that's about.)

The difference between ~GET~ and ~POST~ is that when you use ~GET~ in your application, you're saying that the request is /safe/. Safe requests shouldn't change the state of the application. RFC 7231 explains that a request is safe "if their defined semantics are essentially read-only".

A request that updates a blog post would not be considered "safe", and should use POST. A request that searches for a blog post probably is "safe" and thus can use GET.

HTTP requests contain a lot of information, and a web browser makes lots of them in normal usage.
*** Demo
Make a GET request with a form as well as a POST request. Log both in Wireshark. Show what they look like.

Requests that contain uploaded files are a tiny bit different from those we saw today, but we won't cover exactly how they look on the wire.
** Functions
A function is a "piece" of a program, or a mini-program. Like a program, a function is a series of instructions. A function is those instructions packaged up and made easy to re-use.

A well-designed function serves as an abstraction -- something that lets you accomplish a task without 100% understanding what's going on inside.

Functions are just one of several mechanisms available to make code packaged up and easy to re-use. We've already seen modules; modules are also sort of like mini-programs.

To define a function, you write:

#+begin_src python
def my_function_name(some_argument):
    """A docstring. This string describes the function."""

    ... here is where you would put the stuff you want to do ...

    return something  # if it makes sense for your function
#+end_src

To use it, you write:

#+begin_src python
my_function_name(123)
#+end_src

#+begin_src python
result = my_function_name(123)
#+end_src
*** Recursion
Week 1: 1 pair of mature rabbits
Week 2: 1 pair of mature rabbits + 1 pair of immature
Week 3: 2 pair of mature rabbits + 1 pair of immature
Week 4: 3 pair of mature rabbits + 2 pair of immature
Week 5: 5 pair of mature rabbits + 3 pair of immature
Week 6: 8 pair of mature rabbits + 5 pair
Week 7: 13 pair of mature + 8 pair
*** Fibonacci series
F_0 = 0
F_1 = 1
F_n = F_{n-1} + F_{n-2}

fib(100) = 1 * fib(99) + 1 * fib(98)
fib(99) = fib(98) + fib(97)
fib(100) = 2 * fib(98) + 1 * fib(97)
fib(98) = fib(97) + fib(96)
fib(100) = 3 * fib(97) + 2 * fib(96)
fib(97) = fib(96) + fib(95)
fib(100) = 5 * fib(96) + 3 * fib(95)
fib(96) = fib(95) + fib(94)
fib(100) = 8 * fib(95) + 5 * fib(94)
*** conversion to loop

*** Homework
#+begin_src python
  def factorial(n):
      """
      Factorial function.

      >>> fact(5)
      120
      >>> fact(6)
      720
      """
      pass
#+end_src

#+begin_src python
  def reverse_rec(s):
      """
      Reverse a string, recursively.
      """
      pass
#+end_src

#+begin_src python
  def list_mult(l, n):
      """
      Repeat the list l as many times as n.

      >>> list_mult([1, 2, 3], 2)
      [1, 2, 3, 1, 2, 3]
      >>> list_mult([1, 2], 3)
      [1, 2, 1, 2, 1, 2]
      """
      pass
#+end_src

#+begin_src python
  def flatten(lst):
      """Take a deeply nested list and flatten it to a single level.

      >>> flatten([1, 2, 3])
      [1, 2, 3]
      >>> flatten([[1], [2, 3], [4, 5, 6]])
      [1, 2, 3, 4, 5, 6]
      >>> flatten([1, [2, 3], [[4], [5, [6]]]])
      [1, 2, 3, 4, 5, 6]
      """
      pass
#+end_src

#+begin_src python
  def flatten_dict(d):
      """Flatten a nested dictionary, using a period to separate nested keys.

      Only works if nested keys are all strings.

      >>> flatten_dict({'a': 1, 'b': {'foo': 2, 'bar': 3})
      {'a': 1, 'b.foo': 2, 'b.bar': 3}
      """
      pass
#+end_src
** Complexity theory
Complexity theory is a way to compare the efficiency of algorithms. Algorithms can't be compared directly; you end up having to compare implementations. Worse yet, those implementations also include implementations of languages, of compilers, and of computers themselves. Complexity theory is a way to get around this -- to abstract out the essence of the algorithm so it can be looked at directly.

[N.B. Recall that algorithms are just sets of steps that you can follow to solve a problem, i.e. they're one step short of a program. But frequently it's easier to examine the algorithm when it's embodied in a program. Just be careful that you understand the costs of every operation that the programming language offers.]

Frequently we want to estimate the cost of an algorithm, i.e. how many operations it takes to run, or how much memory it uses. Usually we'll estimate this cost using big-O notation (and its dorky relatives, big-theta and big-omega notation, which are a little academic even for academics). If an algorithm takes e.g. 5 n^2 + 3 n + 12 operations, we say it is "big O of n^2" -- that is, we take the biggest function of n, throw away everything else, and discard any constant factors. (Constant factors tend to be controlled by e.g. speed of hardware, programming language, and other non-algorithmy things that are nevertheless very important.) Sometimes it's enough to just estimate "number of operations" -- sometimes we want to compare against something else, such as "number of times we have to read from disk", or "number of network operations", or some other number of specific operations.

Big-O notation tends to give an "upper bound" to the runtime of an algorithm, which is usually good enough for our purposes, but if you want, you can use big-omega to specify a "lower bound" or big-theta which is supposed to be a more exact bound (both upper and lower).

Sometimes people talk about worst-case, best-case or average-case complexity.

Sometimes you need two variables to express the complexity of an algorithm. Lots of graph theory algorithms require O(V+E) to run. (We'll talk more about graph theory later. It's not graphs in the sense of pictures of mathematical functions.)

Remember that when you're implementing an algorithm, runtime is not the only consideration! Readability and maintainability usually trump runtime, because you usually only have one or two "hot spots" which need to go really fast (if any).
*** Example
http://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html test yourself problem 2
*** Underlying data structures and operations
In order to really do big-O notation justice, you have to understand some of how the computer's memory works, because some operations are hidden by the way the programming language works.

Computer memory is random-access. That means you can go to any place in memory with the same speed. It's almost like each byte of memory in RAM has its own telephone number, and all telephone numbers take the same amount of time to dial, so any byte is equally fast. [Note: this is a gross oversimplification that is nevertheless assumed in complexity theory.]

A single Python variable, like say a variable that contains an int, is just 4 bytes of memory. Thus, to read a variable just takes four phone calls (or, we can say that it just takes one phone call, since we're disregarding coefficients (and also because a 32-bit computer reads memory 4 bytes at a time -- this is called a "machine word")).

Simple mathematical operations are also counted as one single operation. [This is part of the same gross oversimplification.] We say that such an operation is constant-time or O(1).

So how fast is this algorithm?

#+begin_src python
def foo(a, b):
    x = 0
    for i in range(b):
        x += a

    return x
#+end_src

A Python "list" is just a big batch of contiguous memory. That means that if the first element of the list is at phone number 1, the second element will be at phone number 2, and the third at phone number 3, and so on. If you know which index you want, you can just dial it directly -- so this is also one operation.

So what's the asymptotic runtime of this program?

#+begin_src python
def elem(x, lst):
    i = 0
    while i < len(lst):
        if x == lst[i]:
            return True
        i += 1
    return False
#+end_src

What about this one?

#+begin_src python
def foo2(x, l):
    i = len(l)    # len(l) ~= O(1)
    while i > 0:
        l[i] = l[i-1]
        i -= 1
    l[0] = x
#+end_src

#+begin_src python
def foo3(x, l):
    i = len(l)
    while i > 0:
        foo2(x, l)
        i -= 1
#+end_src

Lists also store their size. If you add an element to a list that doesn't have space for it, it will have to find a bigger batch of memory and copy everything over. (What's the runtime of that?)

Because this is expensive, we use a trick. Every time we increase the size of the list, we double the size. This way, we get to insert O(n) elements. This means that adding to the end of a list is, on average, O(1). This is called *amortized* constant time -- it's not really constant, but it's constant enough.

How are dictionaries implemented? Basically, they're like lists, except that whatever you use as your key has to be turned into an index. This is called hashing and it's kind of magical. However, the good news is that lookups in a dictionary are constant-time (relative to the size of the dictionary) because you just have to hash the key and then look at that index.

In a homework a few weeks ago, you implemented a "check if an element is in a list" operation. The runtime of that operation is O(n). In general, you can't do better, but if you know your list is sorted, you can. How? You'll probably come up with an algorithm called binary search.

List:
-1, 2,  5,  9,   15, 16,  18, 19, 20,  25, 35

Find: 6.
#+begin_src python
  def flatten(lst):
      new = []
      for i in lst:
          if not isinstance(i, list):
              new.append(i)
          else:
              new.extend(flatten(i))

      return new
#+end_src

*** Homework
Implement the binary search algorithm. This is kind of naturally recursive too. What is its runtime?

Read https://en.wikipedia.org/wiki/Tower_of_Hanoi. Come up with an algorithm to solve it. Implement it. How fast does it run?
** Object-oriented programming
Object-oriented programming is a paradigm or methodology that is found in a lot of modern programming languges. It's one way to conceptually decompose systems and write abstractions. It's not the only way, which is why Python supports a lot of other ways, but it's still an important way.
*** Abstractions
When you write a function, you're writing an abstraction -- you're defining a new kind of operation which is made up of smaller, more basic operations. Knowing how to use the new operation liberates you from having to use the underlying smaller operations.

Programming is very very often about abstractions in one form or another, and choosing good ones to write and writing them well can be very challenging. (The exercises you guys have been doing are all essentially about implementing an abstraction that someone else chose for you.)
*** Classes
When writing functions, the abstraction you're creating is one of behavior. (This function does that.) In object-oriented programming, your abstraction bundles both behavior and state. This is kind of an abstract idea, so here's an example.

Let's say we want to write a program that models some users' reading habits. We might want to do stuff like this:

#+begin_src python
  alexs_book = {'title': "The Wise Man's Fear",
                'current_page': 10}

  my_kindle = {'current_book': "Pride and Prejudice",
               'account': 'ethan@example.com',
               'books': [
                   {'title': "Pride and Prejudice",
                    'current_page': 213},
                   {'title': "So You Want To Be A Wizard",
                    'current_page': 1},
                   {'title': "Furies of Calderon",
                    'current_page': 92}
               ]
  }

  def turn_book_page(book):
      book['current_page'] += 1

  def turn_kindle_page(kindle):
      # FIXME: This code has bugs.
      current_book = kindle['current_book']
      turn_book_page(kindle['books'][current_book])

#+end_src

We've defined some kinds of ad-hoc data structures here that correspond to books and book-like devices. These data structures correspond to *state* -- some kind of mutable information about current reality. A Kindle is more complicated than a book, so it has more (and different) state.

We've also introduced some operations to manipulate these data structures. However, you have to know which data structure you have when you want to use the operation. If you write a program that works for both books AND Kindles, you have a problem. You'd have to be sure never to call a Kindle function on a book, and vice versa, or else your program would break messily.

To make it a little easier, maybe you could write a function like this:

#+begin_src python
  def turn_page(book_or_kindle):
      # What goes here???
      pass
#+end_src

But in order to reliably determine what thing you have, you'd have to add another field to store that it's a book or a Kindle. The whole thing gets very messy -- dicts aren't required to always have the same keys, but books probably do.

Instead we define something called a *class*, which represents the underlying model. We use these to stamp out *objects*, which resemble the class. That might look like this:

#+begin_src python
  class Book(object):
      def __init__(self, title, current_page):
          self.title = title
          self.current_page = current_page

      def turn_page(self):
          self.current_page += 1

  class Kindle(object):
      def __init__(self, account, current_book, books):
          self.account = account
          self.current_book = current_book
          self.books = books

      def turn_page(self):
          self.books[self.current_book].turn_page()

  alexs_book = Book("The Wise Man's Fear", 10)

  my_kindle = Kindle('ethan@example.com', "Pride and Prejudice", [
      Book("Pride and Prejudice", 213),
      Book("So You Want To Be A Wizard", 1),
      Book("Furies of Calderon", 92)
      ])

  my_kindle.turn_page()
#+end_src

This code says to define two classes, which have certain data and
support certain operations. Then, I *instantiate* those classes, which
means to create an object, or instance, of those classes. When I do
this, the ~__init__~ function for those classes is called (this is
called the *constructor*). Both classes also have other operations,
which are called *methods* (a method is just a function defined on a
class).

Both classes have a common ~turn_page~ method. That means I can always call ~turn_page~ without having to care about what object it is.

To access data in an object, you use the ~object.attribute~ syntax we've seen. To call a method on the object, you write ~object.method()~.

To define methods, define a function inside the body of a ~class~ statement. These functions will take an additional ~self~ argument, which refers to the object itself, and can access its data or its methods directly.

The details of this process vary from language to language. Some, like
Java, require you to formally create an *interface* saying what
operations books and booklike things are expected to perform, and what
operations are available to the person using the class or object
(to try to limit misuse). But Python tends to be a bit more permissive here because of the culture of "We're all adults here". Look up "duck typing" for more about this.
*** Inheritance
Sometimes you want to define some new class. It's a lot like a more specialized version of an existing class, and you don't want to copy all the existing code (DRY; because copying is bad). To do this, we define a *subclass*.

#+begin_src python
  class Paperwhite(Kindle):
      def __init__(self, *args, **kwargs):
          super(Paperwhite, self).__init__(*args, **kwargs)
          self.is_backlight_on = False

      def turn_on_backlight(self):
          self.is_backlight_on = True

  moms_paperwhite = Paperwhite('donna@example.com', .....)
  moms_paperwhite.turn_page()
  moms_paperwhite.turn_on_backlight()
#+end_src

[The ~super~ function might behave a little bit differently in Python 3.]

Here, we are defining a new kind of Kindle. A Paperwhite is
automatically a Kindle, although not all Kindles are
Paperwhites. Paperwhites are a kind of Kindle that has a
backlight. Because Paperwhites *inherit* from Kindles, all Kindle
operations are still available in Paperwhites. (So you can still do
~turn_page~ on one.) It also offers some new functionality (a
~turn_on_backlight~ call).

The constructor for the Paperwhite needs to set up the Paperwhite, which means it needs to set up the Kindle part of the Paperwhite. To do this, it calls its *superclass* using the ~super()~ call.

The constructor for the Paperwhite does this neat trick with ~*args~ and ~**kwargs~. What this is saying is, whatever arguments you give me will be collected, whether they are positional (~*args~) or named (~**kwargs~). Then, when calling the superclass, it can un-collect them in the same way.
*** Design
There's a lot of material out there about "proper" object-oriented design and programming. Some essentials:

- What are the subjects of discourse in the domain? What are their relationships? What operations do they support?

- A constructor should ensure that the object is in a coherent state, and operations should always leave the object in a coherent state.

- A subclass should follow an is-a relationship, and never a has-a relationship. A Paperwhite is-a Kindle. (Although some cultures, like that of Java and Go, discourage inheritance and prefer the use of has-a relationships and delegation.)

- If you ever find yourself doing something like

#+begin_src python
  if foo.type == 'book':   # or isinstance(foo, Book)
      # do something with books...
      pass
  elif foo.type == 'kindle':
      # do something with kindles...
      pass
#+end_src

... you should restructure it as a common method.
*** Differences with Django models
Django models have field definitions which have a clear type.

Django models have clear relationships with other objects.
*** TODO exercises for *args, **kwargs
** Modules
The ~import~ statement introduces a "module", which is an object that represents the code loaded from some other file.

Let's say we put this code in a file called file_loader.py:

#+begin_src python
class FileLoader(object):
    pass

def load_file(filename):
    pass
#+end_src

And in another file (let's call it main.py) we put this code:

#+begin_src python
import file_loader
#+end_src

... we create a variable ~file_loader~ which represents a "module". If we print ~file_loader~, it will show us that it is a module and what file the module was loaded from. We can henceforth access the ~FileLoader~ class and the ~load_file~ function using the syntax ~file_loader.FileLoader~ and ~file_loader.load_file~. If we get tired of typing these things, we can also make them available directly using:

#+begin_src python
from file_loader import FileLoader, load_file
#+end_src

Now we can just use ~FileLoader~ and ~load_file~.

If you have lots of modules together, you can group them in a "package". A package is just a directory with a ~__init__.py~ file in it. See https://docs.python.org/3.5/tutorial/modules.html#packages for more info.
** Return of the Django
*** Review
Django, on startup, examines your site to discover its main application. Then it *imports* that application's settings file and URLs file (i.e. modules you wrote). Then it looks at your settings to identify the other applications in your site and imports all their models. Finally, it begins listening for requests from a browser. When a request comes in, it uses the rules from ~urls.py~ to decide what view will handle it.

Defining a model in Django is done by defining a subclass of ~django.db.models.Model~. Unlike normal Python classes, models tend to have explicit lists of fields and types. Like normal Python classes, they can have their own methods.

Defining a view in Django is done by defining a function (or callable object). This function must take at least one argument, which is a ~Request~ object, but it can take more if it wants to use parts of the URL. This function must also return a ~Response~ object. Normally a ~Response~ is produced by rendering a template, but it doesn't have to be. It's traditional to put views in a ~views.py~ module, but they don't have to be.

Django forms can be defined by defining a subclass of ~django.forms.Form~. Like models, you define all fields that your form needs and what type they are. A form needs access to a ~POST~ or ~GET~ from a real ~Request~ and it will tell you if the data was valid.

Defining a template is done by putting a file in a templates directory. Templates are usually kept in files like ~templates/appname/viewname.html~. Templates use the Django template format. To put a variable in a template, use ~{{ variable }}~. You can do some processing of variables using filters like ~{{ x | first }}~. You also get some other commands like ~{% if %}~ and ~{% for %}~. Templates can *extend* other templates. The "parent template" defines blocks and structure, and the child template fills in those parts.

To add CSS (or eventually, JavaScript) to a page, you'll use the ~staticfiles~ application. In templates, you'll use the ~{% load staticfiles %}~ command to get access to it, and ~{% static "appname/file.css" %}~ to create a link to the file.

CSS is a set of rules that change the appearance of HTML elements. Each rule has a selector that determines what elements it will apply to:

- ~foo~ applies to any HTML element with the tag ~<foo>~
- ~.foo~ applies to any HTML element with ~foo~ among its ~class~ attribute. Note that this kind of class is not like an OOP class!
- ~#foo~ applies to any HTML element with ~foo~ as its ID. IDs are supposed to be globally unique, and classes need not be.
- If ~X~ is a selector, and ~Y~ is a selector, the selector ~X Y~ matches any element who matches ~Y~ that is inside an element matched by ~X~.
- ~X > Y~ matches any ~Y~ child of a node matching ~X~.
- ~X, Y~ matches any node matching ~X~ or any node matching ~Y~.

A rule also has a bunch of properties, which are written inside braces. A property has a name and a value, e.g. ~color: blue;~. Each property allows different kinds of values. Of particular interest are ~float~ and ~position~ properties, which help you put together more complicated layouts. (Although it seems like the forward-looking thing is to use something called flexbox.)

Git is a system that tracks the content of your code, and thus their changes. It can be hosted on Github for free if you don't mind your code being public. You create a new project using ~git init~, choose what changes to record using ~git add~, and then record them with ~git commit~. Some files (like a Django database or a virtualenv!) shouldn't be tracked, so you can put their names in a file called ~.gitignore~.
*** Class-based views
Because most Django views are pretty similar, there is a mechanism to reduce boilerplate in views. You can define a class which is a subclass of an existing Django built-in view class, and customize it. See https://docs.djangoproject.com/en/1.9/topics/class-based-views/intro/.
** Future topics
Local variables
Dynamic typing
Tuples and how they differ from lists
Why I hate CSS
