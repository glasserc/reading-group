* Reading group
** Modeling
Ground rule: If you don't understand something, ask as soon as possible -- it's probably my fault for not explaining it well. If there's something that it's OK not to understand, I'll say so, so assume that everything I said, I was trying to make you understand, and if I didn't succeed, I would like to know that.

The Django tutorial I linked to isn't super great for beginners -- it's kind of targeted at experienced web developers. The goal for these first few weeks is to get us to a place where we have *something* up and running, so for now, it's OK not to understand all of that document. That said, I would love for people to learn/get practice with reading technical documentation. It's something of an art!

The first part of building a web application in Django is defining the structure of your database, so we're going to spend some time talking about that today.
*** What is a web application?
At it's most fundamental level, a website is basically some HTML and some images. Some of you have probably already studied a little HTML and it's not really that interesting. In particular, it's static. It will keep staying the same until you write new HTML.

A web application is a program that generates HTML when you visit, so that it can be *dynamic*, or have the potential for change. This makes it something that a user can interact with, without having to write HTML themselves.

Django (and most similar software) anticipate that you will want to base your application on some data, and that application can manipulate that data, and that data is what the user sees and interacts with by interacting with your application. So it's: User <-> Application <-> Data.

In order to make it easy for your application to manipulate data, it's stored in a database.
*** What is a database?
A database is another piece of software which is in charge of storing and organizing data[1]. We are going to be using a kind of database called a "relational" database (specifically we're going to start by using SQLite, but most databases that have "SQL" in the name function similarly).

You can think of a relational database as kind of like an Excel workbook. A relational database has "tables", which are like sheets in a workbook. Each table is a collection of rows, each of which has the same set of columns. So you might have a "people" table that looks like this:

| Person  | Number of pets | Signed up date |
| Ethan   |              1 |     2015-05-01 |
| Rita    |              0 |     2015-05-18 |
| Francis |              1 |     2015-05-08 |

And you might have another table that stores hobbies:

| Person  | Hobby        |
| Ethan   | Chiptune     |
| Rita    | British rock |
| Francis | Death metal  |
| Ethan   | Baking       |
| Francis | Kendo        |
| Rick    | Beer         |

If you had this data stored in a relational database, it would be possible to ask it to "put it together" and generate a table like this:

| Person  | Number of pets | Number of hobbies |
| Ethan   |              1 |                 2 |
| Rita    |              0 |                 1 |
| Francis |              1 |                 2 |

"Relational" is a long word so I'll probably use it interchangeably with "SQL" (pronounced "sequel"), even though technically the two things aren't exactly the same.

[1] This is a wild oversimplification, but "database" is a term that gets used a lot in a lot of contexts with subtly different meanings.
*** Modeling
When you're using Django (and probably when you're developing any kind of application), the first thing you do is think about what are the entities that you're going to have in your application, and how they relate to one another. For example, in a hospital management system, you might have patients and doctors and rooms, and patients stay in rooms and doctors visit patients (but doctors don't stay in rooms). Once you have a clear idea of what the entities are, you structure your database to support that. In Django, you write the structure of your database in a file called "models.py". You translate this structure into your actual database using the "python manage.py migrate" command.

In the tutorial, they take the example of a "poll", which they define as being a "question" with a variable number of "answers". ("Variable" meaning that one question might have two answers, and another question might have three answers.)

[Side note: Let's say I created my table to be like this:

| Question text | Publication date | Choice 1 text | Choice 1 votes | Choice 2 text | Choice 2 votes | Choice 3 text | Choice 3 votes |
| What's up?    |       2015-05-01 | Not much      |              0 | The sky       |              0 | Just hacking  | 0              |

In doing this, I'm asserting that EVERY question have exactly 3 choices! Clearly they can't have more choices because there's no where to put them, but it's also true that they can't have less choices because what will I put in the 3rd choice?

In other words, notice that columns are *constant* in a relational model, so if you want to have a variable number of something, you have to turn those somethings into rows somehow.]
*** Demo
Once you have your models set up, you can create Python objects and make them go into the database, and similarly you can get things out of the database as Python objects. This might not be impressive, but it's the same thing your application is going to do when users interact with it.

You can access the database your program created using the "sqlite3" command (which you might have to install using apt-get or yum or something). This part isn't super important because Django mostly insulates you from it, but I thought it might be interesting to see what's going on "underneath the hood", and sometimes this is useful for debugging.

To open your database in sqlite, you can type "sqlite3 db.sqlite3". In sqlite, you can do .tables to show the tables. A table was created for "polls_question" and another for "polls_choice". You can see what the "schema" (table structure) for a table was using e.g. ".schema polls_question". You can also see what is in your database using a SELECT statement.

#+begin_src
sqlite> select * from polls_question;
1|What's new?|2015-05-18 04:33:32.860786
2|Should I go to work today?|2015-05-18 04:34:51.572901

sqlite> .schema polls_choice
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id"));
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

sqlite> select * from polls_choice;
1|Not much|0|1
2|The sky|0|1
3|Just hacking again|0|1
4|Yes|0|2
5|No|0|2
#+end_src

So, we see that each choice has FOUR attributes -- an ID for itself, a text, a count of votes, and the ID of the question to which it is associated.

Note that each choice uses the question ID -- in my example above, I used people's names, but using an ID is more natural. For one thing, it lets people change their names without having to change it in a lot of places, and I don't have to worry about them being spelled slightly wrong. For another, names aren't unique, but IDs are.
*** Many-to-many relationships
The example in the tutorial defines a many-to-one relationship -- one choice belongs with one question, but one question has many choices. This kind of relationship, as well as the even simpler one-to-one relationship, is generally implemented by putting the ID of the related object in the table.

There's another kind of relationship between entities called a many-to-many relationship. The relationship between people and hobbies is a good example. Each person has many hobbies, and each hobby can be associated with many people. Traditionally, this is implemented using a "join table" -- a table that just tracks the IDs of both objects. So you might have:

A "people" table:

| ID | Name    | Number of Pets |
|  1 | Ethan   |              1 |
|  2 | Rita    |              0 |
|  3 | Francis |              2 |

A "hobbies" table:

| ID | Hobby        |
|  1 | Chiptune     |
|  2 | British rock |
|  3 | Death metal  |

The "person-to-hobbies link table":

| Person ID | Hobby ID |
| 1         | 1        |
| 2         | 2        |
| 3         | 3        |
| 3         | 1        |

Django can handle this for you too, but you'll have to read more documentation: https://docs.djangoproject.com/en/1.8/topics/db/examples/many_to_many/.
*** Homework
- Let's start small -- instead of a whole dollhouse, let's just design a schema for a paper doll application. A paper doll has a name (e.g. "Princess" or "Zoe") and some articles of clothing. Each article of clothing has a filename (e.g. "gloves.png") and a location (e.g. arms, torso, legs, head). What should the tables look like?

- Go through the tutorial again and try to create another application in your existing site. Call it "paperdolls". Try to define the models the same way they do in the tutorial. To test them, try going into the shell and create objects the way they did (although using your models instead of the polls one). Post any error you get to the mailing list, along with the contents of your models.py.
** Views pt 1
*** Homework review
Here are my solutions:

**** Solution 1
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    doll = models.ForeignKey(Doll)

    filename = models.CharField(max_length=200)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Doll ID | Filename      | Location |
|  1 |       1 | gloves.png    |        2 |
|  2 |       1 | red-dress.png |        0 |
|  3 |       1 | sandals.png   |        3 |
|  4 |       2 | tiara.png     |        1 |
|  5 |       2 | lab-coat.png  |        0 |

**** Solution 2
#+begin_src python
class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class Doll(models.Model):
    name = models.CharField(max_length=200)
    torso_item = models.ForeignKey(ClothingItem)
    head_item = models.ForeignKey(ClothingItem)
    arms_item = models.ForeignKey(ClothingItem)
    legs_item = models.ForeignKey(ClothingItem)
#+end_src

Dolls table:
| ID | Name     | Torso | Head | Arms | Legs |
|  1 | Princess |     2 | ???  |    1 |    3 |
|  2 | Zoe      |     5 | 4    |  ??? |  ??? |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

**** Solution 3
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class DollWearsClothing(models.Model):
    doll = models.ForeignKey(Doll)
    clothing_item = models.ForeignKey(ClothingItem)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

Doll Wears Clothing table:

| ID | Clothing ID | Doll ID | Location |
|  1 |           1 |       1 |        2 |
|  2 |           2 |       1 |        0 |
|  3 |           3 |       1 |        3 |
|  4 |           4 |       2 |        1 |
|  5 |           5 |       2 |        0 |
|  6 |           3 |       2 |        3 |
*** Syntax
Syntax refers to the structure of a language. In English, the sentence "The dog bit the man" is well-formed according to English syntax. The sentence "The bit dog man the" has invalid syntax. The sentence "The man bit the dog" has valid syntax but questionable semantics. In programming languages, we sometimes use "syntax" as an umbrella term for all the rules of the language that give it sense to the computer, which also include semantics.

Depending on how far you've gotten in the Django tutorials, you've seen lots of different syntax so far:

- =from foo import bar= at the beginning of a bunch of different files
- =class Foo():= for models
- =blah = models.CharField()= for fields in those models
- =def __str__():= when defining models
- =INSTALLED_APPS = (...)= when "activating" models
- ='words'= and sometimes ="words"=
- =def foo():= for views
- =urlpatterns = [...]= when setting up views
- =url(r'...', foo)= when setting up views
- =%= in some views

I'm going to touch on the essentials of the most important parts of the most important ones of these, and mention a few details about some of the others, because the goal is to get us up and running as fast as possible without wearing you down with details that aren't important yet. These are just simplistic summaries!
*** Django settings: variables
In almost any programming language, you can do stuff like this:

#+NAME: print_variables
#+begin_src python :results output
x = 5
print(x)
print(x + 3)

x = 6
print(x)
print(x + 3)
#+end_src

If I run this program, it will show:

#+RESULTS: print_variables
: 5
: 8
: 6
: 9

What's going on is that when Python sees the line =x = 5=, it creates a thing called =x=. Wherever it sees =x=, it checks the last value it got for =x=, which in this case is 5. =x= is called a variable, and you can think of it as like a box in the computer's memory that has some "value" inside of it. When Python then sees the line =x = 6=, it will take the 5 out of the box and put the 6 in.

There are many different kinds of values that we can put into a variable.[1] In the above example, =x= is an integer (in Python, we say =x= is an =int=). You can also have bits of words and sentences in variables: just do =x = 'hello'= or =x = "hello"= (they're equivalent). These bits of text are called "strings" (in Python, we say they are =str=). You can have truth values =True= and =False=, which are called Booleans (in Python, =bool=). You can also have lists, which are written =x = [1, 2, 3]= (in Python these are called =list=\ s, but in other languages they're called arrays or vectors). There's also something called a tuple, which is written =x = (1, 2, 3)=, but for now we're going to say it's the same as a list.

There are a bunch of places where you get to customize how Django does some things. We've already seen that we need to update =INSTALLED_APPS= when we add a new app. =INSTALLED_APPS= is an ordinary variable that Django gives some special meaning to. Most of these variables are written in all uppercase, but some (like =urlpatterns=) aren't, and you just have to know that they're special.

[1] In some languages, each variable has to be "declared" to hold only some types of values. Python isn't like that; instead it uses "dynamic typing", which means that any variable can hold any value, and even change from one type of value to another. This has advantages and disadvantages.
*** def foo(): functions/methods
Any time you see =def foo(...)=, we are defining a function. A function is a part of a program. Like a program, a function has some operands, which are called parameters or arguments, and a result, which is called the "return value". Here's an example:

#+begin_src python
def check_password(password):
    if password == 'stairs_are_history!':
        return True
    elif password == 'swordfish':
        return True
    else:
        return False
#+end_src

Here's how you might use it:

#+begin_src python
user_password = input()
password_correct = check_password(user_password)
if password_correct:
    print("Welcome back!!")
else:
    print("Incorrect password")
#+end_src

So when you see the code =check_password(user_password)=, that's saying "Begin doing the stuff under =def check_password=. Also, when doing those things, the variable =password= is going to have the value that =user_password= does.[2][3]" Then, Python goes through line after line, doing what that line says, until it either gets to the end of the =def= or it hits a =return=. If it hits a =return=, the function immediately ends and the value after the =return= is sent to wherever the =check_password()= line was.

Using a function is a nice way to group some commands together and use them many times in different places. For this reason, Django uses them to represent views.

The syntax for a function is:

#+begin_src python
def FUNCTION_NAME(PARAM1, PARAM2, ....):
    STATEMENT1
    STATEMENT2
    ...
#+end_src

N.B. A function definition ALWAYS has a colon (=:=) after the parameter list, and the statements in the function are ALWAYS "indented" by four spaces. Some of those statements might have their own sub-statements, which might be inset by another four spaces, and so on. The function continues until Python sees a non-blank line that isn't indented by four spaces.[4]

To use the function, you write the name of the function, plus the things you want the function to operate on. Then Python will start doing the various statements, one after the other. If the function is going to return something, you can put a variable in front of it, or use it in another function, or whatever.

As a general rule, using a function looks almost exactly like using an entity or a class, but functions usually have lowercase names and entities and classes have Capitalized names.

You can also define functions inside classes; these are called methods and we'll talk more about them several weeks from now. In the first part of the tutorial, you defined one called =was_published_recently=.

=__str__()= is a special method that is used whenever an object needs to be displayed. We won't dwell on it right now.

[2] Again, it isn't necessary to specify a type for =password=; like any variable, it can take any value.

[3] =password= is what's called a "local" variable; it will disappear as soon as the function is over.

[4] Some of you have been using TABs instead of spaces. In the Python community, this is discouraged -- it should always be 4 spaces. If you're lucky, you can set up your text editor to insert 4 spaces when you press the TAB key. For instance, on =gedit=, I was able to find a thing on the bottom of the window that says "Tab width: 8 spaces"; clicking on it let me set it to 4 spaces and "use spaces instead of tabs".
*** import
In Python, when we want to use models, functions, or variables from another file, we use the =import= command. There are many different ways to import things, none of which we're going to discuss now. If you forget to import something, you'll usually get a =NameError= saying that something wasn't defined.
*** . ("dot")
*** Homework
Go through all the files in your site so far. Find examples of the following:
- functions being used
- stuff being imported
- a list
- a tuple

Press on and try to get to the end of part 3 of the tutorial. Hopefully by now we are starting to see how Django lets us build a web application.
** TODO add to email
Solution 1 is what I expected most of you to come up with. It lets you match clothing with dolls. One nice advantage to this system is that we can have multiple articles of clothing on the same doll in the same place. (So, socks and then sneakers, for example.) Similarly, you can have 0 articles of clothing on a part of the doll. Of course, if your requirements don't need/forbid this, that might be a disadvantage.

Solution 2 is kind of like a straw man, devil's advocate thing. Last week I said this isn't really possible because we don't know what to put in the =???= places. In fact, there is a way -- there's a thing called =NULL= which is like an empty space. Some people say =NULL= [[http://c2.com/cgi/wiki?NullsAndRelationalModel]["violates the relational model"]], which might or might not mean anything, but it certainly can make your life difficult if you expect something to never be =NULL= when in fact it sometimes is. For this reason, all fields in Django are not allowed to be =NULL= (this is also enforced by the database). If you want to change this, you can use the [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#blank][blank]] and [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.Field.null][null]] options in your fields.

Solution 2 doesn't let you have multiple articles in the same place, but it does have one nice advantage which is that it's easy to "share" an article of clothing between two dolls -- you just re-use the ID. In Solution 1, this would require duplicating the filename, which is error-prone. (If you move the filename and forget to update it everywhere, you will have a data consistency problem.)

Solution 3 has the advantages of both solution 1 and solution 2 -- you can share clothing, plus you can have multiple clothing in the same place. But there's something weird in it, which is that the location of the same article of clothing can be different for different dolls.

Any of these solutions might be OK depending on what your requirements are, but I'd probably go with solution 3, but move =location= to the Clothing table, and I'd add a column to the Wear table that specifies order (so that socks always go under sneakers).
** office hours
*** exercise 1: change your index view to say "This is the paper dolls index"
*** exercise 2: make it show your index view when you go to polls/hello
*** exercise 3: create a new view that says "I finished exercise 3!" when you go to /ex3
** urlpattern exercises feedback
- /blog was intentional; the goal was to hammer in the point that the name of the files on-disk don't have to correspond to the names in the URLs.
- In exercise 4, when we want to match any player's name, we can use the dot character ('.') in the pattern to match anything at all.
- You can use the name of a view directly in the site's urlpatterns -- you don't have to include a file if you don't want to. You can just give the path to the view and Django will import it for you. So for example you can write 'polls.views.index'. The last part of the path represents the name of the view; everything else represents the name of the module where to find the view.
- For the last exercise: yes, in fact, you can make this work -- the Drupal CMS is set up like this. Everything is just a "node" and depending on what kind of node you get out of the database, you then do something different with it. Yes, this is kind of backwards, and nobody sane does it. Drupal is written in PHP, so you can safely consider them insane.
** Views pt 2
Outstanding questions: what is this .format() business?

It's a pretty common situation where you want to have a string built from text and variables. Here's the "simple" way to do that in Python:

#+begin_src python
x = 5
y = 10
s = "The sum of " + str(x) + " and " + str(y) + " is " + str(x + y)
#+end_src

Kinda wordy. So most recent languages offer something called "string interpolation", which is a mechanism whereby the language can help "fill in" the string with other bits of text.

Python actually has two string interpolation mechanisms. The tutorial uses this form:

#+begin_src python
x = 5
y = 10
s = "The sum of %s and %s is %s" % (x, y, x+y)
#+end_src

In the exercises, I used this form:

#+begin_src python
x = 5
y = 10
s = "The sum of {} and {} is {}".format(x, y, x+y)
#+end_src

The first format is older, and inspired by older mechanisms like C's ~printf~. The second one is newer and more powerful. For instance, if you forget which one is supposed to be x and which one is supposed to be y, you can do this:

#+begin_src python
x = 5
y = 10
s = "The sum of {x} and {y} is {xplusy}".format(x=x, y=y, xplusy=x+y)
#+end_src

The full details are available in https://docs.python.org/3.5/library/string.html#format-string-syntax.
*** Recap to this point:
We've actually learned a lot of "mini-languages", including SQL, regular expressions and format strings. We're actually going to learn another three or four in the near future -- today's is the Django template system.
*** Templates
So far we've written views that just produce responses. But an actual web page is an enormous blob of HTML, some of which is shared between pages and some of which is completely different. Dumping all of that into your ~views.py~ file would rapidly become unmaintainable.[1] So most web frameworks offer a notion of "templates", which are another mini-language that make it easier to generate HTML.

Here's a template (let's pretend we saved it as ~polls/some-template.html~:

#+begin_src jinja
Hello, {{ thing }}!
#+end_src

In Django, the usual way to use a template is to turn it into an HttpResponse, like this:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

The ~render~ function takes three arguments -- the request, the name of the template, and any arguments for the template. These arguments are sometimes called a /context/. The template can access anything in the context. Together, the above should produce:

#+begin_example
Hello, world!
#+end_example

Templates help institute a division between code and presentation. Typically front-end engineers work on templates (and CSS and JS), and back-end engineers work on code that provides stuff to those templates. We're going to be working a little bit on all of these.

[1] Maintainability refers to the property of software to be maintained, i.e. understood, debugged, updated and changed to do new things or to do them better. Maintainability is a big deal for software engineers. Usually maintainable code beats fast-to-write code, and fast-to-write code usually beats fast-to-run code, but this depends on what section of software you're in.
*** Contexts
A context is just a collection of variables for a template. Like all variables, these variables have a *name* and a *value*. In the example above, we created one variable called "username", whose value was "Ethan". Contexts are usually defined using syntax like:

#+BEGIN_EXAMPLE python
now = timezone.now()
ctx = {"username": "Ethan", "now": now}
#+END_EXAMPLE

This syntax means a "dictionary", which is made up of *keys* (before the colons) and *values* (after the colons).  You can look up the value for a particular key, or look at all values, or all keys.  If you access ~ctx["username"]~, that will produce "Ethan".

A context is a dictionary where all the keys are strings.
*** Template language
**** Default is to output
Most template languages are geared towards producing output. In fact, to produce output, you don't even need to give a command -- you just write text. Anything you write will be copied to the output.

Example:

#+begin_src jinja
This is some text without anything special going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

Produces:

#+begin_example
This is some text without anything special going on.
#+end_example

Note that when you're looking at your template, you're looking at plain text, but the template is being rendered as HTML, which is a bit different. In particular, blank lines in text are just spaces in HTML.
**** You can use variables
To access things from the context, you can write two curly braces, then the name of the thing in the context, and then two curly braces.

Example:

#+begin_src jinja
This is some {{ field }} without anything {{ adjective }} going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "field": "words", "adjective": "unusual", "name": "Ethan"
        })
#+end_src

Produces:

#+begin_example
This is some words without anything unusual going on.
#+end_example

As the example shows, you don't have to use everything in the context. It turns out that in Django's template language, you can try to use variables that *aren't* in the context and they will just silently fail and print nothing. I would encourage you not to rely on this behavior if you can avoid it.

You can also access attributes the same way you do in Python. So let's say you have some object in your context, like this:

#+begin_src python
def my_view(request):
    q = Question(id=1, question_text="What's up?")
    return render(request, "polls/some-template.html", {
        "question": q
        })
#+end_src

You can get the text "What's up" using:

#+BEGIN_EXAMPLE
Please answer the question: {{ q.question_text }}
#+END_EXAMPLE

Of course, you can access attributes of attributes of attributes, more or less the same way you do in Python:

#+BEGIN_EXAMPLE
You chose {{ c.choice_text }} for {{ c.question.question_text }}
#+END_EXAMPLE
**** Conditionals
Sometimes you have two different things you might want to do. For example, if polling has closed on a question, then maybe you don't want to let people vote, but if it hasn't closed yet, then you do.

#+BEGIN_SRC jinja
{% if q.was_published_recently %}
  OK, you can vote on this question.
{% else %}
  Sorry, polling has closed on this question.
{% endif %}
#+END_SRC

This is very similar to if statements in Python, which I think we saw a little bit of already, so I won't dwell on it. As in Python, you can write some (limited expressions) as the "condition". For example, here's how you could check if a choice hadn't received any votes yet.

#+BEGIN_SRC jinja
{% if c.num_votes == 0 %}
  Nobody has voted for this choice yet!
{% endif %}
#+END_SRC

N.B. The ~if~ command in Django templates is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~! Don't confuse the two!
**** Looping
So far we haven't talked much about types, but hopefully you remember that ~[1, 2, 3]~ is a list. If you have a list of things, you can do something with each element. So let's say we have:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "numbers": [1, 1, 2, 3, 5, 8]
        })
#+end_src

And the template:

#+BEGIN_SRC jinja
Do you notice anything about these numbers?

{% for number in numbers %}
  {{ number }} ...
{% endfor %}
#+END_SRC

This will produce:

#+BEGIN_EXAMPLE
Do you notice anything about these numbers?

  1 ...
  1 ...
  2 ...
  3 ...
  5 ...
  8 ...
#+END_EXAMPLE

This structure is called a *loop*. We haven't had to use it in Python, but it exists there and is very similar. Lots of things produce lists or other loop-able structures. How it works is, first ~number~ is set to the first thing in ~numbers~. Then, everything between ~{% for .... %}~ and ~{% endfor %}~ is run. Then, we go back to the top. ~number~ gets set to the *next* thing in ~numbers~, and then everything between ~{% for ... %}~ and ~{% endfor %}~ is run again. And so on, until there's nothing left in ~numbers~.

N.B. The ~for~ command, like the ~if~ command and most other commands in Django templates, is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~.
**** Filters
Certain other operations are allowed using a concept known as a "filter". For example, you can get the length of a list using:

#+BEGIN_SRC jinja
There are {{ numbers|length }} numbers.
#+END_SRC

You can select the first element of a list using:

#+BEGIN_SRC jinja
The first number is {{ numbers|first }}.
#+END_SRC

If you have a string you can convert it to lowercase using:

#+BEGIN_SRC jinja
When I am feeling blue, I sign my name as {{ name|lower }}.
#+END_SRC

There's even a "pluralize" filter that helps apply the rules for English pluralization (use a singular if n = 1, otherwise use plural). This isn't safe for international websites, but it's a useful shortcut otherwise.
#+BEGIN_SRC jinja
Here are your item{{ num_items|pluralize }}:
#+END_SRC

You can chain filters too, so if you want the first letter of a string, converted to lower-case, you can do:

#+BEGIN_SRC jinja
Not everyone's name can begin with {{ name|lower|first }}.
#+END_SRC
**** Summary
Django templates are actually tightly limited in scope. The designers of Django wanted to prevent people writing templates from having the ability to break a site by writing a bad template. However, the operations available in a template are specialized for generating text, so despite the limitations, they are still more useful than writing HTML in Python files.

A complete summary of the "built-in" functionality in the template system is available at https://docs.djangoproject.com/en/1.8/ref/templates/builtins/.
*** Database access
We've already agreed that a web application stores its data in a database, and so Django has to provide some mechanism that our websites can use to get data into and out of our database. We saw some of this in part 1 of the Django tutorial, but now is when we can really apply it. We need objects to give to our templates, and these objects are often going to come from the database, so let's review how we can do that.
**** Retrieving an object
Access to objects in the "database", rather than just a single object, or the model itself, is done through an ~objects~ field. If you have a model called ~Question~ and want to retrieve the one with ID 5, you can do:

#+BEGIN_SRC python
q = Question.objects.get(pk=5)
#+END_SRC
**** All objects
You can get access to all objects using the ~all()~ method:

#+BEGIN_SRC python
qs = Question.objects.all()
#+END_SRC
**** Filters and field lookups
What if you want only some of them? For example, you might want to get all the ~Questions~ that have a ~pub_date~ that is already passed, or you might want to get all the ~Choices~ with no votes. In this case, you add a filter using the ~filter~ method. Some examples:

#+BEGIN_SRC python
now = timezone.now()
qs = Question.objects.filter(pub_date__lte=now)
choices = Choice.objects.filter(votes__exact=0)
#+END_SRC

The parameters to ~filter~ are known as "field lookups". You can add as many as you like in a call to ~filter~. Each one expresses some criteria of the objects you are looking for.  These "lookups" are composed of (1) the field name that you are concerned with, (2) a double underscore (~__~), (3) some comparison you want to make with that field, (4) an equals sign (~=~), and (5) something to compare against. So, in the above, we see ~pub_date__lte=now~; ~pub_date~ is the field, and we are looking for the cases where that is ~lte~ (less than or equal to) whatever we have as ~now~. Similarly, ~votes__exact=0~ means to find all choices where the ~votes~ field is ~exact~ (exactly equal to) the value ~0~.

All fields are the ones we defined as fields in the model. However, if the field you want to use is a foreign key, you have to add a ~_id~ to the field name. So if we want to get all the choices for ~Question~ with ID 5, we write:

#+BEGIN_SRC python
choices = Choice.objects.filter(question_id=5)
#+END_SRC

There's one short-cut with field lookups -- if you don't specify a comparison, it's assumed to be ~exact~. So we can instead write:

#+BEGIN_SRC python
choices = Choice.objects.filter(votes=0)
#+END_SRC

(In fact, this is how the ~pk=5~ example above works too.)
**** Full documentation
A complete reference is available at https://docs.djangoproject.com/en/1.8/topics/db/queries/. Field lookups are also documented more extensively at https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups.
** Comments on the exercises
*** Types of model object
We've seen three different kinds of object:

- Model class. These are usually written in capitals (a.k.a. CamelCase) like ~BlogPost~. Model classes define fields, but don't themselves have those fields, so you can't do ~BlogPost.post_text~.
- An *instance* or object of this model class, like ~BlogPost.objects.get(pk=5)~. These are usually put in variables with lower-case-with-underscores names (a.k.a. snake_case, named for Python). If you have ~blog_post = BlogPost.objects.get(pk=5)~, then you can access its fields using ~blog_post.post_text~.
- There's also a "manager", which is the thing you see at  ~BlogPost.objects~. You go from the model class to the manager, and the manager provides access to the objects.
- There's also another type, which is "list of objects":
~BlogPost.objects.all()~ or ~BlogPost.objects.filter(...)~. If you have a list of blog post objects, each one of them will have those fields, but the list itself won't.

Model classes are like cookie cutters, and instances are like the cookies they've cut out. The model class defines the shape of the objects, and how they get made, but isn't itself one of them.
*** RequestContext
For the purposes of this exercise, we don't really need a ~RequestContext~ -- we could use the simpler ~Context~, which doesn't need access to the request -- but we may as well use the ~RequestContext~ everywhere. It's only actually used in a few cases -- the ~LocaleMiddleware~ tries to guess what language the user speaks, which is used when you use ~{% trans %}~ in a template, and there's a thing called *CSRF* which requires sending something to the user when you render templates.
*** for loops
A for loop repeats some set of operations for each object in a list. So, you have to have a list.

#+BEGIN_SRC jinja
{% for blog_post in my_list_of_blog_posts %}
  {{ blog_post.post_text }}
{% endfor %}
#+END_SRC

This means to take the first object in my_list_of_blog_posts, and then do everything "inside" the for loop, with ~blog_post~ being that object. Then, go back to the top and repeat, with ~blog_post~ being the *second* object, and so on.
*** What goes in a view vs. a template?
Django structures stuff according to a paradigm called "model-view-template" (MVT). (Other frameworks work similarly but with different names for the different layers.) This division allocates responsibilities as follows:

- Models: the one "source of truth" for how your data should look and behave.
- Views: responsible for actually responding to user requests and translating that into access to models
- Templates: responsible for presenting the output of the views to a user -- this is the "user experience" part.

What goes in which area is a little bit inexact, and reasonable people can disagree, but most people agree with this vague division.

In these particular exercises, the question of where to put the logic that fetches a blog post's comments could be argued either way. You could put it in the template if you think it's a user interface concern how, if, and whether we display comment information. You could put it in the view if you believe that the main concern here is deciding what data to fetch and how to fetch it. In particular, there are some optimizations you can make if you do the fetching all at once in the view rather than post-by-post in the template. It's also a little surprising if you "accidentally" do database queries in the template, because that might eventually impact performance.

FIXME: The above isn't 100% since fetching in the view is probably correct but it's an optimization that doesn't change how the template looks.

About templates in particular, a good rule of thumb is that you've done a good job dividing stuff between your view and your template if you only have to change your template when someone comes to you and says "Actually, the way we're presenting this information isn't what we want. Can we present it this other way?" (But don't get dogmatic! It's always better to be inconsistent than to have unmaintainable code.)
*** Limits of Django templates
Because of the above division, Django templates are written to be *very* limited. You can't even call functions in a template! There's one exception to this: if you have a "method" like ~obj.foo()~, you can write that in a Django template like ~{{ obj.foo }}~, without the parentheses. Yes, this is crazy, but you might need this to access all the comments for a blog post.
*** Length of a list
In regular Python, you would write ~len(my_list)~. In Django templates, you have to write ~{{ my_list|length }}~.

Different languages and environments have different names for this operation -- ~size~, ~count~, ~length~ are all common. Python's a little unique in that it writes ~len(my_list)~ instead of ~my_list.len~. (This is for historical reasons.)
*** Formatting/style
Software engineers *love* to argue about formatting of source code, often to the detriment of actual engineering. I try to stay limber about these sorts of things and I'd encourage you to as well, at least until you originate a project from scratch and can bend people to your will.

Some "meta-guidelines":

- When in Rome, do as the Romans do. Your code should look like code in the same file, or the same project, or code that works with the same framework.
- Languages often define standards for how code should look. In Python, the standard to follow is PEP8. I don't know of a standard for Django templates.
- Break the rules if it makes something easier to read.

Some generic guidelines:

- When lines get too long, break them into several. "Too long" varies by taste; I prefer about 120 characters, but a lot of people still prefer 80 characters.
- When you find yourself repeating something, turn it into a variable or a function.
- Naming things is really hard, but really important.
- Similar things should go together. Different things should go apart. (This might mean separate functions, separate parts of a file, separate files, or separate projects.)
** CSS pt 1
Reading for this week:
https://www.girldevelopit.com/materials/html-intro, specifically class 2

https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Color (don't feel obligated to read the rest of the tutorial, or earlier parts)

https://docs.djangoproject.com/en/1.8/intro/tutorial06/, use as a reference to try to get your CSS into a page

http://media.mediatemple.netdna-cdn.com/wp-content/uploads/images/css3-cheat-sheet/css3-cheat-sheet.pdf list of a whole bunch of different CSS properties; see also https://developer.mozilla.org/en-US/docs/Web/CSS/Reference which is linked to good references for them
*** Overview
CSS is yet another language that we use to apply style to our pages.

In CSS, you write *rules* which apply to your HTML elements. Each rule changes some properties of the elements in question.

#+BEGIN_SRC html
  <html>
    <body>
      <p>This is the first paragraph</p>
      <ul>
        <li>This is item 1</li>
        <li class="special-list-item">This is item 2</li>
        <li class="special-list-item warning">This is <em>item</em> 3</li>
      </ul>
      <p class="final-paragraph">This is another paragraph</p>
    </body>
  </html>
#+END_SRC

#+BEGIN_SRC css
  p {
    color: #f00;
  }

  .final-paragraph {
    color: #ff0;
    background-color: #000;
  }

  li {
    text-decoration: underline;
  }

  .special-list-item {
    text-transform: uppercase;
  }

  .warning {
    background-color: #f00;
  }

  em {
    font-style: italic;
  }
#+END_SRC

This will cause the first paragraph to have red text, and the last to have yellow text with a black background; list items will be underlined, and the second and third will be written in uppercase, and the third will have a red background; the last word "item" will be italicized.

CSS rules apply to multiple elements, and each element can be affected by multiple rules. When this happens, there is a "cascade", which merges properties according to certain rules (which we'll get to later; for now, let's just say later rules override earlier rules).

HTML elements can have "classes" and "ids" that serve no purpose other than to "hook up" to CSS rules. Accordingly, you can use whatever classes and IDs you like. Stylistically, classes and IDs are often separated with hyphens (which isn't even possible in Python).

To debug CSS rules, you can use your browser's development tools. For example, you can right click on an element and select "Inspect element" to look at what the browser believes the HTML is and what rules apply to it.

Generally, we try to maintain a consistent "look and feel" throughout our site, which includes consistent templates and style; we'll touch more on that in future weeks.
** CSS part 2
*** Template inheritance
The exercises encouraged you to add some things to every page. Of course, that's bad practice (because it's tedious to add and to change; Don't Repeat Yourself). Django templates include a powerful feature called "template inheritance" that lets us get rid of this. The basic idea is that you set up a "framework" template, and the templates for individual views "inherit" the framework from that template.

The Django docs are pretty good for this, so here's the link: https://docs.djangoproject.com/en/1.8/ref/templates/language/#template-inheritance
*** A warning
I'm not really specialized in front-end stuff, although I can get by in a pinch. I'm not 100% up to date on the hot trends or the cool new things, and I'm not exactly sure what to point you at. Here's the lay of the land re: CSS.

- The Bad Old Days: Layout was done using ~<table>~ s. Styling was done directly as HTML attributes (~<font>~ tags, ~<table bgcolor="#fff">~, etc.). Exceeding these constraints meant going to Flash. IE <5. About these techniques and this worldview I know almost nothing. I know at least one web developer who "got out" before this period ended.

- Antiquity. Introduction of CSS: separation of content from style. Front-end web development means knowing stupid CSS tricks that you could use to make a design work in IE as well as other browsers. See http://www.quirksmode.org/css/csshacks.html. IE 5-6.

- Middle Ages. CSS coming into its own. CSS gradients, rounded corners. IE 7-8.

- The Renaissance. Chrome, Firefox, and Webkit rule the skies, and seize on this position to introduce of a stream of new technologies to enhance the web experience: HTML5. LocalStorage, Canvas, WebGL, Geolocation. IE 9-10, starting to become a real browser.

- The future. Responsive design/mobile browsers. The death of Flash. Flexbox?
*** Block and Inline
Already we've seen two different kinds of elements: ~<p>~ elements, which cause a "break" in the flow of text, and e.g. ~<i>~ which just wraps around some element of text. These two kinds of elements are referred to in the specifications as "block" and "inline" elements. Block elements tend to break text, and inline elements don't. Inline elements can be broken across several lines if they're too long. Text itself is generally inline, although it may be included in a block element. One common surprise is that the ~<img>~ element is also inline by default.

Among other behaviors, inline elements cannot have dimensions set for them using the ~width~ or ~height~ property -- they take their size from the size of their enclosed content. Block elements can; their default ~width~ and ~height~ are ~auto~, which means they take up as much width as they can, and only as much height as they need for their contents.

All of this behavior is controlled by the CSS property ~display:~. Changing an element's ~display~ will have numerous effects, some of which you may not anticipate. The most common values are:

- ~display: none;~ -- completely hides the element
- ~display: inline;~ -- covered above
- ~display: block;~ -- covered above
- ~display: list-item;~
- ~display: inline-block;~ -- like ~display: inline;~, but supporting ~block~ properties like ~width~ and ~height~, and can't be split across several lines
*** <div> and <span>
There are two HTML elements that are extremely important because they don't do anything. Those elements are called ~<div>~ and ~<span>~. Unlike almost every other HTML element, they have no built-in styling or any semantic meaning whatsoever. In order to style them, you use classes and IDs like we saw last session. The only semantics associated with them is that ~<div>~ is, by default, ~display: block;~, and ~<span>~ is, by default, ~display: inline;~.
*** Floats
So far we've just been dropping blobs of stuff in a vertical line down the page. If we want to do fancy stuff like lay things out side by side, we need more techniques. The first one was designed for a specialized use case -- where you have some image that you want to "inset" into some text -- but then that turned out to be the best way to get stuff done in the real world. See https://developer.mozilla.org/en-US/docs/Web/CSS/float.

"Floating" an element has a few interesting consequences:

- it is "removed from normal flow", so wherever it was, now it's like it wasn't there
- it gets placed relative to its "containing box", which is a containing element that is either floating or positioned (see https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context)
- if the element is ~width: auto;~ it will "shrink" to just big enough to contain its content
- other floating elements will get pushed up against it... even if they are in a totally different part of the HTML (because they're removed from normal flow).

The "antidote" to floating is to specify the ~clear: both;~ property. Putting this on an element means it will be pushed down until it can fit without leaving room for the floated element.
*** Positioning
Floating is super useful because you can stack up elements in order without specifying their positions in any way. However, there are a couple of cases where it is useful to specify them more exactly. For that, you can use the ~position~ property. When you use ~position:~, you also have to use ~top~, ~left~, ~bottom~, and ~right~ to specify position exactly.

https://developer.mozilla.org/en-US/docs/Web/CSS/position
*** CSS/HTML Style
**** Semantics vs. presentation
One important idea in modern web design is that HTML elements should dictate what your content is, and how it relates to other content in your file, and not cover styling at all. For example, you shouldn't use ~<p>~ elements to insert spacing -- you should use them to signal that some bit of text is a paragraph (instead of a headline or an element in some list).

Similarly, ~<i>~, ~<b>~, and ~<u>~ (which you might have learned as the elements for italic, bold, and underlined, respectively) don't have semantic meaning of their own, so they're considered deprecated. Instead consider ~<em>~ (emphasized) and ~<strong>~.

This is really the only reason to use any particular HTML element. After all, with CSS, you can make anything look like anything.
**** Measurements
For a while some people were saying you should use percentages and ~em~ instead of ~px~ to measure stuff, but I forget why, so maybe do that?
**** Different window sizes
Be sure your website looks OK if you resize your browser window. Not everyone uses their browser full-screen.
**** Accessibility
Some users of your web page aren't going to be looking at it -- they'll be hearing it through screen readers and tabbing through it with keyboards. To the extent possible, we should support those users too.

http://www.w3.org/WAI/intro/accessibility.php

http://www.w3.org/WAI/intro/wcag.php

Most people and companies don't take this as seriously as they should.
*** More resources
http://caniuse.com/ -- see e.g. http://caniuse.com/#feat=webgl

http://www.w3fools.com/ and associated links
** CSS part 3: random notes
*** Measurements
CSS offers both "absolute" (like px) and "relative" (like %, em) measurements. Relative measurements are computed relative to their parents or containers.
*** Grids
*** Homework
- One view which renders a dollhouse
- Dollhouse (i.e., what background? what elements?) actually fetched from the database
- Dollhouse actually rendered visually -- some background, some elements placed correctly
** Forms and HTTP
I'm not going to cover much about the HTML necessary to write forms, or how to use the Django forms library -- I figure you can probably learn that on your own. But of course, sing out if you have problems.

The thrust of this lesson is about HTTP requests, which are the underlying mechanism for basically everything we've done so far and are especially important in handling forms. This is because the Django forms library is sort of old-fashioned -- modern web applications don't usually submit and refresh the entire page any more, but they still use HTML forms and HTTP requests.
*** Reading
Read one of these two. I think the first one is "better" (it's certainly shorter) but it may be less accessible.
http://www.jmarshall.com/easy/http/
http://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html

This provides some amount of overview of how forms work in HTML and HTTP, but with an emphasis on using them in Django. There's one point about forms in Django that you will need to know in order to get them working, and that's the csrf_token thing that they do in the example. Stop at "More about Django Form classes".
https://docs.djangoproject.com/en/1.8/topics/forms/

Wikipedia's got some sort of light but dense information about forms themselves:

https://en.wikipedia.org/wiki/Form_%28HTML%29

Also, about HTTP request methods:

https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
*** HTTP
A web application is a program that responds to "requests" from web browsers -- these requests are made using a protocol called HTTP. In HTTP, each request has a "method" (sometimes called a verb).

In Django, you can access information about the request by using the "request" variable that your view takes. For example, you can get the method being used by examining ~request.method~. The URL of the request is also available, but it's broken up and parsed. In a URL like http://localhost:8080/blog/index?month=December&author=Ethan, the parts we usually care about are the *path* (~/blog/index~, which is available as ~request.path~) and any *query arguments* (~month=December&author=Ethan~). Note that a request can have the same parameter multiple times, as in http://localhost:8080/blog/index?author=Rick&author=Ethan. What this "means" is up to the application to decide.

The most common and important kind of request is the kind that the web browser makes when it goes to a particular URL. In these requests, the web browser requests the contents of that URL. These requests are called "GET requests" because they use the GET method.

In a GET request, Django provides access to the query parameters as ~request.GET~. So, in the above example, you could do ~request.GET["month"]~ to get ~December~. These parameters are always strings. If you need them to be something else, you'll need to convert them. (See https://docs.djangoproject.com/en/1.8/ref/request-response/#django.http.QueryDict for more.)

HTML forms (which you may have seen before) are often submitted to web applications using the POST method. The POST method is used to send data to the web application. There are several other methods, but web browsers typically don't support them directly, so we'll skip them for now. In a POST request, parameters are accessed using ~request.POST~, which behaves the same as ~request.GET~.

(You may have encountered the HTML attribute ~method~ before. ~method~ goes on ~<form>~ elements and you can have the method ~GET~ or ~POST~. This is what that's about.)

The difference between ~GET~ and ~POST~ is that when you use ~GET~ in your application, you're saying that the request is /safe/. Safe requests shouldn't change the state of the application. RFC 7231 explains that a request is safe "if their defined semantics are essentially read-only".

A request that updates a blog post would not be considered "safe", and should use POST. A request that searches for a blog post probably is "safe" and thus can use GET.

HTTP requests contain a lot of information, and a web browser makes lots of them in normal usage.
*** Demo
Make a GET request with a form as well as a POST request. Log both in Wireshark. Show what they look like.

Requests that contain uploaded files are a tiny bit different from those we saw today, but we won't cover exactly how they look on the wire.
** Functions
A function is a "piece" of a program, or a mini-program. Like a program, a function is a series of instructions. A function is those instructions packaged up and made easy to re-use.

A well-designed function serves as an abstraction -- something that lets you accomplish a task without 100% understanding what's going on inside.

Functions are just one of several mechanisms available to make code packaged up and easy to re-use. We've already seen modules; modules are also sort of like mini-programs.

To define a function, you write:

#+begin_src python
def my_function_name(some_argument):
    """A docstring. This string describes the function."""

    ... here is where you would put the stuff you want to do ...

    return something  # if it makes sense for your function
#+end_src

To use it, you write:

#+begin_src python
my_function_name(123)
#+end_src

#+begin_src python
result = my_function_name(123)
#+end_src
*** Recursion
Week 1: 1 pair of mature rabbits
Week 2: 1 pair of mature rabbits + 1 pair of immature
Week 3: 2 pair of mature rabbits + 1 pair of immature
Week 4: 3 pair of mature rabbits + 2 pair of immature
Week 5: 5 pair of mature rabbits + 3 pair of immature
Week 6: 8 pair of mature rabbits + 5 pair
Week 7: 13 pair of mature + 8 pair
*** Fibonacci series
F_0 = 0
F_1 = 1
F_n = F_{n-1} + F_{n-2}

fib(100) = 1 * fib(99) + 1 * fib(98)
fib(99) = fib(98) + fib(97)
fib(100) = 2 * fib(98) + 1 * fib(97)
fib(98) = fib(97) + fib(96)
fib(100) = 3 * fib(97) + 2 * fib(96)
fib(97) = fib(96) + fib(95)
fib(100) = 5 * fib(96) + 3 * fib(95)
fib(96) = fib(95) + fib(94)
fib(100) = 8 * fib(95) + 5 * fib(94)
*** conversion to loop

*** Homework
#+begin_src python
  def factorial(n):
      """
      Factorial function.

      >>> fact(5)
      120
      >>> fact(6)
      720
      """
      pass
#+end_src

#+begin_src python
  def list_mult(l, n):
      """
      Repeat the list l as many times as n.

      >>> list_mult([1, 2, 3], 2)
      [1, 2, 3, 1, 2, 3]
      >>> list_mult([1, 2], 3)
      [1, 2, 1, 2, 1, 2]
      """
      pass
#+end_src

#+begin_src python
  def reverse_rec(s):
      """Reverse a string, recursively, one character at a time.

      This doesn't really make as much sense in Python, but some
      languages have more recursive structures for strings that make
      this more natural.
      """
      pass
#+end_src

#+begin_src python
  def flatten(lst):
      """Take a deeply nested list and flatten it to a single level.

      >>> flatten([1, 2, 3])
      [1, 2, 3]
      >>> flatten([[1], [2, 3], [4, 5, 6]])
      [1, 2, 3, 4, 5, 6]
      >>> flatten([1, [2, 3], [[4], [5, [6]]]])
      [1, 2, 3, 4, 5, 6]
      """
      pass
#+end_src

#+begin_src python
  def flatten_dict(d):
      """Flatten a nested dictionary, using a period to separate nested keys.

      Only works if nested keys are all strings.

      >>> flatten_dict({'a': 1, 'b': {'foo': 2, 'bar': 3})
      {'a': 1, 'b.foo': 2, 'b.bar': 3}
      """
      pass
#+end_src
** Complexity theory
Complexity theory is a way to compare the efficiency of algorithms. Algorithms can't be compared directly; you end up having to compare implementations. Worse yet, those implementations also include implementations of languages, of compilers, and of computers themselves. Complexity theory is a way to get around this -- to abstract out the essence of the algorithm so it can be looked at directly.

[N.B. Recall that algorithms are just sets of steps that you can follow to solve a problem, i.e. they're one step short of a program. But frequently it's easier to examine the algorithm when it's embodied in a program. Just be careful that you understand the costs of every operation that the programming language offers.]

Frequently we want to estimate the cost of an algorithm, i.e. how many operations it takes to run, or how much memory it uses. Usually we'll estimate this cost using big-O notation (and its dorky relatives, big-theta and big-omega notation, which are a little academic even for academics). If an algorithm takes e.g. 5 n^2 + 3 n + 12 operations, we say it is "big O of n^2" -- that is, we take the biggest function of n, throw away everything else, and discard any constant factors. (Constant factors tend to be controlled by e.g. speed of hardware, programming language, and other non-algorithmy things that are nevertheless very important.) Sometimes it's enough to just estimate "number of operations" -- sometimes we want to compare against something else, such as "number of times we have to read from disk", or "number of network operations", or some other number of specific operations.

Big-O notation tends to give an "upper bound" to the runtime of an algorithm, which is usually good enough for our purposes, but if you want, you can use big-omega to specify a "lower bound" or big-theta which is supposed to be a more exact bound (both upper and lower).

Sometimes people talk about worst-case, best-case or average-case complexity.

Sometimes you need two variables to express the complexity of an algorithm. Lots of graph theory algorithms require O(V+E) to run. (We'll talk more about graph theory later. It's not graphs in the sense of pictures of mathematical functions.)

Remember that when you're implementing an algorithm, runtime is not the only consideration! Readability and maintainability usually trump runtime, because you usually only have one or two "hot spots" which need to go really fast (if any).
*** Example
http://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html test yourself problem 2
*** Underlying data structures and operations
In order to really do big-O notation justice, you have to understand some of how the computer's memory works, because some operations are hidden by the way the programming language works.

Computer memory is random-access. That means you can go to any place in memory with the same speed. It's almost like each byte of memory in RAM has its own telephone number, and all telephone numbers take the same amount of time to dial, so any byte is equally fast. [Note: this is a gross oversimplification that is nevertheless assumed in complexity theory.]

A single Python variable, like say a variable that contains an int, is just 4 bytes of memory. Thus, to read a variable just takes four phone calls (or, we can say that it just takes one phone call, since we're disregarding coefficients (and also because a 32-bit computer reads memory 4 bytes at a time -- this is called a "machine word")).

Simple mathematical operations are also counted as one single operation. [This is part of the same gross oversimplification.] We say that such an operation is constant-time or O(1).

So how fast is this algorithm?

#+begin_src python
def foo(a, b):
    x = 0
    for i in range(b):
        x += a

    return x
#+end_src

A Python "list" is just a big batch of contiguous memory. That means that if the first element of the list is at phone number 1, the second element will be at phone number 2, and the third at phone number 3, and so on. If you know which index you want, you can just dial it directly -- so this is also one operation.

So what's the asymptotic runtime of this program?

#+begin_src python
def elem(x, lst):
    i = 0
    while i < len(lst):
        if x == lst[i]:
            return True
        i += 1
    return False
#+end_src

What about this one?

#+begin_src python
def foo2(x, l):
    i = len(l)    # len(l) ~= O(1)
    while i > 0:
        l[i] = l[i-1]
        i -= 1
    l[0] = x
#+end_src

#+begin_src python
def foo3(x, l):
    i = len(l)
    while i > 0:
        foo2(x, l)
        i -= 1
#+end_src

Lists also store their size. If you add an element to a list that doesn't have space for it, it will have to find a bigger batch of memory and copy everything over. (What's the runtime of that?)

Because this is expensive, we use a trick. Every time we increase the size of the list, we double the size. This way, we get to insert O(n) elements. This means that adding to the end of a list is, on average, O(1). This is called *amortized* constant time -- it's not really constant, but it's constant enough.

How are dictionaries implemented? Basically, they're like lists, except that whatever you use as your key has to be turned into an index. This is called hashing and it's kind of magical. However, the good news is that lookups in a dictionary are constant-time (relative to the size of the dictionary) because you just have to hash the key and then look at that index.

In a homework a few weeks ago, you implemented a "check if an element is in a list" operation. The runtime of that operation is O(n). In general, you can't do better, but if you know your list is sorted, you can. How? You'll probably come up with an algorithm called binary search.

List:
-1, 2,  5,  9,   15, 16,  18, 19, 20,  25, 35

Find: 6.
#+begin_src python
  def flatten(lst):
      new = []
      for i in lst:
          if not isinstance(i, list):
              new.append(i)
          else:
              new.extend(flatten(i))

      return new
#+end_src

*** Homework
Implement the binary search algorithm. This is kind of naturally recursive too. What is its runtime?

Read https://en.wikipedia.org/wiki/Tower_of_Hanoi. Come up with an algorithm to solve it. Implement it. How fast does it run?
** Object-oriented programming
Object-oriented programming is a paradigm or methodology that is found in a lot of modern programming languges. It's one way to conceptually decompose systems and write abstractions. It's not the only way, which is why Python supports a lot of other ways, but it's still an important way.
*** Abstractions
When you write a function, you're writing an abstraction -- you're defining a new kind of operation which is made up of smaller, more basic operations. Knowing how to use the new operation liberates you from having to use the underlying smaller operations.

Programming is very very often about abstractions in one form or another, and choosing good ones to write and writing them well can be very challenging. (The exercises you guys have been doing are all essentially about implementing an abstraction that someone else chose for you.)
*** Classes
When writing functions, the abstraction you're creating is one of behavior. (This function does that.) In object-oriented programming, your abstraction bundles both behavior and state. This is kind of an abstract idea, so here's an example.

Let's say we want to write a program that models some users' reading habits. We might want to do stuff like this:

#+begin_src python
  alexs_book = {'title': "The Wise Man's Fear",
                'current_page': 10}

  my_kindle = {'current_book': "Pride and Prejudice",
               'account': 'ethan@example.com',
               'books': [
                   {'title': "Pride and Prejudice",
                    'current_page': 213},
                   {'title': "So You Want To Be A Wizard",
                    'current_page': 1},
                   {'title': "Furies of Calderon",
                    'current_page': 92}
               ]
  }

  def turn_book_page(book):
      book['current_page'] += 1

  def turn_kindle_page(kindle):
      # FIXME: This code has bugs.
      current_book = kindle['current_book']
      turn_book_page(kindle['books'][current_book])

#+end_src

We've defined some kinds of ad-hoc data structures here that correspond to books and book-like devices. These data structures correspond to *state* -- some kind of mutable information about current reality. A Kindle is more complicated than a book, so it has more (and different) state.

We've also introduced some operations to manipulate these data structures. However, you have to know which data structure you have when you want to use the operation. If you write a program that works for both books AND Kindles, you have a problem. You'd have to be sure never to call a Kindle function on a book, and vice versa, or else your program would break messily.

To make it a little easier, maybe you could write a function like this:

#+begin_src python
  def turn_page(book_or_kindle):
      # What goes here???
      pass
#+end_src

But in order to reliably determine what thing you have, you'd have to add another field to store that it's a book or a Kindle. The whole thing gets very messy -- dicts aren't required to always have the same keys, but books probably do.

Instead we define something called a *class*, which represents the underlying model. We use these to stamp out *objects*, which resemble the class. That might look like this:

#+begin_src python
  class Book(object):
      def __init__(self, title, current_page):
          self.title = title
          self.current_page = current_page

      def turn_page(self):
          self.current_page += 1

  class Kindle(object):
      def __init__(self, account, current_book, books):
          self.account = account
          self.current_book = current_book
          self.books = books

      def turn_page(self):
          self.books[self.current_book].turn_page()

  alexs_book = Book("The Wise Man's Fear", 10)

  my_kindle = Kindle('ethan@example.com', "Pride and Prejudice", [
      Book("Pride and Prejudice", 213),
      Book("So You Want To Be A Wizard", 1),
      Book("Furies of Calderon", 92)
      ])

  my_kindle.turn_page()
#+end_src

This code says to define two classes, which have certain data and
support certain operations. Then, I *instantiate* those classes, which
means to create an object, or instance, of those classes. When I do
this, the ~__init__~ function for those classes is called (this is
called the *constructor*). Both classes also have other operations,
which are called *methods* (a method is just a function defined on a
class).

Both classes have a common ~turn_page~ method. That means I can always call ~turn_page~ without having to care about what object it is.

To access data in an object, you use the ~object.attribute~ syntax we've seen. To call a method on the object, you write ~object.method()~.

To define methods, define a function inside the body of a ~class~ statement. These functions will take an additional ~self~ argument, which refers to the object itself, and can access its data or its methods directly.

The details of this process vary from language to language. Some, like
Java, require you to formally create an *interface* saying what
operations books and booklike things are expected to perform, and what
operations are available to the person using the class or object
(to try to limit misuse). But Python tends to be a bit more permissive here because of the culture of "We're all adults here". Look up "duck typing" for more about this.
*** Inheritance
Sometimes you want to define some new class. It's a lot like a more specialized version of an existing class, and you don't want to copy all the existing code (DRY; because copying is bad). To do this, we define a *subclass*.

#+begin_src python
  class Paperwhite(Kindle):
      def __init__(self, *args, **kwargs):
          super(Paperwhite, self).__init__(*args, **kwargs)
          self.is_backlight_on = False

      def turn_on_backlight(self):
          self.is_backlight_on = True

  moms_paperwhite = Paperwhite('donna@example.com', .....)
  moms_paperwhite.turn_page()
  moms_paperwhite.turn_on_backlight()
#+end_src

[The ~super~ function might behave a little bit differently in Python 3.]

Here, we are defining a new kind of Kindle. A Paperwhite is
automatically a Kindle, although not all Kindles are
Paperwhites. Paperwhites are a kind of Kindle that has a
backlight. Because Paperwhites *inherit* from Kindles, all Kindle
operations are still available in Paperwhites. (So you can still do
~turn_page~ on one.) It also offers some new functionality (a
~turn_on_backlight~ call).

The constructor for the Paperwhite needs to set up the Paperwhite, which means it needs to set up the Kindle part of the Paperwhite. To do this, it calls its *superclass* using the ~super()~ call.

The constructor for the Paperwhite does this neat trick with ~*args~ and ~**kwargs~. What this is saying is, whatever arguments you give me will be collected, whether they are positional (~*args~) or named (~**kwargs~). Then, when calling the superclass, it can un-collect them in the same way.
*** Design
There's a lot of material out there about "proper" object-oriented design and programming. Some essentials:

- What are the subjects of discourse in the domain? What are their relationships? What operations do they support?

- A constructor should ensure that the object is in a coherent state, and operations should always leave the object in a coherent state.

- A subclass should follow an is-a relationship, and never a has-a relationship. A Paperwhite is-a Kindle. (Although some cultures, like that of Java and Go, discourage inheritance and prefer the use of has-a relationships and delegation.)

- If you ever find yourself doing something like

#+begin_src python
  if foo.type == 'book':   # or isinstance(foo, Book)
      # do something with books...
      pass
  elif foo.type == 'kindle':
      # do something with kindles...
      pass
#+end_src

... you should restructure it as a common method.
*** Differences with Django models
Django models have field definitions which have a clear type.

Django models have clear relationships with other objects.
*** TODO exercises for *args, **kwargs
** Modules
The ~import~ statement introduces a "module", which is an object that represents the code loaded from some other file.

Let's say we put this code in a file called file_loader.py:

#+begin_src python
class FileLoader(object):
    pass

def load_file(filename):
    pass
#+end_src

And in another file (let's call it main.py) we put this code:

#+begin_src python
import file_loader
#+end_src

... we create a variable ~file_loader~ which represents a "module". If we print ~file_loader~, it will show us that it is a module and what file the module was loaded from. We can henceforth access the ~FileLoader~ class and the ~load_file~ function using the syntax ~file_loader.FileLoader~ and ~file_loader.load_file~. If we get tired of typing these things, we can also make them available directly using:

#+begin_src python
from file_loader import FileLoader, load_file
#+end_src

Now we can just use ~FileLoader~ and ~load_file~.

If you have lots of modules together, you can group them in a "package". A package is just a directory with a ~__init__.py~ file in it. See https://docs.python.org/3.5/tutorial/modules.html#packages for more info.
** Return of the Django
*** Review
Django, on startup, examines your site to discover its main application. Then it *imports* that application's settings file and URLs file (i.e. modules you wrote). Then it looks at your settings to identify the other applications in your site and imports all their models. Finally, it begins listening for requests from a browser. When a request comes in, it uses the rules from ~urls.py~ to decide what view will handle it.

Defining a model in Django is done by defining a subclass of ~django.db.models.Model~. Unlike normal Python classes, models tend to have explicit lists of fields and types. Like normal Python classes, they can have their own methods.

Defining a view in Django is done by defining a function (or callable object). This function must take at least one argument, which is a ~Request~ object, but it can take more if it wants to use parts of the URL. This function must also return a ~Response~ object. Normally a ~Response~ is produced by rendering a template, but it doesn't have to be. It's traditional to put views in a ~views.py~ module, but they don't have to be.

Django forms can be defined by defining a subclass of ~django.forms.Form~. Like models, you define all fields that your form needs and what type they are. A form needs access to a ~POST~ or ~GET~ from a real ~Request~ and it will tell you if the data was valid.

Defining a template is done by putting a file in a templates directory. Templates are usually kept in files like ~templates/appname/viewname.html~. Templates use the Django template format. To put a variable in a template, use ~{{ variable }}~. You can do some processing of variables using filters like ~{{ x | first }}~. You also get some other commands like ~{% if %}~ and ~{% for %}~. Templates can *extend* other templates. The "parent template" defines blocks and structure, and the child template fills in those parts.

To add CSS (or eventually, JavaScript) to a page, you'll use the ~staticfiles~ application. In templates, you'll use the ~{% load staticfiles %}~ command to get access to it, and ~{% static "appname/file.css" %}~ to create a link to the file.

CSS is a set of rules that change the appearance of HTML elements. Each rule has a selector that determines what elements it will apply to:

- ~foo~ applies to any HTML element with the tag ~<foo>~
- ~.foo~ applies to any HTML element with ~foo~ among its ~class~ attribute. Note that this kind of class is not like an OOP class!
- ~#foo~ applies to any HTML element with ~foo~ as its ID. IDs are supposed to be globally unique, and classes need not be.
- If ~X~ is a selector, and ~Y~ is a selector, the selector ~X Y~ matches any element who matches ~Y~ that is inside an element matched by ~X~.
- ~X > Y~ matches any ~Y~ child of a node matching ~X~.
- ~X, Y~ matches any node matching ~X~ or any node matching ~Y~.

A rule also has a bunch of properties, which are written inside braces. A property has a name and a value, e.g. ~color: blue;~. Each property allows different kinds of values. Of particular interest are ~float~ and ~position~ properties, which help you put together more complicated layouts. (Although it seems like the forward-looking thing is to use something called flexbox.)

Git is a system that tracks the content of your code, and thus their changes. It can be hosted on Github for free if you don't mind your code being public. You create a new project using ~git init~, choose what changes to record using ~git add~, and then record them with ~git commit~. Some files (like a Django database or a virtualenv!) shouldn't be tracked, so you can put their names in a file called ~.gitignore~.
*** Class-based views
Because most Django views are pretty similar, there is a mechanism to reduce boilerplate in views. You can define a class which is a subclass of an existing Django built-in view class, and customize it. See https://docs.djangoproject.com/en/1.9/topics/class-based-views/intro/.
** JavaScript
JavaScript is another language used in the web stack. A JavaScript interpreter is embedded in the browser and it executes JavaScript loaded on a web page. You can use JavaScript to make a web page interactive without requiring more requests back to the server. You can also use it to do graphical and animation stuff if you want to do something that you can't do in CSS (although CSS tends to expand to swallow these tasks).

JavaScript originally started out as a toy language that was stuffed into the browser, and JavaScript code was written by people who didn't really know much about programming, but over time it's grown more and more sophisticated and "cool" until real people started writing code in it. In particular, JavaScript has escaped the confines of the browser and can be run on the server now using a thing called NodeJS. Now there's an incredible amount of energy and technology in the JavaScript scene despite the fact that pretty much everyone still agrees that it's actually a pretty crappy language. In particular, because of its peculiar history:

- There are some things that don't have an accepted "technique" yet -- the equivalent of Python's ~import~ statements and modules don't exist in the core JavaScript language, and for a few years we've been in a period of development of possible alternatives and tools. I only know a little bit about these and can't offer deep wisdom about them.

- There are some things that you can do in multiple ways, some of which are just bad or discouraged. Compare with "The Zen of Python", which says "There should be one -- and preferably only one -- obvious way to do it." I'm going to tend to cover the ways that I consider "most correct", although I'll also try to follow up with other "less correct" ways and explain why I think they're less correct, so that you can be prepared if you see them in the field.

- Like HTML, JavaScript is designed to be forgiving of errors. So often, when you do something wrong, the program will just try to make the best of it and continue, as though it were better to do anything at all instead of signal an error. What this means is that sometimes you will get an error with your program far after the actual error happened, so keep an eye out for that. In Python, of course, "Errors should not pass silently, unless explicitly silenced".

- Sometimes language features combine to do bizarre things. See e.g. http://wtfjs.com/ when you're a little more familiar with the language.

What I am covering is meant to get you up and running with basic tools for client-side programming. I haven't kept up to date with all the hot new tech. I'd encourage you to look at/experiment with other technologies if you want to see more about what's out there. In particular, there seem to be a bunch of frameworks for "reactive programming", which promises to make the sorts of things that we're going to do here seem very clumsy. Additionally, there are a few client-side programming languages which offer improvements to JavaScript, and they "compile down" to JavaScript to run in the browser. In particular I'm thinking of PureScript and TypeScript. In five years' time, any of these might be the thing to know, and this lesson may look like cave scratches by Neanderthals.

Most importantly, the goal of this lesson is to get you up and running with JavaScript and maybe also a library called jQuery. The goal of this "unit" is to get you to be able to add a drag-and-drop functionality for items in the dollhouse to allow a user to position them directly (rather than specifying an x/y coordinate).
*** Adding JavaScript to a webpage
The "correct" way is going to be to add a ~<script>~ tag to your HTML. This is going to be very similar to how you added CSS. In your generated output HTML, you want to have the tag: ~<script type="text/javascript" src="path-to-file.js"></script>~. (You'll have to use the ~static~ plugin the same way we did in CSS.) (Note that if you try to use a self-closing ~<script/>~, the browser may not understand it.)

Once you get to a certain size of webpage, you'll probably need to start developing libraries that depend on each other and you'll need to pick a mechanism for importing libraries (I think everyone has standardized on something called "AMD modules" and "require" by now). You'll also eventually need to figure out a mechanism to turn lots of small JavaScript files into one compressed JavaScript file to reduce page load times. That's outside the scope of this course, but be aware that what we're doing isn't the most correct thing forever.

Less correct is to just slap JavaScript into the HTML directly. Sometimes you'll see this when using third-party JavaScript, like for Google Analytics. This looks like:

#+BEGIN_SRC html
<script type="text/javascript">
  // ... code goes here
</script>
#+END_SRC

Either way, your JavaScript will be run every time you refresh the page. You can use your browser's web development tools to verify that the JS is getting loaded.
*** Output in JavaScript
The closest thing to ~print~ in JavaScript is called ~console.log~. You use it like this:

#+BEGIN_SRC javascript
console.log("Hello world!");
#+END_SRC

Any output sent to ~console.log~ will go to your web browser's "console", which should be available also in development tools. When you refresh the page, the console is wiped clean and your program is rerun.

If you're debugging and want to show variables, you can also do that:

#+BEGIN_SRC javascript
console.log("Showing a variable", x);
#+END_SRC

There is also a command called ~alert~ which will show an annoying little pop-up message. You can also use this to output stuff if you're debugging.

There's also a command called ~document.write()~ which will "write" stuff to your HTML. Sometimes ad network code will do this. Don't do this, because it can really screw up your HTML.
*** Overview of JavaScript syntax
#+BEGIN_SRC javascript
// this is a comment
// all statements should end in semicolons
var x = 1;  // this is a variable; you should declare all variables
var y = 2, z = 3; // you can declare multiple variables on the same line
var options = {  // this is an "object", which is like a Python dict
    name: "Ethan",    // keys must be strings and need not be quoted
    course: "Computer Science Reading Group"
};  // N.B. semicolon here!
var myName = options.name; // "object" access
var alsoMyName = options["name"]; // same as above
var numbers = [1, 2, 4]; // array literal
var howManyNumbers = numbers.length; // array length
var someNumber = numbers[0]; // array access
f(x, y);  // function calls are basically the same, but no keyword arguments
obj.meth(x, y); // method calls are also basically the same

var showText = function(x, y){  // defining functions
    console.log("text!");
};  // N.B. semicolon here!

if (x == 5) {
    console.log("x = 5!!!");
}
else if (x == 6) {
    console.log("x = 6!!!");
}
else {
    console.log("x was something else!");
}

// while loop
var i = 0;
while (i < numbers.length) {
    var thisNumber = numbers[i];
    console.log("number " + i + " was " + thisNumber);
    ++i;
}

// for loop in JS is not much different from a while loop
for (var i = 0; i < numbers.length; ++i) {
    var thisNumber = numbers[i];
    // do something with a number
}

// The most elegant way to iterate over an array in JS is the forEach() function
// which takes a function as an argument.
numbers.forEach(function(thisNumber, i) {
    console.log("number " + i + " was " + thisNumber);
});

// you can also iterate over properties of an object using for .. in
// Be careful with this because it also gets properties of "parent" objects!
for (var key in options) {
    var option = options[key];
    console.log("option " + key + " was " + option);
}
#+END_SRC

Some things to note:

- Although the JavaScript language says that statements must end in semicolons, if you leave them out, there is a process called Automatic Semicolon Insertion (ASI) which happens, and often makes your program behave correctly. For this reason, some practitioners prefer not to explicitly put semicolons in. I don't have strong feelings on the subject, but basically follow the school of thought that says "ASI is explicitly about fixing an incorrect program, so if you don't put semicolons, your program is incorrect". See http://inimino.org/~inimino/blog/javascript_semicolons for more about this.

- In Python, variables are local by default, and can be made global using the ~global~ keyword. In JavaScript, variables are global by default, and have to be made local using the ~var~ keyword. You almost always want your variables to be local, so you should always declare them using ~var~.

- I keep writing JavaScript "object" in quotes because these are not like the objects from object oriented programming we've seen in Python. They're really more like dicts or hash tables. Object oriented programming in JS is quite a bit different than in Python. In particular, there's no particular way to define a class, and inheritance functions differently in JS than in Python. For these reasons, most practitioners avoid OOP when doing JS.

- In a JavaScript "object", keys don't have to be quoted, so JavaScript ~{name: "Ethan"}~ is the same as Python ~{"name": "Ethan"}~. However, in Python, keys can be full expressions, so you can have e.g. ~x = "name"; return {x: "Ethan"}~ . You can't do this in JavaScript; you'd have to do ~var x = "name"; var tmp = {}; tmp[x] = "Ethan"; return tmp;~ .

- If you access something in an "object" that doesn't exist, you don't get an error, but rather you get a special value called ~undefined~. Trying to do anything with ~undefined~ is an error.

- In JavaScript, lists are called Arrays. Many things seem like they should be arrays but aren't.

- Arrays behave basically like you expect, but without any of the useful functionality you might be used to from Python. For example, if you want to get the last element, you can't just do ~array[-1]~ -- you have to do ~array[array.length-1]~.

- Despite the fact that we don't really do OOP in JS, there are still methods. Writing a method is very strange in JS, but using them is usually pretty much what you'd expect.

- In Python, you can put a comma at the end of a dictionary or list declaration, but generally this isn't done in JS.

- Defining a function is done using the ~function~ keyword. Note that in JS, it's very common to create an anonymous function by using the ~function~ expression, without putting it in any variable. The ~function~ keyword is like the ~lambda~ in Python, except without any of the restrictions on the Python version. Arguments to the function go in the parentheses, and the body goes in the braces, like you'd expect.

- Note that in JS, you can call a function with different numbers of arguments than it was defined with. Any arguments that don't get values get set to ~undefined~. Any extra arguments are ignored (but can be accessed if you want -- more about this later).

Other people sometimes define functions using this syntax:

#+BEGIN_SRC javascript
function showText(x, y) {
    console.log("text!");
} // N.B. No semicolon
#+END_SRC

I don't like this syntax as much because it makes it less obvious whether the function is global or local. Additionally, sometimes I don't want to just define a function called ~showText~, but sometimes I want to call it ~someObject.showText~ -- with the style that I use, it's easy to change ~var showText =~ to ~someObject.showText =~, whereas with this style, I have to remove the name ~showText~ and move it to the beginning of the line.
*** The DOM
When we were talking about CSS, we talked a little bit about the DOM -- the structure of HTML elements on your web page. Besides writing stuff to the console and popping up message boxes, the main thing you do in JavaScript is manipulate the DOM. You can add classes to a page, add CSS styles to an element, or replace page content entirely. This lets you make a web page that can change.

The way you find DOM elements to manipulate is very similar to the ways we identify elements for CSS rules. First, you can select an element with a given ID using ~var someElem = document.getElementById("some-id")~. Then, you can:

#+BEGIN_SRC javascript
  console.log(someElem.className);  // access its "class" attribute
  someElem.className = "class1 class2"; // replace its "class" attribute
  // pop quiz.. how do we add a class to the element without replacing the existing ones?

  // you can also replace an element's content
  someElem.innerHTML = '<div class="some-class">New content</div>';

  // this adds "inline styles" to an element, the same as if you used
  // the "style" attribute on the element
  someElem.style.color = "blue";
  // this is the same as adding style="color: blue;" to the element
#+END_SRC

You can also fetch a bunch of elements that match a CSS selector. You can use ~var someNodes = document.querySelectorAll("div.some-class");~. This returns a ~NodeList~, which is one of several things in JavaScript that are sort of array-like but not really Arrays. It has a ~length~ and numeric elements from ~0~ to ~length-1~. See also https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll.

This ought to change all ~div~ nodes with the ~some-class~ class to have only the ~new-class~ class.

#+BEGIN_SRC javascript
var someNodes = document.querySelectorAll("div.some-class");
for (var i = 0; i < someNodes.length; i++) {
    var node = someNodes[i];
    node.className = "new-class";
}
#+END_SRC
*** jQuery
Despite the fact that JavaScript is a pretty craptacular language, underneath all its terrible design choices and perplexing behavior, there's actually the germ of a pretty decent language. With this language, it's possible to do clever and beautiful things. One of these things is the jQuery library. jQuery is like a Swiss army knife for client-side JavaScript programming. It contains lots of utilities to find and modify DOM elements as well as more basic stuff like operating on elements of array-like things. jQuery also helps you in the case where you have to support old libraries that don't support all the functionality that you need -- it provides *polyfills*, which are just a fancy way of saying they provide implementations of missing stuff so that your code can work even if the browser doesn't provide everything you need.

[N.B. Old versions of IE used to make our life the hardest, but in version 9 and up, it seems like it's getting acceptable.]

[N.B. Of course, if someone is using NodeJS, which is server-side, a client-side library like jQuery doesn't make sense!]

To use jQuery, put another ~script~ tag before your ~script~ tag, like: ~<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>~. We're using Google's hosted jQuery (see https://developers.google.com/speed/libraries/), but in a real site we'd probably host our own and/or come up with a more sophisticated loading strategy. Anyhow, the browser will load and run the jQuery library, which will define a global variable called ~$~. Then, it will load and run yours, which can use it to do e.g.

#+BEGIN_SRC javascript
$('div.some-class').each(function(i, elem) {
    $(elem).attr('class', 'new-class');
});
#+END_SRC

or even

#+BEGIN_SRC javascript
$('div.some-class').attr('class', 'new-class');
#+END_SRC

See http://learn.jquery.com/ and http://api.jquery.com/ for more info.

As time has gone on, more and more of the functionality that you used to need jQuery for has been moved into browsers themselves. For example, you can use CSS animations where previously you had to use jQuery animations, and ~document.querySelectorAll~ is basically the same as jQuery's ~find~ function. Because of this, and because jQuery is such a big library, some practitioners have always avoided it, either by replacing it with other libraries or with no library at all. See also http://youmightnotneedjquery.com/ for comparisons of how to do tasks with jQuery and with "vanilla JavaScript". Although the central premise of the website is that jQuery isn't really needed, I think almost all of the jQuery operations look way easier to read and maintain than the vanilla JS ones. This is a point of contention in the community, with some people jokingly responding to JavaScript questions with "just use jQuery", and others making fun of noobs who use jQuery even when they don't have to.

[N.B. The function given to the .each() method on jQuery objects gets arguments in a different order from the JS Array.forEach() method! This has tripped me up a number of times.]
*** Events
JavaScript is also good at listening for and responding to events. Using jQuery, you can do:

#+BEGIN_SRC javascript
$(".some-selector").on("click", function() {
    // do something
    // "this" is available to refer to the element on which the event happened
});
#+END_SRC
*** Page load event
Although you will normally put your scripts in the ~<head>~ block of your page, the rest of the document hasn't loaded yet. Usually it's a good idea to set up code to run after the page is loaded using e.g. the jQuery ~ready~ function.

#+BEGIN_SRC javascript
$(document).ready(function() {
    alert("OK, rock and roll!!");
});
#+END_SRC
*** Reading list
http://ejohn.org/blog/html-5-data-attributes/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference is a good reference
** Data modeling
"Show me your [functions] and conceal your [data structures], and I shall continue to be mystified. Show me your [data structures], and I won’t usually need your [functions]; they’ll be obvious." -- Fred Brooks

When developing a system to represent some problem or some information, you will have to choose a representation from among many that seem viable. This set of notes focuses on modeling your data in a way that is the most "correct". Correct means that it is easiest to understand and maintain, and that in particular it does the most to "make illegal states unrepresentable" (in the words of Yaron Minsky).

I'm not calling this section "data structures" because "data structures" is a field of computer science that focuses in minute detail on the efficiency of a particular mechanism. Data structures people care about things like whether you store a matrix by rows or by columns. That field of study can be interesting, but this set of notes is not concerned with such minute detail or even efficiency except in the vaguest of terms. We care more about "abstract data types", which define a set of operations supported by some structure.

By the same token, I'm going to focus on modeling your data for correctness assuming some sort of abstract memory in some sort of pure conceptual domain. I'll touch on translating these data models into specific programming language types, but translating them into e.g. a relational system is beyond the scope of this set of notes. There's usually some well-known way to "encode" what you want into the tool that you're using (or to "decode" that tool's structures into the original author's semantics).

Another related topic is about dividing up a system into smaller systems and components. This is called system architecture and I'm not super good at it. There are much fewer hard-and-fast rules about architecture, and a lot depends on the business context you're operating in. The same system can be described as "enterprise" or "industrial strength" or "heavyweight" or "baroque" or "overengineered". Architecture is not the emphasis of this set of notes.

Some amount of this will vary a little bit from language to language, but not too much. What seems to vary more is the lengths that people will go to in the pursuit of correctness, and how much they are willing to compromise correctness in exchange for efficiency (or even for convenience).
*** Basic types
Some "fundamental" types that you might use to model an individual datum.
**** Integer
A good starting point for data modeling is the "integer" type. Integers are familiar from mathematics; they represent numbers like -5, 1, 17, but nothing "fractional". Integers are discrete. They support addition, subtraction, multiplication, division, and "modulo".

Some languages distinguish between "signed" and "unsigned" integers. Signed integers can be positive or negative (i.e. they have a plus sign or a minus sign in front of them). Unsigned integers can only be non-negative, i.e. 0 or greater. (If you need a non-positive number, you can just use an unsigned integer and assume it's always the opposite, i.e. additive inverse, of the number you want.)

Some languages force you to choose a "size" for your integer, usually measured in bytes, but for most web development, this doesn't matter all that much.

Integers are a good choice for modeling:

- Numeric quantities.
- "Scores", i.e. ratings of things like priorities or rank. When doing this, be clear about whether higher is better or lower is better.
- "Enums", i.e. mutually exclusive categories, especially if they have an implicit "order". More about this later.

Integers are a bad choice for:

- Anything that "seems" numeric but doesn't behave numerically. As a good example, the book "Programming Perl" points out that the ZIP code of Cambridge, MA is 02140, but unlike numeric values, 02140 isn't the same as 2140, which isn't a valid ZIP code.
**** Float
For cases where your numeric quantity has fractional parts, one option is to use a "float", or a floating-point number. "Floating-point" means that although your data has a fixed amount of precision, that precision can be used to represent very small numbers (i.e. 0.00000000000000000000005) or very large ones (i.e. 50000000000000000000000.0). That is, the decimal point can "float" around within the precision you are allowed.

Most languages offer floating point numbers implemented directly using the processor's built-in floating point capacity, which usually follows a standard called IEEE 754. IEEE 754 mandates a standard where numbers are represented as decimals in base-2. This means that it's possible to represent 0.5 (which is 0.1 in base 2), but 0.2 is 1/5, which isn't possible to represent exactly in base 2 (it would be 0.0011 repeating). That means that when you try to represent 0.2 as a float, what you actually "get" might be either 0.19999999999999999999.... or 0.2000000000000000000000000001, depending on what floats are possible and which ones are closest to what you wanted. See https://docs.python.org/2/faq/design.html?highlight=floating%20point#why-are-floating-point-calculations-so-inaccurate for more.

JavaScript has the unusual property that there is one "type" for both integers and floats, called "number". That means that e.g. modular arithmetic "works" on floating point numbers (it does not in Python).

Floats are a good choice for:

- Approximate numerical quantities requiring a very large range (but relatively small precision).
- Or generally any kind of numeric quantity where you want to do math but don't really care how precise the math is.

Floats are a bad choice for:

- Money. Seeing something like "$5.01" may make you think of a floating-point quantity, but because floating point arithmetic isn't "exact", you can accumulate "error" of fractional cents, which can be scary. In this case, one trick is to store integer numbers of cents instead, and just convert them to dollars on input/output. Otherwise you could use Decimal, below.
- More generally, if you "only" need a specific range and precision isn't really negotiable, you can use an integer number of something that's very large (years) or very small (microseconds).
**** Bignum/Decimal
In many languages, normal "integers" only have a certain range -- for example, a common one is up to 2^64. This is the "natural" size of the processor and operations on such integers are very fast. Beyond this, someone has to do work to translate "bigger" integers into integers of this size when doing math. This works similarly to how humans learn their multiplication tables up to e.g. 10 x 10, and bigger multiplication problems are "decomposed" into smaller ones. In this way, you can store arbitrarily large integers, which are called "arbitrary precision" or (sometimes, more casually) "bignums". Ideally they work exactly the same as regular integers, but sometimes special syntax is needed to use them.

In Python, bignums are called ~long~, although ~long~ can mean other things in C-like languages. Also in Python, integer math will "gracefully" return longs if you exceed the capacity of an int.

Once you have arbitrarily-large integers, it's possible to have arbitrary-precision floating-point by just using a bignum + some information saying where the decimal point goes. In Python, arbitrary-precision floating-points are called ~Decimal~ and they are available in the ~decimal~ module.

Both bignums and decimals are less efficient than "pure" integers and floats, but are usually fast enough.

Bignums are a good choice for:

- Very large numbers for which mathematical operations nevertheless need to be completely precise. (This is common in cryptography, for instance.)

Decimals are a good choice for:

- Numbers with digits after the decimal place that you nevertheless want to represent exactly. A good example is when you want to store a number like "0.2" and don't want it to come back out as "0.20000000000000000000001" (although sometimes you don't care).
**** Booleans
Booleans are central to a lot of computer science. They can be represented using a single bit of memory and only have two values (true and false).

Booleans are a good choice for:

- Individual attributes which can only be true or false (there are no "unknown" or "n/a" or "ask" option).
- "Flags", i.e. a bunch of on-off information that isn't mutually exclusive. For example, a file might have can_read, can_write, and can_execute flags, and each might be true regardless of the other two. (If it *is* mutually exclusive, i.e. if you can only write things you can also read, then you want an enum; see below.)

Note that you can combine a lot of flags into an integer using bitwise AND, OR, NOT, and XOR operations. This used to be a thing people would do in low-level languages to save a few bytes of memory; these days it's more likely a way to combine arguments to a function. I'd generally consider this bad practice these days, both because individual bytes of memory aren't so precious and most languages offer some better way to pass in a wide variety of arguments (for instance, Python has keyword arguments, or you can pass in a struct of all possible arguments (see below)).
**** Enum
A Boolean is a type that can either be true or false, but not both at the same time, and not anything else. Sometimes you also want to define a type that can only be one of a small set of possible values. I'm calling this an "enum", which is the name it's given in C/C++. It stands for "enumerated type", i.e. you've enumerated all possible values for this type.

For example, my microwave can be standing by (not cooking), or it can be cooking, or it can have finished cooking (in which case it displays "end"). Because the microwave cannot be both cooking and finished cooking at the same time, this can be an enum.

Enums are good candidates for anything that seems kind-of-Boolean-y, but isn't quite Boolean, or any other kind of mutually exclusive state.

For a while, Python didn't have a "standard" enum functionality built-in, and people had differences of opinion about what it should actually do and how it should actually work. However, Python 3.4 offers https://docs.python.org/3/library/enum.html.

Some more modern languages offer something that might be called "enum" but is a little more complicated. I'll cover these in "Tagged unions", below.
**** String
A string represents a piece of text, meant to be shown to or received from a human.

In Python 3, this is called ~str~. In Python 2, this is called ~unicode~. (This is the major difference between Python 2 and Python 3.)

Some systems (SQL) require you to know ahead of time how much text you are going to store, the same way that you need to know the size of your integers.

Strings are a good choice for:

- Names. (But be aware of https://www.w3.org/International/questions/qa-personal-names)
- Addresses.
- Other actual human text.
- Sometimes, as a serialization format for other, more complicated data, like dates or enums. Note that one danger with strings is that they can become a kind of default unstructured type whenever something is too complicated to represent or someone is too lazy to do things "right". See http://wiki.c2.com/?StringlyTyped. This tendency isn't necessarily bad, just something to be aware of.
**** Bytestrings
A bytestring is a sequence of bytes. Unlike a string, a bytestring is not usually shown to a human. Instead, a bytestring represents something that needs to be sent to an input or output device, without human understanding being necessary.

In Python 3, this is called ~bytes~. In Python 2, this is called ~str~, which is a bad name for it and a major reason why Python 3 exists.

It's pretty rare to need bytestrings in modeling data, but they are worth a mention because a lot of systems get them wrong, and even when they don't, it can be helpful to understand how they're supposed to be used. If you ever encounter bytestrings, I recommend this presentation by Ned Batchelder: https://nedbatchelder.com/text/unipain.html.
**** Optional/nullable
Sometimes you want to talk about a datum that is always there or necessary. Other times you want to talk about one that may be present or absent. The latter is sometimes called a "nullable" type, with "null" representing the absent value. Nullability isn't a type itself, but it's a thing that modifies other types.

Being clear about whether something is nullable or not, and what null means, can be very important. Going from a place where "null" is allowed to a place where "null" is forbidden is an accident waiting to happen. For this reason, "null" has been called "the billion-dollar mistake". (See https://en.wikipedia.org/wiki/Null_pointer#History.)

In some languages and/or for some contexts, nullable types are the default; in others, nullability is something that is explicitly mentioned. In Python, the equivalent of "null" is called ~None~, and any variable can usually be ~None~. (In Django models, nulls are forbidden by default.) JavaScript, of course, has two null-esque values, ~null~ and ~undefined~. In C and a lot of related languages (C++, Java, Go), there are "primitive" types which can never be ~NULL~ (you can't have a nullable int) and "pointer" types which are always nullable (you can't insist on a non-nullable object). A couple languages let you choose between nullable or non-nullable versions of any type (for example, in C#, you can have ~int?~ to describe a nullable int, although it seems all pointers can still be null).

In a language where things can be null, some people will "null-check" incoming arguments of every function and throw an exception if they're null. I personally don't like doing this, since:

- It adds a lot of boilerplate to all functions.
- You have to do it not just on incoming arguments, but anything returned from any function, unless you're sure that the function will never return a null (including in the future if someone modifies it).
- You're already going to get a ~NullPointerException~, even without code to explicitly check for nulls; you just get to change the ~NullPointerException~ into something that tells you *what* was null.

The "cutting edge" approach is called an "option" type, which is a tagged union (about which see below) where you either have ~Some(value)~ or ~Nothing~. See also https://en.wikipedia.org/wiki/Option_type. Because ~Some(value)~ is different from ~value~, you can never accidentally use an "optional" thing as though it were guaranteed to be present.

Nullable types are often used for:

- Data that might be missing.
- Functions that can "fail" in a soft way -- where no answer is possible.
*** Compound
These are choices for when you need to model something more complicated than a single datum. Note that these structures are all composed, themselves, of structures, so you can "nest" them, or combine them like Legos into ever more complicated possibilities. (For example, "a list of departments, each of which is a map of strings to people records".)
**** Record
A record type lets you define a new kind of "data", usually by putting together existing kinds of "data". A record type defines a "format" which consists of several fields, each with its own type. You can then create records of this type which necessarily conform to this format.

In a procedural language like C, this is called a struct. In a classical object-oriented language, these are your classes and your instances. In some languages, tuples can be considered a kind of simplistic record type. (In Python, tuples are more like lists, which are collections -- about which see below.) In a database system, record types are like tables, and records themselves are the rows in that table.

A classic example of structs would be something like a two-dimensional point on the screen, which could be defined as something like:

#+begin_src c
struct Point {
    int x;
    int y;
}
#+end_src

In other words, a point has an (integer) x coordinate and an (integer) y coordinate. You can't have a point without both, and a point can't be created with any additional information.

Records are good for:

- Combining related data together.
- Combining data of different types together. If you have a fixed number of different things, you have a record. If you have lots of the same kind of thing, you don't have a record, you have a list.
- Combining data with the set of operations that can be performed on it. A common use of records is to let you "encapsulate" some kind of internal state while exposing only well-defined operations to other code.

Records are one of the main ways to define new abstractions, letting you create a thing closer to some real-world or domain-specific concept rather than always considering the nitty-gritty of what has to happen. For this reason, they are also sometimes overused; the Gang-of-Four book "Design Patterns" describes mechanisms you can use to solve lots of different problems in a language like Java that has nothing but classes. Many of these "patterns" are foreign or disappear completely in other languages. Many of the problems that these patterns try to solve are solved simpler using e.g. functions.

Instead of records, you can equivalently store data in "parallel arrays". In this scheme, you don't define e.g. an array of people, each of which has a name, an address, and an age, but instead you define an array of names, an array of addresses and an array of ages. Although this is equivalent, it's very rare that this is a good idea.
**** Tagged union
Some modern languages (Rust, Haskell, Swift) have a kind of enum-esque functionality where you define not only the possible cases, but additional information that goes with it. Sometimes these are referred to as "tagged unions" or "tagged constructors". As an example, let's say we let our users specify colors using either a "named" color like ~blue~, or a hex-encoded color like ~#00ff00~, or an RGBA color like ~rgba(0, 255, 0, 0.1)~. You might represent this using something like:

#+begin_src rust
enum CSSColor {
  NamedColor(String),
  HexEncoded(i32, i32, i32),
  RGBA(i32, i32, i32, f32)
}
#+end_src

These kinds of structures are like a fusion of a record and an enum, and they're super neat when you have them available. Usually, to examine them and extract the useful data, you need some kind of "pattern-matching" operation.

If your language has tagged unions, odds are good that it has an option type instead of nullability (see above).
**** List
A list represents an ordered group of zero or more elements. A list does not have a fixed size and can grow or shrink over the course of a program.

In Python, this is the ~list~ class. In JavaScript, this is called ~Array~ (although it isn't a true array, about which more in a second). In C++ it's called a vector and in Rust it's called ~Vec~.

Some languages also expose a more basic ordered collection called an array which corresponds to a large block of computer memory with a fixed size. Unlike lists, arrays cannot grow or shrink. However, a list can be implemented using arrays -- when you need to grow the list, you copy everything to a new, bigger, array.

It's generally a good idea for all the elements in your list to be the same type (or offer some common functionality). If you have elements of different types, you probably want a record type.

Although a list has relatively few constraints, you can always try to use a list in a more restrictive way. As an example, you can maintain a sorted list by being careful where you insert elements. Having a sorted list may be valuable for certain kinds of algorithms (i.e. binary search).

Lists are a good fit when:

- You want to say "several" of something without saying anything else.
- You want to process a bunch of items in a uniform way.
***** List-like variations
Stacks and queues are a restricted version of lists where you can only insert and remove elements in certain places. In a stack, you insert ("push") and remove ("pop") only from one end, which creates a "last-in-first-out" order. In a queue, you insert ("enqueue") only at one end and remove ("dequeue") only from the other end, which creates a "first-in-first-out" order. These can be useful if you want to process elements in a certain constrained order. A good example is tracking nested elements, where a stack is almost always what you want.

A dequeue ("double-ended queue") is a list that supports inserts and removals from both ends and can be used as either a stack or a queue, depending on which ends you use for what.

A priority queue is a list where each element has a "priority". Removal of the "next" element produces the element with the lowest priority. This means that unlike a regular queue, elements that are added later might get removed (and thus processed) earlier.

Because all of these types are just lists but with fewer operations, they are mainly useful in code/architecture and not in data modeling (you'd just use a list instead).
**** Set
A set represents an unordered group of elements, with no element being repeated. You can use a set if you want to enforce that elements are unique (usually duplicate elements are silently dropped).

Mathematical "sets" also have certain popular operations which may be present -- union, intersection, subtraction -- but these operations can often be present on lists as well.

In Python, there is a built-in ~set~ class. If your language doesn't have a set type, the usual way to implement it is using a map (see below).
**** Map (associative array)
An associative array is a collection of key-value pairs. The key serves as an ID for the value: given a key, you can look up the value, but you may not be able to go from the value back to the key. In other words, it associates a value with a key. "Associative array" is kind of an unwieldy term, so this abstract data type is usually called a map or hash table instead. Each key can only be associated with one value -- inserting a second key-value pair with the same key will overwrite the first.

Python is unusual in that it calls this class ~dict~ or dictionary. (An English dictionary associates words, which are the keys, with definitions, which are the values.) In most other languages, "map" or "hash table" is used.

For most of JavaScript's history, an "Object" type was the closest thing available to a map. An Object is more correctly used in JavaScript to represent records, but because the syntax is very convenient, people still sometimes use "objects" as maps that can only have string keys. (These days, JavaScript also has a Map class.)

Maps are very versatile structures:

- Instead of a list, you can always use a map with an integer key. For this reason, some languages don't bother building lists or arrays but go straight to maps. PHP's "array" type is a map for this reason.
- If you don't have a "set" type in your language, you can use just the "keys" part of a map, ignoring the values.

Maps are a good idea when:

- You want to be able to look up a given value based on its ID.
- No two items can have the same ID. If you need to have key-value pairs where the key isn't unique, i.e. not really a key, then you can just use a list of pairs.
- You have keys of some type and values of some possibly different type. If your values are of different types, you might have a record. (N.B. Django template "contexts" are maybe an exception to this rule, where values are all just string-esque things.)
- You're using some record type and you want to add information to it, but you can't because it's an external library or otherwise "closed". You can use the record as the key, and the value can be whatever supplemental information you want to track. (N.B. Some languages have restrictions on what kinds of things can be keys, like they have to be hashable or orderable or whatever.)
**** Intermission: IDs
When your data model contains any kind of collection, you'll often need to find or refer to an element in that collection. In other words, you'll need to take some information and use it to uniquely identify some element. What you're doing is defining a thing that refers to an element, or a reference.

A reference must be permanent (it should never change, no matter what happens to the thing it refers to), and it must be unique (it should only ever identify one thing), and you almost always want every item to be "referable".

It might be possible that some element of the data uniquely identifies it, but this is vanishingly rare or maybe even impossible. (Apparently this is called a "semantic key".) Much more common is for a developer to think some field is guaranteed to be permanent until someone in Customer Satisfaction needs to edit it, or for some field to be "pretty unique" until management wants to be able to track the old owner AND the new owner of that phone number, or everyone needs to have a social security number until someone doesn't. For these reasons, when designing a way to refer to things, you almost always want to have an arbitrary ID as the reference. (This is apparently called a "technical key".) If you control the arbitrary ID and don't let it be a property of the data in any way, you can ensure that it is permanent (because why would you change it?), unique (because you control its generation), and mandatory (because you can assign one to everything).

If you're referring to an element in a list, you might be tempted to use its index as its ID. Be careful with this, because lists almost always change, which invalidates all the IDs. If you need permanent IDs into a structure, you probably want a map, using some kind of arbitrary ID as the key.

Most relational databases default to generating arbitrary IDs using integers that increase starting at 1. This has a certain convenience, but has some weaknessess too. In a distributed system, two machines could choose the "next" ID at the same time, which would cause a collision. Additionally, sometimes having IDs be predictable is a security weakness -- imagine SnapChat where you could see any post by starting at 1 and increasing until you ran out! So other systems use random numbers, or strings, or UUIDs, or something else. (See https://www.clever-cloud.com/blog/engineering/2015/05/20/why-auto-increment-is-a-terrible-idea/ for more on this.)

On the other hand, IDs are also one of the most "internal" parts of a system that users will still interact with, so choosing a good scheme for them can be a critical user interface decision.

Note that if you have a relatively small fixed set of IDs, you basically have an ~enum~. In that case, there may not be a need for an arbitrary ID.
**** Trees
A tree is a collection of nodes that has a certain recursive structure. A tree can be either an empty collection of nodes, or one node that has "children" trees (which themselves can be either empty or nodes that have trees, which themselves etc.). Trees show up in lots of places in computing -- a filesystem is a tree where folders can contain folders which contain folders, etc., and HTML elements contain children which are themselves HTML elements.

Trees are the focus of a lot of exercises in a data structures and algorithms course, and occasionally you will have a problem which is appropriate to model as a tree. The most common ones involve "folder"-like structures, or language-like structures (for example, a Python expression is either a number, or the addition of two expressions, which themselves are either numbers, or etc.).
**** Graphs
Graphs are probably the most complicated data structure that you might actually still use. A graph is a collection of nodes (usually called "vertices") plus a collection of connections ("edges") between those nodes. Sometimes these edges have additional information associated with them (a "label", "cost" or "weight").

Graphs are really useful for modeling networks of things. For example, the Interstate system is a network of roads connecting cities. The World Wide Web is a network of pages with links to other pages.

Graphs are also quite generic. A tree is just a graph with no cycles. Sometimes you will think you see a graph only to discover that because of some property of your data, you don't need something as complicated as a graph, but can instead get away with a list or something simpler.

Graph algorithms are usually quite specialized and relatively complicated (there are entire courses on "graph theory"), so we won't discuss them here, merely to point out that they exist in case you need them.
*** Bonus: Functions
Although we usually think of code and data as fundamentally different, in some ways they're two sides to the same coin. Code is just data that is interpreted by a processor, and data is code which produces information.

Sometimes your code needs input that is so open-ended that there isn't any way to encode it using any number of options. For example, maybe you want to write code that reads integers from a file and "does something" with them. Sometimes that "something" might be to take the biggest, sometimes it might be the smallest, sometimes it might be the one that occurs the most often, sometimes it might be the average. One way to implement this would be to encode each of these possibilities as ~enum~ s, but this limits you to supporting only the options you anticipated, and forces your code to handle all of them at once, which can add a lot of complexity to your code.

Another alternative is to let the user give you code that says what to do with the integers. The natural way to do this in most languages is for them to pass a function. Your function can call the user's function and use what it returns. If you can get yourself in the right mindset, this a very powerful technique.

This technique works in both directions -- rather than write a function "with a hole in it" that does a whole task, you can write several functions that contain the pieces, and let the user call them in whatever order they want. If you write code that a user calls, you've written a library; if you are calling code that a user wrote, you've written a framework.

When functions are part of an interface, you're inherently limiting the use of that interface to people who can write code. For this reason, it's pretty rare that you use functions to represent anything that an end user interacts with. But functions do turn up in the interfaces that programmers use (and offer to other programmers).

Functions don't go under "Basic" data structures because in a theoretical sense, they are the most complicated possible data structure. But in another sense, they're also very fundamental. There's a whole school of thought (called "functional programming") emphasizing this pattern and its use in structuring programs.
*** See also
- https://en.wikipedia.org/wiki/Abstract_data_type
- https://en.wikipedia.org/wiki/Collection_(abstract_data_type)
- https://www.youtube.com/watch?v=IcgmSRJHu_8 (This is Elm, but a great talk. Between 18m-21m or so, it becomes very Elm-specific, but the basic ideas are cross-language.)
- https://www.slideshare.net/ScottWlaschin/domain-driven-design-with-the-f-type-system-functional-londoners-2014/93 and subsequent slides
** Asynchrony in JS
We use a lot of anonymous functions in JavaScript, but there's no real reason they *need* to be anonymous. For example, let's say I have the following (synchronous) code:

let flour = getEggs();
let water = getWater();
let yeast = getYeast();
let dough = mix(flour, water, yeast);
let risenDough = allowRise(4, dough);
let bread = bake(risenDough, 425);

Let's say getEggs, getWater, and all the rest are asynchronous. They can't return their results immediately, but have to go get them for a while first. So they need to know what to do when they have the results. How do we express "a thing to do"? As code. How do we pass code as an argument? Wrap it in a function. So maybe we write something like this:

function bakeRisenDough(risenDough) {
  bake(risenDough, 425);
}

function allowRiseAndThenBakeDough(dough) {
  allowRise(4, dough, bakeRisenDough);
}

function getWaterAndYeastAndMixAndAllowRiseAndThenBakeDough(flour) {
  function getYeastAndMixAndAllowRiseAndThenBakeDough(water) {
    function mixAndAllowRiseAndThenBakeDough(yeast) {
      mix(flour, water, yeast, allowRiseAndThenBakeDough);
    }
    getYeast(mixAndAllowRiseAndThenBakeDough);
  }
  getWater(getYeastAndMixAndAllowRiseAndThenBakeDough);
}

getFlour(getWaterAndYeastAndMixAndAllowRiseAndThenBakeDough);

Kind of a drag, isn't it? We have all these meaningless functions that only exist to string together other meaningless functions. When you have functions like this, you might consider whether the names of the functions are really adding that much. If they aren't, then maybe we can do without them. Since each function is only used once, we might not define them inline instead:

getFlour(function(flour) {
  getWater(function(water) {
    getYeast(function(yeast) {
      mix(flour, water, yeast, function(dough) {
        allowRise(4, dough, function(risenDough) {
          bake(risenDough, 425);
        });
      });
    });
  });
});

This kind of sucks too, but this is the best we've got with the tools we've seen so far. This is how asynchronous programming in JS was done for a long time. Given these tools, I'd probably write a mix of these two things -- maybe extract allowRiseAndBakeDough, but leave the rest the same.

This isn't the only approach to expressing asynchrony in computer languages. In some languages, there's a concept of "threads", which sort of allow the possibility of continuing to write straightforward synchronous-looking code, but with execution happening in multiple spots at once. The problem is that different threads can interact in many different ways, and a programmer may not always have anticipated all of them.

JavaScript decided not to include threads. The next mechanism they introduced for asynchronous programming was called promises, and they're a little nicer than this kind of "callback hell". We'll talk about them a bit more next time.
** Low-level code refactors
To refactor code means to change its structure while preserving its behavior. You refactor code when it works but it doesn't support what you want to do. This might happen after you've bashed out some code for the first time, or when you come back to it after learning more about the project the code belongs to. Some refactors can be quite involved and intense where responsibilities move from one section of code to another, or things are separated out from other things. Make sure you have a good test suite before you embark on these!

There are also a bunch of simple "micro-refactors" which are relatively obvious. To get you to start thinking in these terms, here is a list with a few. I've named each one, but I'm not really clear on which names might make sense to other people and which might not. (However, the term "extract" does seem to be relatively well-understood.) I'm hoping that once you start to see them, you'll see them everywhere.

The ones in these list mostly focus on small code-level changes. Maybe later we can talk about those more involved refactors that talk about moving functions from one place to another, changing the relationship between two pieces of code, changing the arguments given to functions, etc.
*** Extract constant
Before:

#+BEGIN_SRC javascript
let x = 5 * 8;
console.log("An octagon with radius 5 has perimeter", x);
#+END_SRC

After:

#+BEGIN_SRC javascript
const RADIUS = 5;
const SIDES = 8;
let x = RADIUS * SIDES;
console.log("An octagon with radius", RADIUS, "has perimeter", x);
#+END_SRC

You almost always want to name "magic numbers" like this!
*** Extract constant/variable as parameter
Before:

#+BEGIN_SRC javascript
function greetUser() {
  const username = "George";
  console.log("Hello, " + user);
}

greetUser();
#+END_SRC

After:

#+BEGIN_SRC javascript
function greetUser(username) {
  console.log("Hello, " + user);
}

const username = "George";
greetUser(username);
#+END_SRC

This can make a function more flexible, analogously to extracting the constant/variable itself.

Sometimes it's important to move the source of information into/out of a function based on what part of the codebase should be "responsible" for it. This particular transformation moves the responsibility for the username outside of the function (~username~ is now provided to the function), and reversing the transformation moves the responsibility back into the function. (This is still true even if, say, ~greetUser~ calls a function to get ~username~.)
*** Extract expression as variable
Before:

#+BEGIN_SRC javascript
const LENGTH = 10;
const WIDTH = 20;
console.log("The area of the rectangle is", LENGTH * WIDTH);
#+END_SRC

After:

#+BEGIN_SRC javascript
const LENGTH = 10;
const WIDTH = 20;
const AREA = LENGTH * WIDTH;
console.log("The area of the rectangle is", AREA);
#+END_SRC

Any expression you repeat more than once should probably be a function or a variable. Some compilers can notice when you re-use an expression and only compute it once -- this is called common subexpression elimination, or CSE.

If something is only used once, it can sometimes be valuable to do the reverse of this refactor, i.e. put the expression in directly and get rid of the variable.

Other examples:

Before:

#+BEGIN_SRC javascript
console.log("The area of the rectangle is", 15 * 2);
console.log("The area of the rectangle is", 3 * 9);
#+END_SRC

After:

#+BEGIN_SRC javascript
function logRectangle(length, width) {
  console.log("The area of the rectangle is", length * width);
}
logRectangle(15, 2);
logRectangle(3, 9);
#+END_SRC

Normally, a repeated expression produces the same value, which means it can be stored in a variable. However, in the general case, you may have repeated code. Code can't be extracted as a variable, but it can be extracted as a function.

Before:

#+BEGIN_SRC javascript
button1.addEventHandler('click', function() {
  console.log("Click received:", this.value);
});
button2.addEventHandler('click', function() {
  console.log("Click received:", this.value);
});
#+END_SRC

After:

#+BEGIN_SRC javascript
const myButtonHandler = function() {
  console.log("Click received:", this.value);
}
button1.addEventHandler('click', myButtonHandler);
button2.addEventHandler('click', myButtonHandler);
#+END_SRC

Drawn from a real-life situation! Here is an interesting example where although it "feels" like we are extracting code, in actual fact we can get away with extracting a "variable", which is just a function.
*** Rename variable or function
Before:

#+BEGIN_SRC javascript
let controller = {};
controller.ethan = "trustno1";
#+END_SRC

After:

#+BEGIN_SRC javascript
let passwords = {};
passwords.ethan = "trustno1";
#+END_SRC

Naming things well is very hard. It can be very helpful to change names when you think of a better one.

Changing a local variable's name should always be safe. (By definition, if it's local, it can't be seen outside the function.) Renaming a global variable, a member variable, or a function means renaming it in every place it's being used. In more dynamic languages (like JavaScript!) it may not be possible to know definitively if something is being used or not (because things can be looked up dynamically at runtime), so you may have to test to make sure everything still works OK.
*** Several Boolean refactors
These are usually most useful when targeting the condition of an ~if~ statement or a loop, but can apply to any expression that manipulates Booleans:

- Negating a negation cancels out. So, ~!(!x)~ is the same as ~x~ -- if ~x~ is truthy, then ~!(!x)~ will have the same truthiness value as x. N.B. However, in JS, sometimes ~!!x~ is used as a shorthand way to convert something to a Boolean.

- De Morgan's laws: ~!(x && y)~ is ~!x || !y~, and ~!(x || y)~ is ~!x && !y~.

- ~x && true~ is the same as ~x~. ~x && false~ is the same as ~false~.

- ~x || false~ is the same as ~x~. ~x || true~ is the same as ~true~.

- More at https://en.wikipedia.org/wiki/Boolean_algebra.

- Also keep in mind the opposites of common comparisons: ~!(x > y)~ is the same as ~x <= y~, and vice versa.

Before:

#+BEGIN_SRC javascript
let userIsNew = ....;
let emailIsValid = ....;
if (!(emailIsValid || !userIsNew)) {
  console.log("Can't register as new user with invalid email");
} else {
  // User is old so email doesn't have to be valid
}
#+END_SRC

After:

#+BEGIN_SRC javascript
if (!emailIsValid && userIsNew) {
  console.log("Can't register as new user with invalid email");
} else {
  // User is old so email doesn't have to be valid
}
#+END_SRC

Sometimes it also helps to reframe your variables -- instead of having ~let emailIsValid = whatever;~, consider doing ~let emailIsInvalid = !whatever;~. Or the other way around.

*** Flipping if/then
Before:

#+BEGIN_SRC javascript
if (condition) {
  // Do something
} else {
  // Do something else
}
#+END_SRC

After:

#+BEGIN_SRC javascript
if (!condition) {
  // Do something else
} else {
  // Do something
}
#+END_SRC

This can be handy in combination with the Boolean refactoring laws above. Or sometimes you find yourself with something like:

#+BEGIN_SRC javascript
if (condition) {
} else {
  console.log("OK, this is a thing we want to handle somehow");
}
#+END_SRC

If the ~then~ part is completely empty, you don't actually care about the condition -- you're checking for the inverse of the condition, and you can switch it around into:

#+BEGIN_SRC javascript
if (!condition) {
  console.log("OK, this is a thing we want to handle somehow");
} else {
}
#+END_SRC

And then drop the ~else~ entirely (as with other refactors, below):

#+BEGIN_SRC javascript
if (!condition) {
  console.log("OK, this is a thing we want to handle somehow");
}
#+END_SRC

N.B. Some languages (most notably Perl) offer some interesting control flow statements, such as ~unless (condition)~, which is the same as ~if (! condition)~, and ~until (condition)~, which is the same as ~while (! condition)~.
*** Collapse if
Before:

#+BEGIN_SRC javascript
f(1);
if (condition) {
}
f(2);
#+END_SRC

After:

#+BEGIN_SRC javascript
f(1);
f(2);
#+END_SRC

An empty ~if~ statement can simply be left out!

Similarly:

Before:

#+BEGIN_SRC javascript
f(1);
if (condition) {
  f(2);
} else {
}
#+END_SRC

After:

#+BEGIN_SRC javascript
f(1);
if (condition) {
  f(2);
}
#+END_SRC

An empty ~else~ block can also just be dropped.
*** Combine branches
Before:

#+BEGIN_SRC javascript
if (condition) {
  f();
  // Other stuff..
} else {
  f();
  // More stuff..
}
#+END_SRC

After:

#+BEGIN_SRC javascript
f();
if (condition) {
  // Other stuff..
} else {
  // More stuff..
}
#+END_SRC

You can also pop stuff out at the end of the ~then~ / ~else~:

#+BEGIN_SRC javascript
if (condition) {
  // Other stuff..
  f();
} else {
  // More stuff..
  f();
}
#+END_SRC

Becomes:

#+BEGIN_SRC javascript
if (condition) {
  // Other stuff..
} else {
  // More stuff..
}
f();
#+END_SRC

Using this sometimes lets you shrink either the ~then~ or the ~else~ case down to nothing, at which point you can drop it (as above).

Sometimes it can be helpful to reverse this refactor -- split something into two different branches to make them behave slightly differently, or do them in different orders.
*** Unconditional conditions
Before:

#+BEGIN_SRC javascript
if (true) {
  // True then
} else {
  // True else
}

if (false) {
  // False then
} else {
  // False else
}
#+END_SRC

After:

#+BEGIN_SRC javascript
// True then
// False else
#+END_SRC

N.B. Sometimes you'll see something like this:

#+BEGIN_SRC javascript
const DEBUG = false;
if (DEBUG) {
  // Some stuff
}
#+END_SRC

This is set up so that if you want more debugging output, you can just change the DEBUG constant at the top of the file. In this case, don't go to the trouble of taking out all the ~if~ blocks -- usually a compiler or something like that will do it for you, and/or it won't hurt anything to leave them in.
*** Early exit
This is kind of a combination of the "flipping if/then" and "collapse if" refactors (above), but in the context of a function.

Before:

#+BEGIN_SRC javascript
function doSomething(c) {
  if (condition) {
    // Do stuff
    // Sometimes this is really long stuff
    // and it takes up lines and lines
    // to the point where you don't even
    // remember what condition you were in
    // or if it's still relevant...
    // Oh OK I guess we're done
  }
}
#+END_SRC

After:

#+BEGIN_SRC javascript
function doSomething(c) {
  if (!condition) {
    return;
  }

  // Do stuff
  // Sometimes this is really long stuff
  // and it takes up lines and lines
  // to the point where you don't even
  // remember what condition you were in
  // or if it's still relevant...
  // Oh OK I guess we're done
}
#+END_SRC

Lots of times you'll have some kind of condition which you need to check. If the condition isn't true, your whole function (or a large fraction of it) doesn't make sense. I like to return early in these kinds of cases. I find that the code tends to read clearer as "here is an invalid case; abort when this happens" instead of "here's the only valid case". I sometimes lose track of the conditional, so when we get to the end of the function I'm like "wait, two closing brackets, why?? what were we in the middle of? do I need to handle something else now that the if statement is done?" Also pulling the body outside of the if statement lets you save a layer of indentation, which I usually prefer.

N.B. Some grognards insist that functions should only have one exit point, so prefer the "before" form. This may be a leftover habit from C, where you need to explicitly clean up anything you allocated as part of your function. See [[http://wiki.c2.com/?SingleFunctionExitPoint][SingleFunctionExitPoint]] on Wiki Wiki Web. As with most stylistic quirks you encounter on the job, it's best to "do what the Romans do", even if you don't necessarily agree with it.
*** Unrolling a loop
Before:

#+BEGIN_SRC javascript
for (let i = 0; i < n; i++) {
  f(i);
}
#+END_SRC

After:

#+BEGIN_SRC javascript
f(0);
f(1);
f(2);
f(3);
f(4);
// ...
f(n);
#+END_SRC

You probably won't actually see this in your day-to-day work. It sometimes comes up when optimizing code that has to be very very fast. It has come up enough that there's a name for it: https://en.wikipedia.org/wiki/Loop_unrolling . Much more likely is that you'll be doing the reverse of this transformation.
*** Extending a loop
Before:

#+BEGIN_SRC javascript
for (let i = 0; i < n; i++) {
  f(i);
}
f(n);
#+END_SRC

After:

#+BEGIN_SRC javascript
for (let i = 0; i < n + 1; i++) {
  f(i);
}
#+END_SRC

If you see some code that looks similar to code inside a loop, you can sometimes incorporate it into the loop itself. The reverse can also be useful sometimes if you need to make the bounds line up for whatever reason.

Variation (extend at the beginning):

Before:

#+BEGIN_SRC javascript
f(-1);
for (let i = 0; i < n; i++) {
  f(i);
}
#+END_SRC

After:

#+BEGIN_SRC javascript
for (let i = -1; i < n; i++) {
  f(i);
}
#+END_SRC

An example from a real linked list problem:

Before:

#+BEGIN_SRC javascript
f(head);
let p = head.next;
while (p !== null) {
  f(p);
  p = p.next;
}
#+END_SRC

This turned out to cause a bug because sometimes ~head~ was null (so ~head.next~ was crashing).

After:

#+BEGIN_SRC javascript
let p = head;
while (p !== null) {
  f(p);
  p = p.next;
}
#+END_SRC
*** Anti-patterns
Don't do these -- people online will make fun of you.

The "[[http://thedailywtf.com/articles/Switched_on_Loops][for-case loop]]" a.k.a. the "[[https://en.wikipedia.org/wiki/Loop-switch_sequence][loop-switch sequence]]":

#+BEGIN_SRC javascript
for (let i = 0; i < 10; i++) {
  if (i == 0) {
    // Do something interesting for 0
  } else if (i == 1) {
    // Use 1 to do something interesting
  } else if (i == 2) {
    // .. and so on ..
  } else {
    // Do the 9th interesting thing
  }
}
#+END_SRC

The "loop" here isn't actually repeating any action. This is actually a sequential process that's been forced into a strange looping construct. Instead do:

#+BEGIN_SRC javascript
// Do something interesting for 0
// Use 1 to do something interesting
// .. and so on ..
// Do the 9th interesting thing
#+END_SRC

There's no crime in writing out a sequence of operations if they really are sequential and have nothing to do with each other.

If at first you don't succeed, try, try, and then stop:

#+BEGIN_SRC javascript
let success = doSomething();
if (! success) {
  success = doSomething();
  if (! success) {
    success = doSomething();
  }
}
#+END_SRC

Obviously this could conceptually go on forever. But there's no real reason these things need to be nested like this -- this is actually a looping process that's been written out as a strange nested if-then.

#+BEGIN_SRC javascript
let success = false;
while (! success) {
  success = doSomething();
}
#+END_SRC

N.B. From a theoretical perspective, there's only ever two ways failure can be handled: by trying forever, or by aborting. Be sure you are OK with whichever one you choose. (There are lots of other options that boil down into one of the two options. For example, "Try five times, then give up" just means "Try and on failure give up, except that 'failure' is defined as a sequence of five specific failures.")
*** Exercises for the reader
Try to clean up this messy function. It's meant to be part of a banking system. You can certainly clean up the first if-then-else statement by straightening out the condition and merging common stuff between the two branches. For the second if statement, use an early-exit to clarify. Consider renaming the parameters (which I chose to be deliberately obtuse).

#+BEGIN_SRC javascript
let balance = 1000;
function cashCashCash(x, t) {
  if (!(x > balance || !t)) {
    console.log("Sending", x, "to", t);
    balance -= x;
  } else {
    balance -= x;
  }
  if (balance < 0) {
    console.log("Currently in debt", -balance);
    if (transferDest) {
      console.log("Maybe you shouldn't have sent that money to", t);
    }
    sendEmail();
  }
}
#+END_SRC

Try to condense the two similar-looking code blocks below into a single function being called twice. Then, try to clean up the conditional inside the ~for~ loop (it isn't really needed).

#+BEGIN_SRC javascript
console.log("Calculating results for George");
for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) {
    f(i, "George");
  } else {
    g(i);
  }
}

console.log("Calculating results for Henry");
for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) {
    f(i, "Henry");
  } else {
    g(i);
  }
}
#+END_SRC
** Future topics
Local variables
Dynamic typing
Tuples and how they differ from lists
Why I hate CSS
Intro to web security: XSS, injection attacks, encryption?
** Future refactors
*** "Switch" into dynamic dispatch
Before:

#+BEGIN_SRC javascript
function doSomethingForTypeOne() {
  // ...
}

function doSomethingForTypeTwo() {
  // ...
}

if (obj.type == 1) {
  doSomethingForTypeOne();
} else if (obj.type == 2) {
  doSomethingForTypeTwo();
}
#+END_SRC

After:

#+BEGIN_SRC javascript
typeOne.prototype.doSomething = function() {
  // ...
}

typeTwo.prototype.doSomething = function() {
  // ...
}

obj.doSomething();
#+END_SRC

This is a classic object-oriented refactor -- see e.g. [[https://refactoring.guru/replace-conditional-with-polymorphism][replace conditional with polymorphism]]. There's also another style where you look up the functions yourself:

#+BEGIN_SRC javascript
const doSomethingByType = {
  1: doSomethingForTypeOne,
  2: doSomethingForTypeTwo
};

doSomethingByType[obj.type]();
#+END_SRC

The object-oriented version of this is sort of hiding the hash table in the dynamic dispatch.
*** "before"/"end" into wrapper function
This shades into "design pattern" territory.

Before:

#+BEGIN_SRC javascript
setUp();
doSomething1();
cleanUp();

setUp();
doSomething2();
cleanUp();
#+END_SRC

After:

#+BEGIN_SRC javascript
function withResource(f) {
  setUp();
  f();
  cleanUp();
}

withResource(doSomething1);
withResource(doSomething2);
#+END_SRC

If you have some kind of "resource" that needs to be cleaned up, or some kind of logic that absolutely needs to be run "after" certain things, and you're afraid people will forget it, you can write a wrapper function to enforce that it gets called. This is most powerful when the result of the set up is somehow required for the ~doSomething~ functions. Some languages have other mechanisms for enforcing cleanup that don't require closures like this: in C++, there's a technique called [[https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii][RAII]] ([[http://wiki.c2.com/?ResourceAcquisitionIsInitialization][RAII on Wiki Wiki Web]]) and in Python there's [[https://en.wikibooks.org/wiki/Python_Programming/Context_Managers][context managers]].
** Linked lists
*** Disclaimer
This is one of those topics you tend to learn in an undergraduate computer science curriculum and use rarely afterwards. My covering it in this reading group does not constitute an endorsement of its importance or the choice to include it in a typical curriculum. We're covering it because:

- For pedagogical reasons. Linked lists are a useful "jumping off point" for studying certain data structures and algorithms topics. (Although, typically we start with sorting algorithms, because those let you explore the same topics without having to talk about data structures on top of it.)
- They're a useful "shibboleth", a concept that interviewers will use as a shorthand to verify that you have computing knowledge. It's not fair, but being able to talk knowledgeably on this specific subject can convince someone that you know a lot about computer programming more generally.
- It happens to be a topic around which lots of Codewars problems are written.
- Some programming languages use linked lists a lot and it's good to recognize them.
- Linked lists happen to be an interesting application of recursion (which is probably why they are also relevant to a lot of Codewars problems).
- Under certain somewhat rare cases, linked lists are actually useful. (Any time you want to remove stuff from the middle or the beginning.)
*** Background
In order to understand linked lists, it's probably best to start with some systems-level stuff about your computer's memory. Memory is like a giant rack of cubbies, like the PO boxes at a post office. Each one is small enough to hold one thing, and you can go into any of them equally easily (at least, from the back; PO boxes are usually locked). Each cubby has a number on it, so you can talk about the cubbies with your friends ("check out what's in #108") and find the one you want without having to count them one at a time. This kind of memory is called "random-access". (Some kinds of memory are sequential-access, but they're outside the scope of this discussion. Think of old-school cassette tapes. These kinds of memory are not in as much use these days.) Each PO box has a number inside it -- nothing more or less.

This PO box metaphor corresponds to bytes of RAM. Each byte of RAM has an "address". Addresses start at zero and increase linearly. Each byte can only hold a number. Any byte can be accessed directly.

Sometimes you'll need to store a bunch of things next to each other. One way is to try to reserve a block of PO boxes, say numbers 104-132. This gives you room for 29 items. This is basically how arrays work. If you want to get the 5th item, you can use your knowledge of the block of PO boxes to say "Well, the first one is 104, so the fifth one must be 108", and jump directly there.

This is great until you need to add or remove items. Our block of PO boxes is exactly 29 items long. If we need to store more items than this, we need a bigger chunk of boxes. So when we add the 30th item, we have to find a bigger block of boxes, and (once we find it) copy everything over, one item at a time. This "resize" operation is relatively expensive, so we'd like to not do it that often.

What if we have *less* than 29 things? Do we need to resize here too? Well, actually, there's a trick. If you can afford to give up a PO box, you can use the first PO box to keep track of how many things you have, and know that only that many of them are in use, and the ones after are empty. (So, for instance, if box 104 says "10", then we know that boxes 105-114 are in use.) In this way, we can have an array that "grows" a little bit, until it can't grow any more, and then it resizes. Sometimes this is called a "vector" (which is a confusing name, I know).

All the PO boxes contain numbers. But the PO boxes are themselves numbered! So one PO box can store the number of another PO box (or, again, in the lingo, its "address"). The term for this is a "pointer". We'll see why this is useful in a minute.
*** Linked list
Instead of blocking off a giant chunk of PO boxes for your array of numbers, you can allocate just two. The first box (say, #104) will store the first number in your array (let's say it's 15). The second box (#105) will store the number of some other box (let's say it's #258), at which there are another pair of boxes, storing again another number in the array, and then another address. So you end up with something that looks like:

| Box | Contents    |
| ... |             |
|  24 | 4           |
|  25 | 0           |
|  26 | [unrelated] |
|  27 | [unrelated] |
|  28 | 1           |
|  29 | 38          |
|  30 | 3           |
|  31 | 24          |
|  32 | [unrelated] |
|  33 | [unrelated] |
|  34 | [unrelated] |
|  35 | [unrelated] |
|  36 | [unrelated] |
|  37 | [unrelated] |
|  38 | 2           |
|  39 | 30          |
| ... |             |

Our linked list starts at PO box 28-29. 28 is the first element, the number 1. 29 points to the next PO box, which is #38. 38 contains the next element of the list, 2, and 39 points to the next PO box. 30 contains the next element, 3, and #31 points to the next PO box, which is 24. 24 contains the next and final element of the list, 4, and #25 points to the next PO box. We use 0 to represent "no further elements". Our linked list contains the numbers 1, 2, 3, and 4, but spread out throughout memory.

Each pair of boxes is a "node" in the linked list, and by jumping from node to node, you can retrieve all its elements. The linked list is a chain organized by "next" pointers. Note that PO boxes do not have to be next to each other or indeed even "in order" (from the perspective of its contents)!

Sometimes this same list is drawn as a series of boxes, something like https://commons.wikimedia.org/wiki/File:Linked_list_data_format.jpg. Each box represents a node, which has two parts -- its actual data (in this case, the numbers 1 through 4) and the pointer to the next node.
*** Implementation in JS
You can think of a node in the linked list as a pair of things: some "data", and a pointer to the next node, usually called "next". In JavaScript, we can represent a node as an object, something like this:

#+BEGIN_SRC javascript
let linkedList = {
  data: 1,
  next: ...
};
#+END_SRC

Some languages (such as C) include the concept of pointers directly. JavaScript isn't one of those languages, but actually almost every variable in JavaScript is secretly a pointer. So we could do this:

#+BEGIN_SRC javascript
let secondNode = {
  data: 2,
  next: null
};

let linkedList = {
  data: 1,
  next: secondNode
};
#+END_SRC

Or more concisely:

#+BEGIN_SRC javascript
let linkedList = {
  data: 1,
  next: {
    data: 2,
    next: null
  }
};
#+END_SRC

When we write it like this, it stops looking like a chain of things pointing to other things, and starts to look more like one thing contained inside another thing, but rest assured that it's all pointers internally.

Note that a "linked list" is just represented as its first node! We could add other stuff, but this is the essence of it.

We can write the "abstract definition" of a linked list as something like (N.B. pseudocode)

#+BEGIN_SRC javascript
class Node {
  data,     //  number, for instance
  next      //  Node
}
#+END_SRC

In other words, it's a recursive structure! But don't forget to account for the possibility of an "empty" linked list, which contains no elements. Pop quiz: how is that represented? You can work backwards -- a linked list with one element must be a Node, followed by an "empty" linked list.

A more complete definition in a language like Haskell would be something like:

#+BEGIN_SRC haskell
data List = Node a List | Null
#+END_SRC

Because recursion and functional programming are such a natural pairing, there's a long history of linked lists in functional programming languages (even though they are often less efficient -- see below). Sometimes you'll encounter the terms "nil" to mean the end of a linked list, and a "cons cell" for the "node" (for instance, see https://stackoverflow.com/a/2689376/6107066).

[In a language like C, recursive structures have to use pointers because the compiler needs to know how much space to reserve for each Node. If a Node can truly contain another Node, then that means each Node takes up as much space as a Node does, plus some bytes -- but that means Nodes are either inconsistently sized, or infinitely big. So instead we make the "next" a pointer, which is always a fixed size.]
*** Operations
Stop and think about these basic operations, and how you might do them in linked lists or arrays:
- Insert an element in the middle of the sequence
- Remove an element from the middle of the sequence
- Add an element to the end of the sequence
- Access the 10th element of the sequence

Some of these operations are cheaper in linked lists rather than arrays. However, one hidden consequence of arrays is that they're good for what is called "locality". If you're going to operate on one element of the array, the processor may guess that you are going to operate on others, and start to preload surrounding memory, which will make subsequent operations faster. With a linked list, the processor may still guess this and preload memory, but it will contain stuff you don't care about. For this reason, in practice, arrays are often faster (which is why Python lists and JavaScript arrays are implemented internally with arrays). But this could change if the balance between processor and memory speed changes.

Note also that this "optimization" came at a cost -- linked lists require twice as much memory to store the same stuff! This is because the "next" pointers take up space (whereas in an array, the "next" element is just the next box over). On the other hand, we didn't have to find a big block of contiguous memory, which can be useful sometimes.

http://www.codewars.com/kata/linked-lists-push-and-buildonetwothree is a Codewars problem for implementing a specific implementation of linked lists. It links (hah!) to a bunch of other problems where you get to implement the standard sorts of operations for linked lists. https://www.codewars.com/collections/fun-with-lists is similar. https://www.codewars.com/kata/convert-a-linked-list-to-a-string is another little linked list one. https://www.codewars.com/kata/zipwith-ii-lists is a bit more advanced, requiring you to implement "zipWith", which is a common higher-order function, on linked lists (rather than just arrays).

[Spoilers for the above: With this linked list structure, it's quite easy to insert or remove elements anywhere in the chain (you just have to change a couple pointers). This is very different from arrays, where you have to copy lots of elements around in order to operate in the middle (or even the beginning). However, this structure is not random access -- if I want to get to the 5th element, I have to follow 5 "next" pointers.]
*** Variations
If you take a data structures and algorithms class, you'll hear about differen flavors of linked list -- the kind that we describe here is a "singly linked" list, with each node pointing to the next. Other kinds include "doubly linked", which include pointers both forwards and backwards, and "circular", where the "next" pointer at the end goes back to the start. There aren't really major distinctions, but you can read about them a little bit on Wikipedia.
** Templates
*** Motivating example
Someone designed our website. They hand us HTML for two pages -- a "landing" page that looks like this:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <h1>Welcome to the jungle!</h1>
    <p>
      Welcome to the jungle.com design refresh. We hope you like it!
    </p>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

And a page for individual blog articles which looks like this:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li>Some blog article title</li>
      </ul>
    </header>
    <h3>Some blog article title</h3>
    <h4>by Fred Bloggs on August 12th, 2018</h4>
    <p>
      Blog content goes here. This is an article about some topic.
    </p>
    <p>
      Blog articles can have a lot of content. Here's more content.
    </p>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

Our job is to write a server program that renders both types of HTML depending on what page it is.

Exercise: take a minute to review the HTML above. Which pieces are the same in the two files? Which pieces are different?
*** Raw code
Let's try just writing code that assembles HTML out of strings.

#+BEGIN_SRC javascript
function renderMainPage() {
  let output = [];
  output.push("<html>");
  output.push("  <head>");
  output.push("    <link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" />");
  output.push("  </head>");
  output.push("  <body>");
  output.push("    <h1>Welcome to the jungle!</h1>");
  output.push("    <p>");
  output.push("      Welcome to the jungle.com design refresh. We hope you like it!");
  output.push("    </p>");
  output.push("    <footer>Copyright 2018 The Jungle.com.</footer>");
  output.push("  </body>");
  output.push("</html>");
  return output.join("\n");
}

function renderBlogPost(blogPost) {
  let output = [];
  output.push("<html>");
  output.push("  <head>");
  output.push("    <link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" />");
  output.push("  </head>");
  output.push("  <body>");
  output.push("    <header>");
  output.push("      You are here:");
  output.push("      <ul>");
  output.push("        <li><a href=\"/\">Home</a></li>");
  output.push("        <li>" + blogPost.title + "</li>");
  output.push("      </ul>");
  output.push("    </header>");
  output.push("    <h3>" + blogPost.title + "</h3>");
  output.push("    <h4>by " + blogPost.author.name + " on " + blogPost.publishDate + "</h4>");
  let paragraphs = blogPost.content.split("\n\n");
  for (let i = 0; i < paragraphs.length; i++) {
    output.push("<p>" + paragraphs[i] + "</p>");
  }
  output.push("    <footer>Copyright 2018 The Jungle.com.</footer>");
  output.push("  </body>");
  output.push("</html>");
  return output.join("\n");
}
#+END_SRC

Ugh! This is super gross. We had to mix HTML and JS. The HTML is encoded as JS strings which makes it almost unreadable. Not only that, there's a JS indentation which can be different from the HTML indentation so again it's really hard to match up what's supposed to close what. Front-end developers can often do some great stuff if they have access to the HTML and CSS, but here they can only touch "their" code by going through "our" code. This makes it much harder for them to do their work. What a disaster!
*** JSP/ASP/PHP
So instead let's define a kind of "template language". It will look mostly like HTML and it will have certain special non-HTML commands that we can use to embed code. In the late 90s, Microsoft came out with Active Server Pages, and in Java there was something called Java Server Pages, and around the same time PHP was starting to get popular, and it uses a similar style (although in PHP, *everything* is HTML, whereas in JSP-based applications, most things are Java, and JSP files are the exceptions).

Converting the "blog post" function above, we'd get something like this:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li><%= blogPost.title %></li>
      </ul>
    </header>
    <h3><%= blogPost.title %></h3>
    <h4>by <%= blogPost.author.name %> on <%= blogPost.publishDate %></h4>
    <% let paragraphs = blogPost.content.split("\n\n"); %>
    <% for (let i = 0; i < paragraphs.length; i++) { %>
    <p>
      <%= paragraphs[i] %>
    </p>
    <% } %>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

OK, this looks a little better. A web designer who is only familiar with HTML could probably work with this. There are some variables and stuff that would only get filled in later, but they could probably just work around that. It looks much more like HTML with a little bit of code sprinkled in.

How does it work? We can translate this kind of JSP into the previous function just by copying everything that isn't "special" into the function, and storing it in an output variable, like we did above. There are only two "special" constructs: ~<% foo %>~, which represents code that we put into the function directly, and ~<%= foo %>~, which represents an expression whose output we will concatenate into our function's rendered output.

Note that the JSP refers to a variable called ~blogPost~, but (unlike the function) there's no explicit "argument" to the JSP. Instead, templates like this have what's called a /context/, a set of variables which are made available to the template.

In the early '00s there were a proliferation of different template languages. Some are tied very tightly to rendering HTML, for example https://en.wikipedia.org/wiki/Template_Attribute_Language. Most aren't really used any more.
*** DRY
Unfortunately, we have a bunch of repetition in these pages, and (as you know) repetition hurts our souls. For example, on January 1st, we have to change the copyright date in the footer, which means we have to change every single JSP. So maybe we need to figure out a way to start sharing some of this code.

Let's imagine we had a function called ~render()~. This function could take the name of a template and return the rendered output of the template. In other words, it's a way to include one template in another template. Then we could define a ~header.jsp~ file like this:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
#+END_SRC

And a ~footer.jsp~:

#+BEGIN_SRC jsp
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

Now we can share those pieces in other templates. For example, our ~blogpost.jsp~ file might now look something like this:

#+BEGIN_SRC jsp
<%= render("header.jsp") %>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li><%= blogPost.title %></li>
      </ul>
    </header>
    <h3><%= blogPost.title %></h3>
    <h4>by <%= blogPost.author.name %> on <%= blogPost.publishDate %></h4>
    <% let paragraphs = blogPost.content.split("\n\n"); %>
    <% for (let i = 0; i < paragraphs.length; i++) { %>
    <p>
      <%= paragraphs[i] %>
    </p>
    <% } %>
<%= render("footer.jsp") %>
#+END_SRC

Now when we edit the footer, it takes effect everywhere, because the footer is actually shared.

Exercise: convert the home page to a JSP that uses the header and footer in the same way.

There are some problems with the above approach. For example, you could forget to include the footer and everything will "seem" fine. (You won't have the closing ~</body>~ and ~</html>~, but most browsers will automatically figure out that these tags should be closed, and will insert closing tags for you.) This means you have to check every page to remember to include the footer.

What about page titles? The ~<title>~ element has to go into the ~<head>~, which is defined in ~header.jsp~. One option might be to add the "context" to the ~render~ call:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
    <title><%= title || "Home page" %>
  </head>
  <body>
#+END_SRC

#+BEGIN_SRC jsp
<%= render("header.jsp", {title: "Blog: " + blogPost.title}) %>
... rest of the page ...
#+END_SRC

OK, but what about other stuff that we might want to add to the ~<head>~ element, like other CSS files or ~<meta>~ tags? Maybe we can add another "extra code" variable to the header:

#+BEGIN_SRC jsp
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
    <title><%= title || "Home page" %>
    <%= extraCode || "" %>
  </head>
  <body>
#+END_SRC

#+BEGIN_SRC jsp
<%= render("header.jsp", {
      title: "Blog: " + blogPost.title,
      extraCode: "<link rel=\"stylesheet\" type=\"text/css\" href=\"blog.css\">",
    }) %>
... rest of the page ...
#+END_SRC

This is starting to get us back to where we started, with HTML embedded in code, only now it's almost worse because we have HTML embedded in code embedded in HTML! Yuck.
*** Django style
Django templates were invented for the Django web framework and seem to have influenced lots of other systems (such as Twig and Nunjucks; Mustache and Handlebars also look a little similar but are apparently inspired by another system called ctemplates which was invented at Google). The ideas here were that we want to minimize the amount of actual code that happens in the template -- it should be (as much as possible) just pure layout and design, with the bare minimum of code permitted to allow the HTML to be written correctly. Django templates also introduced a new feature, called template inheritance, which helps us with the kinds of problems of extensibility we were facing before.

The syntax of Django templates is a little different from other languages. Instead of ~<%= expression %>~, you write ~{{ expression }}~. Also, you can have filters, which are sort of like functions that the template language provides: ~{{ expression|filter }}~. Instead of ~<% code; %>~, you write ~{% code %}~, but be careful because Django templates don't let you write arbitrary code -- only certain commands are allowed. So a simple definition of our blog post template might look like this:

#+BEGIN_SRC django-html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <header>
      You are here:
      <ul>
        <li><a href="/">Home</a></li>
        <li>{{ blogPost.title }}</li>
      </ul>
    </header>
    <h3>{{ blogPost.title }}</h3>
    <h4>by {{ blogPost.author.name }} on {{ blogPost.publishDate }}</h4>
    {% for paragraph in blogPost.content.split("\n\n") %}
    <p>
      {{ paragraph }}
    </p>
    {% endfor %}
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

Seems straightforward enough. What about the re-use problem (sharing the header and footer), like we saw before? For that, we have template inheritance. Template inheritance works a little bit like object-oriented programming does. First, someone defines a "layout", which is like a parent class. For our case, we might write a ~layout.dhtml~ file that looks like this:

#+NAME: layout.dhtml
#+BEGIN_SRC django-html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    {% block body %}
      This is the default content.
    {% endblock %}
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

We see that this is a "complete" Django template -- nothing is missing, nothing indicates in any way that this is a "parent" template. We can even render this template, and if we do, the ~{% block %}~ will render its contents, so we'll get:

#+BEGIN_SRC django-html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    This is the default content.
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

We can think of this "layout" template as turning into object-oriented like this:

#+BEGIN_SRC javascript
function Layout() {
}
Layout.prototype.render = function() {
  let output = [];
  output.push("<html>");
  output.push("  <head>");
  output.push("    <link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" />");
  output.push("  </head>");
  output.push("  <body>");
  output.push(this.renderBlockBody());
  output.push("    <footer>Copyright 2018 The Jungle.com.</footer>");
  output.push("  </body>");
  output.push("</html>");
  return output.join("\n");
};
Layout.prototype.renderBlockBody = function() {
  let output = [];
  output.push("This is the default content.");
  return output.join("\n");
};
#+END_SRC

In other words, each block becomes a method, but also simultaneously becomes a place where the method is called. This makes the block a "hook", something that we can attach to if we want to change the behavior of the template.

So how do we hook into it? We ~extend~ the template. We might write a ~homepage.dhtml~ file that looks like this:

#+NAME: homepage.dhtml
#+BEGIN_SRC django-html
{% extends "layout.dhtml" %}

{% block body %}
    <h1>Welcome to the jungle!</h1>
    <p>
      Welcome to the jungle.com design refresh. We hope you like it!
    </p>
{% endblock %}
#+END_SRC

This gets translated into something like this:

#+BEGIN_SRC javascript
// Implementing inheritance in "vanilla" i.e. pre-ES2015 JS. The details aren't super important...
function HomePage() {
  Layout.call(this);
}
HomePage.prototype = Object.create(Layout.prototype);
HomePage.prototype.constructor = HomePage;

// Override just the renderBlockBody function.
HomePage.prototype.renderBlockBody = function() {
  let output = [];
  output.push("<h1>Welcome to the jungle!</h1>");
  output.push("<p>");
  output.push("  Welcome to the jungle.com design refresh. We hope you like it!");
  output.push("</p>");
  return output.join("\n");
};
#+END_SRC

So now, when we render the home page, we start by rendering the parent template (in this case ~layout.dhtml~). That means we get the overall structure of the page first:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <!-- SPACE left here because this is where block body goes -->
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

But then, because the home page "overrode" the body block, we get its content instead of the content from ~layout.dhtml~. So we end up with:

#+BEGIN_SRC html
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="site.css" />
  </head>
  <body>
    <h1>Welcome to the jungle!</h1>
    <p>
      Welcome to the jungle.com design refresh. We hope you like it!
    </p>
    <footer>Copyright 2018 The Jungle.com.</footer>
  </body>
</html>
#+END_SRC

... which is where we started.

So why is this better?

- One problem we had before was that it was possible to ~render~ the header and forget to ~render~ the footer. Here, that's not possible -- if you extend a template, it surrounds you completely.

- Another problem we had was that we had very little flexibility in our templates. ~header.jsp~ could provide a way to set a title, but not much more than that. It was impossible to add HTML code to a "helper" template like ~header.jsp~. But now that we have blocks, it's easy to put empty blocks wherever we like and child templates can pick and choose the ones that make sense for them to override. Additionally, overriding a block takes place in the template, so we are free to directly add HTML rather than writing it as strings.

- Another nicety is that we can see the whole layout in one file, rather than having to piece it together between the ~header.jsp~ and ~footer.jsp~. If we forget to close a tag, it's more obvious, because both the opening and closing are in the same file.

This style of templating is very powerful! A parent can define blocks, and then a child can "fill in" those blocks, and it can even define its own blocks, that can be then filled in by grand-children, and so on. Anything can be a block if we want it to be. It's entirely up to us!

Note that there's nothing special about the blocks or their names -- ~body~ just happened to be a name I chose. The only thing that matters is that the blocks defined by the child fit into the blocks of the same name in the parent. Blocks aren't magically linked to an HTML element of the same name, and they don't have any intrinsic meaning. They just serve to let one template define some overarching structure, and to have another template "plug in" to that same structure.

We aren't limited in the number of blocks we define or where we put them. We can add one wherever we think a child template might want to override something. One good rule of thumb is to make sure that anything opened in a block gets closed in the same block.

Exercise: convert the blog post template to extend the layout we've defined.

Exercise: the home page should have a title of "Welcome to the Jungle", and the blog post pages should have a title of "Jungle Blog: Some Blog Post Title". How can we modify the templates to make this happen?

Exercise: what do we have to add to allow blog post pages to have an additional CSS file (~blogpost.css~) without it being present on the home page?
*** Next steps: client-side templating
These templating systems are typically used in server-side systems. In these systems, a request comes in, a bunch of information gets looked up, and we render that information to a response. That response contains HTML that's relatively static. We can sprinkle some JS on it for small stuff, but very complicated web applications that involve updating HTML will often go back to the server, since that's where the templates are.

Let's say we wanted to design an application that let us add elements to a shopping list. As we add each item, we need to add more HTML to the page. But we want the application to be AJAX. One possibility is to have the HTML on the client side instead of the server side. Then, we can render each item as we add it without having to consult the server.

This leads us to libraries like Mustache and Handlebars, which are designed to render templates in the browser.

Another nice thing would be to track changes to our variables in JS and automatically update the DOM. If the DOM is generated by the templates, then it should be easy to render them again with our data. This idea leads us to libraries like React and Vue.

React templates are usually written in a language called JSX, which is embedded in JS. A page might look like this:

#+BEGIN_SRC javascript
class HomePage extends React.Component {
  render() {
    return (
      <html>
        <head>
          <link rel="stylesheet" type="text/css" href="site.css">
        </head>
        <body>
          Welcome to the {location}!
          <MyFooter />
        </body>
      </html>
    );
  }
}

class MyFooter extends React.Component {
  function render() {
    return (
      <footer>Copyright 2018 The Jungle.com.</footer>
    );
  }
}
#+END_SRC

In JSX, elements are just written straight into the JavaScript code. Wait, isn't this where we started, and what we tried to get away from? Basically, yes. But in the meantime, the culture has changed -- instead of getting enormous blocks of HTML from some guy using Dreamweaver, the expectation is now that the front-end is code that is every bit as powerful and important as the stuff happening on the back-end.

A full treatment of React is outside the scope of this document, but it's worth pointing out some features of the syntax:

- Each React "component" defines its own ~render()~ function explicitly.
- The render function returns something like the DOM (specifically, it returns a tree of elements).
- A component can use other components by including it directly in its tree of elements.
- It's not possible to forget to "close" an element because the syntax reflects an HTML fragment, which means opening and closing tags are balanced.
- Instead of using ~{{ expression }}~, we do ~{expression}~.
- We can also use expressions as "attributes" to our elements, which is how we pass arguments to them.

If your application feels like it's too interactive for the old-fashioned "server-side framework which renders HTML which has some JS sprinkled on top", then you might end up using something like React. This ecosystem is still very young, though, and there are enough complications that it's not a decision to be made lightly. If you aren't sure whether your project is a good fit for something like React, ask a senior engineer.
** Normalization (SQL without Django)
A database is another piece of software which is in charge of storing and organizing data[1]. We are going to be using a kind of database called a "relational" database (specifically we're going to start by using PostgreSQL, but most databases that have "SQL" in the name function similarly).

You can think of a relational database as kind of like an Excel workbook. A relational database has "tables", which are like sheets in a workbook. Each table is a collection of rows, each of which has the same set of columns. So you might have a "people" table that looks like this:

| Person  | Number of pets | Signed up date |
| Ethan   |              1 |     2015-05-01 |
| Rita    |              0 |     2015-05-18 |
| Francis |              1 |     2015-05-08 |

And you might have another table that stores hobbies:

| Person  | Hobby        |
| Ethan   | Chiptune     |
| Rita    | British rock |
| Francis | Death metal  |
| Ethan   | Baking       |
| Francis | Kendo        |
| Rick    | Beer         |

If you had this data stored in a relational database, it would be possible to ask it to "put it together" and generate a table like this:

| Person  | Number of pets | Number of hobbies |
| Ethan   |              1 |                 2 |
| Rita    |              0 |                 1 |
| Francis |              1 |                 2 |

"Relational" is a long word so I'll probably use it interchangeably with "SQL" (pronounced "sequel"), even though technically the two things aren't exactly the same.

[1] This is a wild oversimplification, but "database" is a term that gets used a lot in a lot of contexts with subtly different meanings.
*** Example
#+BEGIN_SRC psql
CREATE TABLE people (
  name TEXT NOT NULL PRIMARY KEY,
  number_of_pets INTEGER NOT NULL,
  signed_up_date TIMESTAMPTZ NOT NULL
);
#+END_SRC

#+BEGIN_SRC psql
INSERT INTO people VALUES
  ('Ethan', 0, '2015-05-01 00:00:00'),
  ('Rita', 0, '2015-05-18 00:00:00'),
  ('Francis', 1, '2015-05-08 00:00:00');
#+END_SRC

#+BEGIN_SRC psql
SELECT * FROM people;
#+END_SRC

#+BEGIN_SRC psql
SELECT * FROM people WHERE name = 'Ethan';
#+END_SRC

#+BEGIN_SRC psql
UPDATE people SET number_of_pets = 2 WHERE name = 'Francis';
#+END_SRC

#+BEGIN_SRC psql
CREATE TABLE hobbies (
  person TEXT,
  hobby_name TEXT UNIQUE NOT NULL
);
#+END_SRC

N.B. There should really be a foreign key constraint here but the example includes Rick, who isn't in the "people" table...

#+BEGIN_SRC psql
INSERT INTO hobbies VALUES
  ('Ethan', 'Chiptune'),
  ('Rita', 'British rock'),
  ('Francis', 'Death metal'),
  ('Ethan', 'Baking'),
  ('Francis', 'Kendo'),
  ('Rick', 'Beer');
#+END_SRC

N.B. This table is sort of "freestanding" so it's not a problem that Rick doesn't "really exist" in the people table. In a real application, it probably would be!

Trying to compute the number of hobbies for each person:

#+BEGIN_SRC psql
SELECT person, COUNT(*) FROM hobbies GROUP BY person;
#+END_SRC

Combining info with the people table:

#+BEGIN_SRC psql
SELECT p.name, p.number_of_pets, COUNT(h.hobby_name) FROM people p, hobbies h WHERE p.name = h.person GROUP BY p.name;
#+END_SRC

N.B. This could be done using SQL's "join" functionality, but let's just do it by hand this time.

#+BEGIN_SRC psql
DROP TABLE people, hobbies;
#+END_SRC
*** Modeling
One of the most important things you do when you're developing an application is to think about what are the entities you're going to have in your application, how they relate to one another, and how you're going to store them. For example, in a hospital management system, you might have patients and doctors and rooms, and patients stay in rooms and doctors visit patients (but doctors don't stay in rooms). Once you have a clear idea of what the entities are, you structure your database to support that. In a SQL world, this means ~CREATE TABLE~ statements, but in a non-SQL world, it might mean defining functions to validate the data you put into/take out of the database.

Let's say we're trying to build an order system. Here's our first idea of what an orders table might look like. This tracks every order made in our system. (The following sections are written against a PostgreSQL database to get you some experience with it, but the same ideas can be expressed using a spreadsheet. I created one at https://docs.google.com/spreadsheets/d/1vwGf_5lq7o-xrT7hFrPR3-avSUXHD0GmmbCmVDuD5zY/edit#gid=877230314 that you can look at instead if you like.)
*** Denormalized first draft
#+BEGIN_SRC psql
CREATE TABLE orders (
  name TEXT,
  email TEXT NOT NULL,
  date TIMESTAMPTZ NOT NULL,
  items TEXT NOT NULL
);
#+END_SRC

#+BEGIN_SRC psql
INSERT INTO orders VALUES
  ('Ethan', 'ethan@example.com', '2018-10-01 00:00:00', '1245, 1234, 1221'),
  ('Rita', 'rita@example.com', '2018-10-02 00:00:00', '111234 , 1232'),
  ('Ethan', 'ethan@example.com', '2018-10-02 00:00:00', '1245, 1221'),
  ('Mike', 'mike@example.com', '2018-10-03 00:00:00', '1221, 1222, 1223'),
  ('Rita', 'ethan@example.com', '2018-10-04 00:00:00', '1254 1221'),
  ('Mike', 'mike@example.com', '2018-10-03 00:00:00', '1221, 1222, 1223');
#+END_SRC

#+BEGIN_SRC psql
SELECT * FROM orders;
#+END_SRC

#+BEGIN_SRC psql
DROP TABLE orders;
#+END_SRC
There are a couple of problems with this design:

- *Update anomaly.* We see that Rita has two different email addresses (or, to look at it another way, ~ethan@example.com~ has two different names). This seems bad -- an email address should be unique and owned by just one person. However, due to the structure of our database, it's possible to store this kind of inconsistent data. In particular, if we try to update Rita's email address, but we don't get all the rows, we will get this kind of garbage data.
- *Insertion anomaly.* It's not possible to store information for a user that didn't make an order.
- *Delete anomaly.* Relatedly, if we delete all of a user's orders, we have implicitly deleted the user, whether we wanted to or not.
- Mike's order appears twice. Is it a duplicate, or does it represent Mike actually placing two orders? What if we want to correct one but not the other? We won't be able to because the UPDATE command only lets us describe the rows in terms of their values.
- Items are just plain loose text. This makes it hard to count the number of items in each order, or to check for orders containing e.g. the item 1234.
*** An attempt at normalization
- Let's put an ID column on our orders table. That way we'll be able to distinguish whether Mike made two orders or it's a repeat of an existing order.
- Let's split up the items column. The "item" column should only store one number so that querying is easier. But then how do we represent an order with multiple items? We'll have to have multiple rows.
#+BEGIN_SRC psql
CREATE TABLE orders2 (
  id SERIAL,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  date TIMESTAMPTZ NOT NULL,
  item_id INTEGER NOT NULL
);
#+END_SRC

#+BEGIN_SRC psql
INSERT INTO orders2 VALUES
  (1, 'Ethan', 'ethan@example.com', '2018-10-01', 1245),
  (1, 'Ethan', 'ethan@example.com', '2018-10-01', 1234),
  (1, 'Ethan', 'ethan@example.com', '2018-10-01', 1221),
  (2, 'Rita', 'rita@example.com', '2018-10-02', 111234),
  (2, 'Rita', 'rita@example.com', '2018-10-02', 1232),
  (3, 'Ethan', 'ethan@example.com', '2018-10-02', 1245),
  (3, 'Ethan', 'ethan@example.com', '2018-10-02', 1221),
  (4, 'Mike', 'mike@example.com', '2018-10-03', 1221),
  (4, 'Mike', 'mike@example.com', '2018-10-03', 1222),
  (4, 'Mike', 'mike@example.com', '2018-10-03', 1223),
  (5, 'Rita', 'ethan@example.com', '2018-10-04', 1254),
  (5, 'Rita', 'ethan@example.com', '2018-10-04', 1221),
  (6, 'Mike', 'mike@example.com', '2018-10-03', 1221),
  (6, 'Mike', 'mike@example.com', '2018-10-03', 1222),
  (6, 'Mike', 'mike@example.com', '2018-10-03', 1223);
#+END_SRC

We still have the same anomalies from before, but it's at least better. This design meets something called *first normal form*. This is a weak form of normalization that is really meant to let us get stuff into a form that is handleable by a database.

#+BEGIN_SRC psql
SELECT DISTINCT id FROM orders2 WHERE item_id = 1234;
#+END_SRC

#+BEGIN_SRC psql
SELECT DISTINCT name FROM orders2 WHERE item_id = 1221;
#+END_SRC

#+BEGIN_SRC psql
DROP TABLE orders2;
#+END_SRC

[Side note: The Wikipedia example on the First Normal Form page walks us through a different attempt to try to resolve this. Let's say I created my table to be like this:

| Person | Email             |       Date | Item 1 | Item 2 | Item 3 |
| Ethan  | ethan@example.com | 2018-10-01 |   1234 |   1221 |   1245 |
| Rita   | rita@example.com  | 2018-10-02 | 111234 |        |        |

In doing this, I'm asserting that EVERY question have exactly 3 choices! Clearly they can't have more choices because there's no where to put them, but I'm also sort of implying that they can't have less choices because what will I put in the 3rd choice? Besides, this is bad form because it makes querying hard -- I have to check that e.g. item 1 is 1234 OR item 2 is 1234 OR item 3 is 1234 -- and generally we would prefer that columns not have any "order" to them.

In other words, notice that columns are *constant* in a relational model, so if you want to have a variable number of something, you have to turn those somethings into rows somehow.]
*** More normalized
Second and third normal forms are stricter than first normal form. The basic idea is to focus on "dependencies", which in this context refer to fields whose values should be determined entirely by other fields (from our example before, name should be determined by email). You remove these dependencies by pulling them into their own database.

#+BEGIN_SRC psql
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL
);
#+END_SRC

#+BEGIN_SRC psql
CREATE TABLE orders3 (
  id SERIAL PRIMARY KEY,
  customer_id SERIAL REFERENCES customers (id),
  date TIMESTAMPTZ NOT NULL
);
#+END_SRC

#+BEGIN_SRC psql
CREATE TABLE order_items (
  order_id SERIAL REFERENCES orders3 (id),
  item_id INTEGER NOT NULL
);
#+END_SRC

#+BEGIN_SRC psql
INSERT INTO customers VALUES
  (1, 'Ethan', 'ethan@example.com'),
  (2, 'Rita', 'rita@example.com'),
  (3, 'Mike', 'mike@example.com');
#+END_SRC

#+BEGIN_SRC psql
INSERT INTO orders3 VALUES
  (1, 1, '2018-10-01 00:00:00'),
  (2, 2, '2018-10-02 00:00:00'),
  (3, 1, '2018-10-02 00:00:00'),
  (4, 3, '2018-10-03 00:00:00'),
  (5, 1, '2018-10-04 00:00:00'),
  (6, 3, '2018-10-05 00:00:00');
#+END_SRC

#+BEGIN_SRC psql
INSERT INTO order_items VALUES
  (1, 1245),
  (1, 1234),
  (1, 1221),
  (2, 111234),
  (2, 1232),
  (3, 1245),
  (3, 1221),
  (4, 1221),
  (4, 1222),
  (4, 1223),
  (5, 1254),
  (5, 1221),
  (6, 1221),
  (6, 1222),
  (6, 1223);
#+END_SRC

- This design gets rid of our anomalies:
  - It's possible to insert a customer without orders, or delete orders without getting rid of customers.
  - It's impossible to have inconsistent data -- email determines name. We can even put ~UNIQUE~ on the email field. Similarly, an order can only have one date.
- We still have problems if we try to have the same item multiple times in a given order.
  - One way we could try to solve this is by adding an "item position" to the ~order_items~ table, or we could add a unique ~orderitem_id~ column.

But what if we want all the data together at once, like we had before? Like what if we need to generate an invoice?

#+BEGIN_SRC psql
SELECT c.name, c.email, o.date, oi.item_id FROM customers c, orders3 o, order_items oi WHERE c.id = o.customer_id AND oi.order_id = o.id;
#+END_SRC

#+BEGIN_SRC psql
DROP TABLE customers, orders3, order_items;
#+END_SRC
*** In JS
Of course, the ideas of denormalization and normalization are present in any place you structure data. For example, we could reproduce the same denormalized first draft in JS using something like:

#+BEGIN_SRC javascript
// Defining a single order
let order1 = {
  "name": "Ethan",
  "email": "ethan@example.com",
  "date": "2018-10-01",
  "items": [1245, 1234, 1221],
};

// Defining an array of them
let orders = [
  order1,
  { name: "Rita", email: "rita@example.com", date: "2018-10-02", items: [111234, 1232]},
  { name: "Ethan", email: "ethan@example.com", date: "2018-10-02", items: [1245, 1221]},
  { name: "Mike", email: "mike@example.com", date: "2018-10-03", items: [1221, 1222, 1223]},
  { name: "Rita", email: "ethan@example.com", date: "2018-10-04", items: [1254, 1221]},
  { name: "Mike", email: "mike@example.com", date: "2018-10-03", items: [1221, 1222, 1223]},
];
#+END_SRC

You don't get SQL, so any analysis/combination you want to do has to be done in JS:

#+BEGIN_SRC javascript
orders.filter(o => o.items.includes(1221));   // get the orders where item 1221 was purchased

// JS doesn't have "select distinct", so if we want that, we have to write it ourselves:
let names = {};
orders.filter(o => o.items.includes(1221)).map(o => o.name).forEach(name => names[name] = true);
Object.keys(names)
#+END_SRC

N.B. We get arrays in JS so handling items is already better than in the spreadsheet case. It's also possible to refer to an array element by its index rather than with an ~UPDATE~ query, so we can fix a single order if we want:

#+BEGIN_SRC javascript
orders[5].name = "Francis";
#+END_SRC

But it's still denormalized and we still have all the same problems of inconsistency/update anomalies.

We can normalize this data in a variety of ways. Here's one where we use the customer's position in the array as their ID.

#+BEGIN_SRC javascript
let customersWithId = [
  { id: 0, name: "Ethan", email: "ethan@example.com" },
  { id: 1, name: "Rita", email: "rita@example.com" },
  { id: 2, name: "Mike", email: "mike@example.com" }
];

let ordersWithCustomerId = [
  { customerId: 0, date: "2018-10-01" },
  { customerId: 1, date: "2018-10-02" },
  { customerId: 0, date: "2018-10-02" },
  { customerId: 2, date: "2018-10-03" },
  { customerId: 0, date: "2018-10-04" },
  { customerId: 2, date: "2018-10-03" }
];

// Match order date with customer name
ordersWithCustomerId.map(o => {name: customersWithId[o.customerId].name, date: o.date});
#+END_SRC

This is normalized in the same way as the SQL example ~orders3~. (I put the customer ID in the ~customersWithId~ array but really I don't have to, they already have their ID implied by their array indices.) Because the customer information is not duplicated, I still have no possibility of update anomalies.

Here's another approach where we get rid of IDs entirely!

#+BEGIN_SRC javascript
let customerObjects = [
  { name: "Ethan", email: "ethan@example.com" },
  { name: "Rita", email: "rita@example.com" },
  { name: "Mike", email: "mike@example.com" }
];

let ordersWithCustomerObjects = [
  { customer: customers[0], date: "2018-10-01" },
  { customer: customers[1], date: "2018-10-02" },
  { customer: customers[0], date: "2018-10-02" },
  { customer: customers[2], date: "2018-10-03" },
  { customer: customers[0], date: "2018-10-04" },
  { customer: customers[2], date: "2018-10-03" }
];
#+END_SRC

If you try to visualize this using your browser's dev tools, it'll show you that each order has its own "customer" field. But in fact the customers are shared by the orders. You can prove this:

#+BEGIN_SRC javascript
orders2[3].customer.name   // Mike
orders2[5].customer.name   // Mike
orders2[3].customer.name = "Francis";
orders2[5].customer.name   // Francis
#+END_SRC

In other words, you can't have an update anomaly here either.
*** Final thoughts
Why normalize? It gives our data structure.

Why *denormalize*? Sometimes you do that too because having data in a "flat" structure can be faster.

Some other random stuff:

- A great essay about [[https://web.archive.org/web/20170727224913/https://qntm.org/gay][Gay marriage: the database engineering perspective]]. (This is an archive.org link because it seems like he took it down at some point.) There's also a follow-up, [[https://qntm.org/support][Obergefell v. Hodges: the database engineering perspective]], about the follow-up once gay marriage became legal in the United States.
- "Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious." -- [[https://en.wikiquote.org/wiki/Fred_Brooks][Fred Brooks]], in The Mythical Man-Month
- List of SQL commands from the Postgres documentation: https://www.postgresql.org/docs/current/sql-commands.html
- Wikipedia on database normalization: https://en.m.wikipedia.org/wiki/Database_normalization
** Iteration in JavaScript
This falls under the category of "fundamentals" -- the equivalent of dribbling in basketball. So far, we've focused on making the program work, which has mostly boiled down to "use the simplest thing that works", but now I want to focus on the next step, going from code that works to clean, idiomatic code, and to that end, I want to drill a little bit on all the options we have available. Knowing these options is part of what it means to have a deeper knowledge of JavaScript.

Besides that, these options can save you lines of code as well as better express intent, both of which can come in handy on e.g. a whiteboard coding problem.

First let's talk about arrays, and then we'll talk about objects, and then we'll talk about iterables.
*** Arrays: basic for loop
This looks like this:

#+BEGIN_SRC javascript
  let a = [4, 9, 15];
  for (let i = 0; i < a.length; i++) {
      // do something with a[i]
  }
#+END_SRC

This is the plain, bog-standard for loop. It's easy to remember because it's the same for loop style that you might use for other kinds of looping. Here we use a variable ~i~ which goes through every index in the array, and we use that index to look something up in the array, and then we operate on the thing that we got.

Use this style when:

- You need some more complicated iteration or termination condition. For example, you want to look at every second element, or you want to stop once you find a certain element.
- You can't think of any better alternative.
*** Arrays: forEach
One annoyance in the previous example is that we have to create this new ~i~ variable that we have to keep track of, but actually we don't care about it. We just use it to refer to elements of the array. We can also just access the elements more directly using the ~Array.forEach~ method:

#+BEGIN_SRC javascript
  let a = [4, 9, 15];
  a.forEach(function(element) {
      // do something with element
      console.log(element);
  });
#+END_SRC

~forEach~ is pretty interchangeable with the above ~for~ loop -- maybe it's a little fancier, but that's all.

The callback function is called with ~element, index, array~, so if you need the index as well as the element, you can just pass a function of two arguments.

~forEach~ itself returns ~undefined~, so using it is a way to signal that you're doing something with a side effect here.

Use this style when:

- You want to write a ~for~ loop but don't actually need the index.
- You want to look a little more sophisticated than just writing a ~for~ loop.

Personally, I don't think the ~forEach~ method is always an improvement on a base ~for~ loop, but it's a matter of taste so your opinion may differ.
*** Arrays: map
Sometimes you want to go through an array and build up a new array. For example, maybe you have a bunch of URLs, and you want to fetch each one, which produces a Promise, and then use Promise.all() to wait until you get them all back. For this, you should use ~map~:

#+BEGIN_SRC javascript
  let a = ["http://google.com/", "http://en.wikipedia.org/"];
  let b = a.map(function(element) {
      return fetch(a);
  });
  return Promise.all(b);
#+END_SRC

Use this when:

- You want to transform one array into another one.

Don't use this style when:

- Any element depends in some way on previous elements.
- You need to invoke side effects. Using ~map~ is a way of expressing that the essence of what you're doing is pure, and that the return value is what's important.

Refactor to this when you see:

#+BEGIN_SRC javascript
  let a = [4, 9, 15];
  let b = [];
  for (let i = 0; i < a.length; i++) {
      b.push(/* some result computed from a[i] */);
  }
#+END_SRC
*** Arrays: filter
Another common operation is to find all the elements of an array matching some condition. For example, maybe you want to go through an array of URLs and only fetch the ones that point to Wikipedia.

#+BEGIN_SRC javascript
  let a = ["http://en.wikipedia.org/wiki/Manhattan", "http://maps.google.com/"];
  let b = a.filter(function(element) {
      // return true if element should be included in b
      // N.B. Don't actually compare URLs like this
      return element.startsWith("http://en.wikipedia.org/");
  });
#+END_SRC

Like ~map~, use of ~filter~ is a way of pushing towards a functional style and should not be mixed with side effects.

Use filter when:

- You want to focus on certain elements of an array.
- It's easy to express whether you want an element or not according to just that element (without regard to previous elements).

Refactor to this when you see:

#+BEGIN_SRC javascript
  let a = [4, 9, 15];
  let b = [];
  for (let i = 0; i < a.length; i++) {
      if (/* some condition of a[i] */) {
          b.push(a[i]);
      }
  }
#+END_SRC
*** Arrays: reduce
Finally, it can be helpful to combine all elements into a single "summary" value. For this we use ~reduce~. The classic examples of using this are "sum" and "product" functions:

#+BEGIN_SRC javascript
  function sum(arr) {
      return arr.reduce((acc, elem) => acc + elem, 0);
  }

  function product(arr) {
      return arr.reduce((acc, elem) => acc * elem, 1);
  }
#+END_SRC

But really it can be used to implement any kind of looping construct, where the "state" of your loop (the variables that you would normally be changing) are passed and returned explicitly as an "accumulator". For example, maybe we want to implement a simple calculation language. Each command in our language is either a number, or the word "sum" or "product" (meaning, take the sum or product of all the numbers since the last word).

#+BEGIN_SRC javascript
  let a = [9, 15, "sum", 2, 12, 1, "product", 12, "sum"];
  let output = a.reduce((acc, elem) => {
      if (elem == "sum") {
          acc.result.push(sum(acc.current));
          acc.current = [];
      } else if (elem == "product") {
          acc.result.push(product(acc.current));
          acc.current = [];
      } else {
          acc.current.push(elem);
      }
      return acc;
  }, {current: [], result: []});
#+END_SRC

Personally, I often find ~reduce()~ isn't clearer than writing the equivalent loop. (Guido van Rossum wrote [[https://www.artima.com/weblogs/viewpost.jsp?thread=98196][much the same thing in 2005]].) I've also encountered code that was written to use ~reduce~ in a clean, functional, immutable way that turned out to be a performance bottleneck and fixing it meant converting it to a loop.

#+BEGIN_SRC javascript
  let a = [9, 15, "sum", 2, 12, 1, "product", 12, "sum"];
  let current = [];
  let result = [];
  // Or you could use forEach here if you want
  for (let i = 0; i < a.length; i++) {
      let element = a[i];
      if (element == "sum") {
          result.push(sum(current));
          current = [];
      } else if (element == "product") {
          result.push(product(current));
          current = [];
      } else {
          current.push(element);
      }
  });
#+END_SRC

Use ~reduce~ when:

- You want to show off your functional programming skills.
- You need to define ~sum~ or ~product~.
*** Arrays: other methods
- ~every~: check if all elements match a condition, returning immediately at the first one that doesn't: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
- ~some~: check if at least one element matches a condition, returning immediately at the first one that does: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
- ~find~: find the first element matching a condition: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
- ~findIndex~: same as ~find~, but returning its index: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
*** Objects: basic for loop
Now let's talk about objects. Just a recap: What are commonly called "objects" in JavaScript are really a poor man's hash table. A hash table is like an array, but instead of looking up elements by numeric index, the index can be some other non-numeric thing, like a string. (In JavaScript objects, it has to be a string, but you can use Map instead. More on this later.)

JavaScript provides the following construct to loop over an object:

#+BEGIN_SRC javascript
  let a = {"Ethan": 4, "Francis": 9, "Rita": 15};
  for (let name in a) {
      // do something with name or a[name]
  }
#+END_SRC

There are a couple caveats/known issues with this syntax:

- This loop iterates over properties that were inherited from other classes. So, for example, this simple JS OOP example iterates over both ~hello~ and ~myMethod~ despite the fact that neither is defined on my ~e~ instance:

#+BEGIN_SRC javascript
  function EthanTest() {
  }
  EthanTest.prototype.hello = 4

  EthanTest.prototype.myMethod = function() {}

  let e = new EthanTest();
  for (let name in e) {
    console.log(name, e[name]);
  }
#+END_SRC

(This doesn't affect classes defined using new-school ~class~ syntax, so maybe it's not a big deal any more.)

In particular, some older client-side JS libraries (Prototype.js and Mootools?) add stuff directly to Array.prototype or String.prototype, so received wisdom is not to use this on arrays or strings. (But then, you probably won't work on sites adding stuff to Array.prototype or String.prototype, or if you do, you'll add non-enumerable properties, so maybe this won't be an issue either.)

- The ~for ... in~ syntax is a little opaque. In particular it looks very much like the ~for ... of~ syntax which is arguably more useful (about which more later). So pay attention to that little word.

There are some helper methods that help you iterate over just the parts of the key-value mapping that you care about:
*** Objects: keys
In particular, you can call ~Object.keys~ to get an ~Array~ of the keys in the object. This function doesn't return any "inherited" keys. Then you can iterate over the keys however you like:

#+BEGIN_SRC javascript
  let a = {"Ethan": 4, "Francis": 9, "Rita": 15};
  let keys = Object.keys(a);
  for (let i = 0; i < keys.length; i++) {
      // do something with keys[i] or a[keys[i]]
  }
#+END_SRC

... or use whatever other ~Array~ methods you want on the keys:

#+BEGIN_SRC javascript
  let a = {"Ethan": 4, "Francis": 9, "Rita": 15};
  console.log(Object.keys(a).filter(k => k.length <= 5));
#+END_SRC

Use this method when:

- You don't need the object itself, but just its keys, or some kind of manipulation of the keys.
*** Objects: values
If you don't actually need the keys, you can equally just get the values:

#+BEGIN_SRC javascript
  let a = {"Ethan": 4, "Francis": 9, "Rita": 15};
  console.log(Object.values(a).map(x => x ** 2));
#+END_SRC

Use this method when:

- You don't actually care about the keys. Maybe you were just using them to ensure that duplicates were filtered out or something.
*** Objects: entries
If you need the keys and the values, there's a method that provides that too, which is called ~entries~:

#+BEGIN_SRC javascript
  let a = {"Ethan": 4, "Francis": 9, "Rita": 15};
  let entries = Object.entries(a);
  for (let i = 0; i < entries.length; i++) {
      let [key, value] = entries[i];
      // Do something with key and/or value
  }
#+END_SRC

(Note that this uses "destructuring assignment": ~let [key, value] = something~. This is a neat ES6 feature which makes the ~entries~ method quite a bit more useful.)

Use this method when:

- You definitely want both the key and the value. Using ~entries~ makes that a bit clearer than iterating over the object itself, and the keys/values are more clearly paired.
- You want to use fancy Array methods like ~filter~ or ~map~ but need both the keys and the values.
*** Interlude: Maps
ES6 also includes a Map class. If JS objects are a poor man's hash table, Map is the regular man's hash table. You can use anything as a key. For example, check this out:

#+BEGIN_SRC javascript
  let a = {};
  a[5] = "hello";
  let firstKey = Object.keys(a)[0]
  console.log(typeof firstKey);

  let m = new Map();
  m.set(5, "hello");
  let mapFirstKey = Array.from(m.keys())[0];
  console.log(typeof mapFirstKey);
#+END_SRC

(Note: this ~Array.from~ is unfortunate. We'll talk more about that in a little bit.)

This can be handy if you want to use actual numbers (or arrays, or functions...) as the keys in your lookup table.

The disadvantage is that there's no native syntax for Maps the way there is for Objects. Instead you have to do this Java-esque ~get~/~set~ nonsense.

If you use Map, the implication is that you're creating some kind of lookup structure, with all the keys the same type and all the values the same type (although not necessarily the same type as the keys). You can use objects in this way too, but objects are also used to pass around options or to parse JSON responses, so objects don't really imply that same lookup-structure-y-ness. In terms of data structure design, I'd expect a Map to have consistent keys and consistent values, and if I had heterogeneous keys/values, I'd define a class and use instances of that class. JavaScript objects are somewhere between the two.
*** Iterables: for ... of
Most languages eventually find that there's a common pattern of looping over different data structures, and introduce a common looping structure to make it easy to write code that is agnostic about the data structure it operates on. In JavaScript this structure is called "[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol][the iterable protocol]]". Any class that implements the iterable protocol can be iterated over using a ~for ... of~ loop:

#+BEGIN_SRC javascript
  let a = [4, 9, 15];
  for (let x of a) {
      console.log(x);
  }
#+END_SRC

Again, be careful -- ~for ... of~ can look like ~for ... in~ at a glance.

Whoever implements a class gets to decide what you get when you iterate over the instances of that class. In this case, when you iterate over arrays, you get each element of the array. When you iterate over Maps, you get ~[key, value]~:

#+BEGIN_SRC javascript
  let m = new Map();
  m.set("Ethan", 4);
  m.set("Francis", 9);
  m.set("Rita", 15);
  for (let [key, value] of m) {
      console.log(key, value);
  }
#+END_SRC

You can't iterate over an object using ~for ... of~ (you'll get an error that objects aren't iterable) but you can iterate over the arrays you get from ~Object.keys~, ~Object.values~, or ~Object.entries~.
*** Iterators: Map.prototype.keys and Map.prototype.values
We saw that when you get the keys of an object using ~Object.keys~, you get an array of keys. Arrays have all those nice methods you saw earlier like ~filter~, ~map~, so that's all great. However, arrays need memory, and allocating that memory can be a waste if you only need to go over some of those elements. So another approach is to return an *iterator*, which is like a tiny data structure that keeps track of where you were and gives you the next element when you ask for it. The Map equivalent of the Object functions ~keys()~, ~values()~, and ~entries()~ all return iterators.

Because JavaScript, these iterators do not share the useful array methods we saw earlier. However, you can convert an iterator to an array if you need to using ~Array.from~:

#+BEGIN_SRC javascript
  let m = new Map();
  m.set("Ethan", 4);
  m.set("Francis", 9);
  m.set("Rita", 15);
  for (let key of m.keys()) {
      // ...
  }

  // or ...
  let keys = Array.from(m.keys());
#+END_SRC
*** Recap
- ~for (let i = 0; i < ...; i++)~ is a fine default but sometimes you can do better.
- ~for ... of~ is pretty nice.
- ~for ... in~ can be useful sometimes. So can ~forEach~. But feel free not to use them if you think they make your intentions less clear.
- You can sometimes build up chains of array methods rather than explicitly writing out a loop, which can make your code feel more declarative and elegant.
- Maps are nice.
** How to jump into a bigger codebase
** Elm, part 1a: the language (intro)
*** What is Elm?
Elm is an interesting point in the universe of front-end tools. Elm is a programming language which has been designed, along with its tools and libraries, to specialize in making front-end programming as pleasant as possible. Some aspects of this decision:

- Whereas the trend is to make a programming language general-purpose -- for example, for JavaScript to "break out" of the browser and run in Node -- the Elm designers steadfastly refuse to even consider running Elm "on the back-end".

- The Elm designers focus on ease-of-use and simplicity, even to the extent of incredibly thorough compiler error messages. Instead of adding features or language syntax, Elm tends to stick with a relatively small core of fairly clear language primitives.

- There are other languages that fit a similar role to Elm -- CoffeeScript, TypeScript, or BuckleScript/Reason that Facebook has come out with recently. Almost all of the languages in this category try to make it seamless or at least easy to interoperate with JavaScript, so they can take advantage of existing JavaScript code. Elm takes the opposite approach -- Elm treats JavaScript as dangerous and quarantines it. Unlike the languages which are built "on top" of JavaScript, Elm is a statement that JavaScript cannot be fixed, it can only be replaced.
*** Why Elm?
Why bother with Elm? It's relevant to us because:

- Elm makes writing front-end code more pleasant by eliminating some of the problematic things in JavaScript. We'll see more of how this works in a little bit.

- It's interesting pedagogically. It's very different from the other "general-purpose" languages we've seen (JavaScript, Python). Learning Elm will expand our viewpoint on programming in a way that may make us a better programmer in other languages too.

- I wanted to use Elm because it was interesting to me personally, and now I'm making the rest of you learn it too.

In the interests of completion, we should also observe that:

- Elm's focus on simplicity sometimes comes at the cost of power or flexibility. Elm tends to give you just one tool to solve a problem, which can be frustrating.

- Elm is a very young language -- meaning it's immature. Sometimes there are bugs in the compiler. Sometimes the "best practices" are still being developed. In the cases where there is more than one way to do something, it may not be well-understood which way is good or bad. Sometimes progress on Elm is slow, and sometimes it goes through drastic changes. Version 0.19 broke all the 0.18 code, for instance, and you will have to be aware sometimes which one is described in a webpage.

- The Elm ecosystem is still small. In JavaScript you can usually find a library on npm that will do what you want; often, nobody has written a library yet that will do it for Elm. The documentation isn't always everything it could be. Whereas Python had a thorough "language syntax reference", Elm doesn't. (There's https://github.com/izdi/elm-cheat-sheet, but it's unofficial, and oh yeah, it's for 0.18.)

- In particular, Elm is largely the brainchild of a guy named Evan Czaplicki and his colleagues at a company called NoRedInk. They have some (let's say) unorthodox methods of running an open source project/community and some strong opinions about language design and programming style in general. As a result, the Elm community is still small, although very vocal. They tend to try to be friendly and helpful, and especially considerate of new learners, but they sometimes come off as condescending. In these notes, I will occasionally observe that "Evan writes X" or "Evan thinks X" -- this is not an endorsement, but merely a note about the current conditions in this community.
*** What does Elm look like?
Here is some Elm code.

#+BEGIN_SRC elm
  fib : Int -> Int
  fib n =
      if n == 0 || n == 1
      then 1
      -- Recursive case
      else fib (n - 1) + fib (n - 2)
#+END_SRC

This is an implementation of the Fibonacci function. Note: this is not a complete Elm "program". (There's no entry point.) We're not going to learn the concepts we need to put the whole thing together for another few lessons. Exercises I provide will include a bunch of scaffolding that you won't be expected to understand. We can also go to https://ellie-app.com/new which contains a complete program and try to modify it. (We can try just copying and pasting our code in to see whether it will even compile, for example.)

Let's break this example down line-by-line:

- ~fib : Int -> Int~. This is a *type signature*. The ~:~ symbol is used to tell Elm what type something is, and can be read "has the type", like "~fib~ has the type ~Int -> Int~". ~Int~ is the type of integers. ~->~ is the type of functions -- ~a -> b~ means "a function that takes ~a~ as an argument and returns ~b~". So all together, this is saying "~fib~ is a function taking ~Int~ and returning ~Int~". Type signatures like this are often put above the thing they're describing. They help us describe our code's interface and help Elm verify the correctness of what we've written.

- ~fib n =~. Elm code takes the form of a lot of "definitions" that are written in kind of a mathematical style. This is the definition of a function of one argument (~n~, on the left side of the equals sign). In other words, this is saying, "To compute ~fib~ of ~n~, do the following".

- ~if n == 0 || n == 1~. This is the first line of the function definition. *Elm, like Python and Haskell, are sensitive to whitespace*, so the implementation of the function is indented. This is also an ~if~ statement, checking for our base case. ~||~ works the way you would expect. The most basic builtin operators are listed at https://package.elm-lang.org/packages/elm/core/latest/Basics.

- ~then 1~. This is the "body" of the ~if~ statement -- this is what we do if the condition is true. In this case, what we do is ~1~. This value will be the value of the ~if~ statement. More about this later.

- ~-- Recursive case~. Elm has two syntaxes for writing comments: single-line ones like this, and block comments that look like ~{- block comments -}~.

- ~else fib (n - 1) + fib (n - 2)~. This is the "else" branch of the ~if~ statement (what we do if the condition is false). In this case, what we will do is calculate ~fib (n - 1) + fib (n - 2)~. As with the ~then~ branch, if we choose this branch, this will be the value of the ~if~ statement.

  - In Elm, to call a function, we just write the name of the function, then a space, then the arguments to the function. So to call ~fib~ with ~5~, we write ~fib 5~. Parentheses like ~fib(5)~ in JavaScript are not necessary.

  - However, in Elm, we say that *function application binds tightest*. What this means is that if we write ~fib n - 1~, Elm understands this as ~(fib n) - 1~ (the function application has precedence), and not what we actually want. We can use parentheses as usual to enforce order of operations.

When you look at Elm code, you will notice first that the syntax is very different from other languages you've seen. (Instead of the C family languages, which inspired JavaScript syntax, Elm is more inspired by the ML family of languages, which includes Haskell.) But apart from this surface difference, there are two important structural differences that make Elm so different. Let's dig into those in a bit more depth.
*** Static typing
Elm is *statically typed*. This means that every variable has a type that can be determined before your code even runs. In Python, you can do this:

#+BEGIN_SRC python
  def f(x):
      return x + 1

  print("OK, let's call f")
  s = "hi"
  f(s)
#+END_SRC

This defines a function ~f~, which can be called with integers. Then, we print a little message, and then we call the function with a string. This is invalid, and we'll get an error message saying so -- *after* we've printed the message. In other words, this is a *runtime* error, because the language does not know what type ~s~ is until runtime. (Indeed, ~s~ can be an ~int~ later in the program.) This is what makes Python *dynamically typed*.

In Elm, the equivalent function will not even run. Elm code is *compiled* before you can run it, and as part of the compilation process, your code will be *typechecked*, which means each operation is examined to see whether it makes sense with the types that we have. When typechecking, Elm will infer that ~f~ can only be called with integers, that ~s~ is a string, and thus calling ~f~ with ~s~ is an error.

Statically typed languages have the advantage that they can prevent a lot of the goofy stuff that happens in JavaScript. In JavaScript, if you try to add a number to an object, you get ~"[object Object]5"~ . In Elm, you just can't do this; if you try, the compiler will yell at you and you won't be able to run your code. This also prevents stuff like ~undefined is not a function~ or ~could not access property foo of null~. This is one of Elm's big selling points: if your code compiles, it will run, with no mysterious or surprising breakages at runtime. (You can still have bugs, of course.)

The *disadvantage* of static typing is that you have to spend more time thinking about your program before you write any of it. You will have to figure out what types you need and how they fit together. This effort usually leads to a better program, but it can be frustrating and feel "slower" than just writing JavaScript.

Elm is pretty smart and can figure out what types your functions have. However, it's traditional to put type signatures above each top-level definition. This helps prevent situations where you write a function that, while legal, doesn't do what you intend.
*** Purity
Elm is a *pure* language, which means that no operation can have a side effect.[*] This means that when you call a function, the only thing it can do is return a value.

[*] Wikipedia instead describes languages as "purely functional", in which operations are expressed as mathematical functions, with their output only depending on their arguments, or alternately by forbidding mutable data. This might be more correct from a theoretical standpoint, or maybe it's saying the equivalent thing.

This has a lot of implications! To start with, you can never change a variable -- doing so is, by definition, a side effect. Doing ~x = 5; x = 6~ is invalid.

Because you can never change a variable, there's also no real "loop" operations -- no ~for~, no ~while~. Instead, you have to write your own recursive functions (or use helpers like ~fold~).

Because side effects are impossible, the only thing a function can do is return a value. You noticed before that there's no ~return~ statement in Elm -- there's no real need for it.

I said that there's no ~return~ statement -- in fact, there aren't really even statements at all! No operation can have a side effect, so every operation must have a value, which means the language only has expressions. Even ~if~ statements have values, which we saw in the ~fib~ function above -- if the condition is true, we use the value of the ~then~ branch; otherwise, we use the value of the ~else~ branch.

Finally, purity means that if you call a function with the same arguments, you *must* get the same results. The advantage here is that no data is hidden and no code can change a variable somewhere without you knowing about it. The disadvantage is that a lot of things tend to rely on some kind of implicit state, and in Elm you have to always make that state explicit.

The upshot here is that some things that seem like they would be easy in JavaScript are suddenly going to seem very hard. (For example, getting a random number is a simple function call in JavaScript, but in Elm it's more complicated.) The good news is that some things that are hard in JavaScript are simpler or at least more pleasant in Elm. But either way, it's going to be jarring. When this happens, just remember that Ethan said it was OK.
*** Elm syntax cheat sheet
We've seen the syntax for defining a function -- type signature, then something ~func arg1 arg2 = body~, where ~arg1~ and ~arg2~ are the function arguments, and ~body~ is an expression whose value will be the return value of the function. It's also common to put a documentation comment above the function, which describes what the function does: ~{-| Example documentation comment. -}~

We've also seen some operators. ~+~, ~-~, ~*~ all do what you would expect. ~/~ does floating-point division. ~//~ does integer division, discarding remainder. ~||~ and ~&&~ do logical operations. Comparisons are done with ~==~, ~/=~, ~<~, ~>~, ~<=~, ~>=~. Strings are concatenated using ~++~.

We've seen ~if~ statements: ~if condition then body else elsebody~. Elm doesn't have special syntax for "chained" or "nested" if statements, so there's no special ~else if~ syntax. However, you can still nest if statements in the usual way:

#+BEGIN_SRC elm
  if c1
  then if c2
       then b2
       else e2
  else if c3
       then b3
       else e3
#+END_SRC

You can also define local variables within a function if you like using ~let ... in~. Example:

#+BEGIN_SRC elm
  let
      number = 14
  in
  number - 4
#+END_SRC

This can be useful in larger functions, or if you need to re-use a smaller expression, but it's also pretty common not to even bother with helper variables and just use expressions directly. Remember that you *cannot redefine variables*.
*** Homework
- Install Elm on your computer. Follow the instructions at https://guide.elm-lang.org/install.html . This will show you how to run the elm REPL, which lets you run individual commands. It will also show you how to use ~elm reactor~ and ~elm make~ to compile and run Elm programs that you have on your computer. This may be easier than using Ellie. Make sure you know how to build and run Elm programs.

- https://ellie-app.com/5KWm4SVfG9na1 is a "problem set". You can solve it on Ellie or on your own computer, as you prefer.
** Elm, part 1b: types
We saw last week that Elm is a statically-typed language. This static type system is pervasive in Elm and a major part of the Elm paradigm. It's very common, when writing Elm code, to not think about a variable's value, but just its type, and often that type serves as a guide for what operations are available for it. This week we'll look more at the type system itself and how to use it.

What is a type? A type is a set of values. When we say that something ~x~ is of type ~Int~, what we mean is that ~x~ can have the values ~1~, ~2~, ~3~ and so on, but cannot have the values ~3.14~, ~False~, or ~"butterscotch"~. Giving types to things makes it possible for Elm to verify that we are using them in ways that are correct. If Elm detects that something is being used inconsistently (we try to add something to it although it isn't a number, or we try to use it as both a number and a string), we will get a compiler error and be unable to run our program. If our code compiles successfully, it doesn't necessarily mean that we don't have any bugs, but it's a good start.

In Elm, we use the ~:~ symbol to indicate the type of something. Most types start with a capital letter. Types operate at a different "level" than values. We can't say ~x = Int~ because ~x~ is a variable and can only hold a single value, whereas ~Int~ is the "class" of a whole bunch of values. Similarly ~f Int~ and ~Int + 5~ don't make any sense.
*** Basic types
We've already seen some of the builtin types: ~Int~, ~String~, ~Float~, ~Bool~. These should mostly be familiar from other languages. Elm also has ~Char~, which is the type of a single "letter".

#+BEGIN_SRC elm
  x : Int
  x = 5

  name : String
  name = "Ethan"

  e : Float
  e = 2.71828

  space : Char
  space = ' '
#+END_SRC
*** Function types
Last week we saw that functions also have a type. A function that takes an ~Int~ and returns a ~String~ has the type ~Int -> String~.

Functions can take multiple arguments. For example, if a function ~f~ takes an ~Int~ and a ~Char~ and returns a ~String~, we write its type ~f : Int -> Char -> String~. This syntax may look a little strange -- it almost looks like, instead of one function of two arguments, there's two functions of one argument! And the reason for this is that actually, it is. This enables a feature called "partial function application", which we'll see in more depth later.

#+BEGIN_SRC elm
  double : Int -> Int
  double x = x * 2

  greet : String -> String -> String
  greet firstName lastName =
      "Hello, " ++ firstName ++ " " ++ lastName ++ "!"

  -- Anonymous functions ("lambdas") are also available in Elm. They use
  -- the backslash "\" character, which is supposed to look a little
  -- like the Greek letter lambda.
  double : Int -> Int
  double = \x -> x * 2
#+END_SRC
*** Lists
Elm has a "sequence" type which is called ~List~. Although in many languages, the name for this kind of "sequence of things" is ~Array~, in Elm we use ~List~. Note that Elm also has an ~Array~ type that we won't talk about.

#+BEGIN_SRC elm
  numbers : List Int
  numbers = [ 12, 24, 36 ]

  names : List String
  names = [ "Ethan", "Mike", "Alex" ]
#+END_SRC

We write a list value using square brackets: ~[ 1, 2, 3 ]~. We write the type of lists using the name ~List~: the previous list is type ~List Int~.

In Elm, a ~List~ is homogeneous -- all elements in it must be of the same type. You can't write ~[4, "Ethan"]~ -- this list is invalid.

We see that ~List~ is not a "complete" type by itself. A list is a list "of" something. A list of ~Int~ has type ~List Int~. If you've ever looked at C# or Java, this may be familiar to you -- in Java, a list type would be ~List<T>~, and we would say it was "generic" over the type ~T~. In Elm we don't use those angle brackets, but the idea is the same.
*** Tuples
Sometimes you just want to pair up two (or three, but anyhow a small, fixed number) of things. To do this, you can use a tuple.

#+BEGIN_SRC elm
  red : ( Int, Int, Int )
  red = ( 255, 0, 0 )

  englishGrade : ( String, Int )
  englishGrade = ( "Professor Quinlan", 85 )

  mathGrade : ( String, Int )
  mathGrade = ( "Professor Feigenbaum", 92 )

  grades : List ( String, Int )
  grades =
      [ mathGrade
      , englishGrade
      , ( "Professor Ingalls", 88 )
      ]
#+END_SRC

We write the types of tuples using parentheses, so ~( Int, Int )~ is the type of a tuple with an ~Int~ and an ~Int~. We also write the tuple values themselves using parentheses, so an example of the previous type is ~( 2, 4 )~.

Tuples serve a different role than lists. Lists are good when you have a bunch of elements which are all the same type, and you don't know how many you will have. Tuples are good for when you have a fixed number of things and they aren't necessarily the same type. They're a first step towards defining a new type. In the above example, I'm sort of defining a "color" type which is a RGB triple, and I'm sort of defining grades as ~( professor name, grade )~ pairs.

Tuples are real types and so can be used in any place other types can be -- as the element of a list or as the return type of a function, for example. Using a tuple this way is one way to get around the fact that functions can only return one value.

A tuple is a good fit for when defining a type for something feels too heavyweight, but if you find yourself re-using a specific tuple, you should probably define a type for it. Anything a tuple can do, you can do with a record type (below).
*** Records
Records are sort of like classes or structs from other languages. They group a bunch of fields together in a single value which includes all of them. In the functional community we tend to use the word "types" instead of "classes" because classes have methods "attached" to them, whereas types are free floating and functions using them can be defined anywhere.

The most common use is something like this:

#+BEGIN_SRC elm
  type alias User =
      { id : Int
      , name : String
      , username : String
      , email : String
      }
#+END_SRC

This defines a ~User~ type which is a combination of an ~Int~ (the ~id~) and three ~String~ (the ~name~, ~username~, and ~email~). You can then "create" a ~User~ value like this:

#+BEGIN_SRC elm
  ethan =
      { id = 1,
      , name = "Ethan"
      , username = "glasserc"
      , email = "ethan@example.com"
      }
#+END_SRC

You can access the fields of a record using dot syntax. ~ethan.name~ is ~"Ethan"~.

Elm also allows you to write ~.name~ -- this creates a function ~User -> String~ which extracts the ~name~ field from a ~User~. (You can also pattern-match individual fields out of a record. More about pattern-matching later.)

This "common" use case is actually the combination of two Elm features. First, record types. You can create a record type without giving it a name, sort of the same way you create a random tuple:

#+BEGIN_SRC elm
  greetUser : { id : Int, name : String, username : String, email : String } -> String
  greetUser u = "Hello, " ++ u.name ++ " <" ++ u.email ++ ">"
#+END_SRC

This is kind of rare -- records are usually complicated enough and meaningful enough to give names to -- but it does happen. For example, https://package.elm-lang.org/packages/elm/http/latest/Http uses these kinds of "anonymous" records in its function arguments.

The other feature is type aliases:
*** Aliases
Elm lets you define a type alias. This lets you give a new name to a commonly-used type. That might be a type like ~Int~ or ~String~ which already exists or it might be a type built out of other types like tuples or records. An example:

#+BEGIN_SRC elm
  type alias RGB = ( Int, Int, Int )

  saturation : RGB -> Float
  saturation color = -- ...
#+END_SRC

This kind of type is very simple -- whenever the compiler sees ~RGB~, it immediately replaces it with ~( Int, Int, Int )~. There's no difference as far as it's concerned. If you have a function that takes ~( Int, Int, Int )~, it also takes ~RGB~. If you define ~type alias Name = String~, then the compiler won't prevent you from passing a ~String~ to a function that needs a ~Name~, or vice versa. After compilation, the type alias completely disappears.

One implication of "disappearing" type aliases is that you can't have a recursive one. Consider the following structure:

#+BEGIN_SRC elm
  type alias List = ( Int, List )
#+END_SRC

The compiler knows it can replace ~List~ with ~( Int, List )~. But wait, there's a ~List~ right there in the tuple! So it tries to replace that and gets: ~( Int, ( Int, List ))~. But wait, there's still ~List~! Trying to expand this alias leads to an infinite type, which (among other problems) doesn't fit in computer memory, so compilation is impossible.

Besides records, you can use this kind of alias to tentatively introduce types without a lot of fuss. For example, you might know you need a type for money that is more complicated than floating-point numbers. Until you have the time/information to implement that, you can ~type alias Money = Float~. This kind of type alias is lightweight but it can feel a little "unsafe". (It's "safe" for records because the real safety comes from the definition of the record type, not the alias.)

As a special feature, if you define an alias to a record type, Elm also defines a function with the same name as the alias which functions something like a constructor. For example, in the ~User~ example above, Elm will define a function ~User : Int -> String -> String -> String -> User~. This is kind of like a "constructor" from the enum section (below) -- it helps you create instances of the type. This only happens for type aliases for records!
*** "Custom types" (a.k.a. tagged unions or ADTs)
We said above that types are a name given to a set of possible values. The ~type~ declaration in Elm is the way you create this set of possible values.

#+BEGIN_SRC elm
  type Color
      = Red
      | Green
      | Blue
#+END_SRC

This declaration creates a type called ~Color~. There are three "variants" of ~Color~. Each variant has a "constructor" -- ~Red~, ~Green~, and ~Blue~. These constructors (which have to start with a capital letter) are how you create ~Color~ values. So you can do:

#+BEGIN_SRC elm
  skyColor : Color
  skyColor = Blue
#+END_SRC

Your type can have as many variants as you want. ~Bool~ is just a type with two variants (~True~ and ~False~). It's even possible to have types that have zero values! It's called https://package.elm-lang.org/packages/elm/core/latest/Basics#Never and I don't think I've ever really used it in real code.

Not only that, but each variant can store additional data, and that data can be different for different variants. An example:

#+BEGIN_SRC elm
  type SearchQuery
      = SearchByName String
      | SearchById Int

  query : SearchQuery
  query = SearchByName "Ethan"
#+END_SRC

Unlike records, the data associated with variants is not identified by name -- only by position. (For this reason, it can be helpful to have both "tagged union" types as well as records.) It's not possible to directly get the data out of a ~SearchQuery~ because a ~SearchQuery~ could be either a ~SearchByName~ or a ~SearchById~. Instead, we can use pattern matching:

#+BEGIN_SRC elm
  searchString : SearchQuery -> String
  searchString q =
      case q of
          SearchByName s ->
              -- Now we have a new variable, s, which corresponds to the
              -- string that was given originally to the SearchByName
              s

          SearchById i ->
              -- And here we have i which corresponds to the Int that
              -- was given to SearchById
              String.fromInt i

  -- It's also possible to disregard the associated data if you don't
  -- need it
  searchIsByName : SearchQuery -> Bool
  searchIsByName q =
      case q of
          SearchByName _ ->
              True

          SearchById _ ->
              False
#+END_SRC

Pattern matching works by letting us check which variant the value is and, at the same time, extract the data from it. We "deconstruct" the data using the same constructors we used to create it. Remember that the space of types and the space of values are different -- in the type declaration, we said ~SearchByName~ is followed by a ~String~, but in the pattern matching, we extract a variable (not a type).

We said that type aliases "disappear" after compilation. The ~type~ declaration in Elm defines a type that does not disappear. Each constructed value is represented as a JavaScript object which indicates which constructor was used for it and any additional data it has. Here's an example of a linked list and a length function for it:

#+BEGIN_SRC elm
  type IntList
      = Cons Int IntList
      | Nil

  length : IntList -> Int
  length l =
      case l of
          Cons _ remainder ->
              length remainder + 1

          Nil ->
              0
#+END_SRC
*** Polymorphism and parametricity
Some functions have a type that is more complicated. For example, consider the *identity function*, ~identity x = x~. What is the type of this function? It can take any type and returns that type. Writing ~Int -> Int~ is too restrictive -- it's simultaneously ~String -> String~.

The answer is that a type signature can have variables in it. In this case, we can say ~identity : a -> a~. Here, ~a~ is not a specific type, but it can take on any type. When we do ~identity 5~, Elm sees that we're applying ~identity~ to an ~Int~, and so ~a~ must be ~Int~ here, and since ~identity~ returns ~a~, it must return an ~Int~ too.

We say that the ~identity~ function is polymorphic, or generic. Sometimes you also see the word "parametricity" tossed around.

The same principles apply when we define types. Above, we defined an ~IntList~ type, which could be useful for managing lists of integers. What if we want to have a list of strings? Do we need to write a whole new type? No, we can do:

#+BEGIN_SRC elm
  type MyList a
      = Nil
      | Cons a (MyList a)
#+END_SRC

Now, ~MyList a~ is the type of a list that holds ~a~ elements. ~MyList Int~ is the type of lists that hold ~Ints~, etc. ~MyList~ by itself is incomplete -- you need to provide another type for it to "work". Indeed, this is exactly how the built-in ~List~ type works!

This idea is pretty funky and you may stumble over it the first few times you use it.
*** Some useful types
Here are some other examples of this kind of generic type. There's a type called ~Maybe~. It's defined like this:

#+BEGIN_SRC elm
  type Maybe a
      = Just a
      | Nothing
#+END_SRC

This type is central to how we avoid "undefined is not a function" in Elm. The type ~Maybe~ lets you express that something is optional or that it can "fail".

You can use ~Nothing~ sort of the way you would use ~undefined~ or ~null~ in JavaScript, but the difference is that ~Nothing~ is part of this ~Maybe~ type, so you can't pass it for just anything.

There's also ~Result~:

#+BEGIN_SRC elm
  type Result e a
      = Err e
      | Ok a
#+END_SRC

This lets you represent "failure with a reason".

These types are very handy and appear all over the place. There's also a bunch of utility methods to help when working with them: https://package.elm-lang.org/packages/elm/core/latest/Maybe and https://package.elm-lang.org/packages/elm/core/latest/Result.

N.B. It's possible to overuse these. If you find yourself using a type with ~Maybe~ s nested in ~Result~ s or the other way around, that's a good clue that you might want to define a new type. It's also possible to lean on ~Maybe~ as a crutch instead of correctly modeling when you will have (or not have) the related value. (I have more to say about this but not sure when. Remind me!)
*** Partial function application
We said earlier that a function of two arguments is written like this:

#+BEGIN_SRC elm
  divideBy : Int -> Int -> Int
  divideBy y x =
      x // y
#+END_SRC

This example defines a function called ~divideBy~ which takes two numbers and divides the second by the first. So ~divideBy 3 12~ is ~4~.

In Elm (and many related languages) there's the concept of "partial function application", which means you can provide e.g. only one of the two arguments, and in so doing, create a new function. (Sometimes this is also called "currying", although technically, currying is something else; everyone just uses the word wrong.) So although you could do this:

#+BEGIN_SRC elm
  halve : Int -> Int
  halve x =
      divideBy 2 x
#+END_SRC

You can just do this:

#+BEGIN_SRC elm
  halve : IntList -> IntList
  halve =
      divideBy 2 x
#+END_SRC

Why is this useful? It makes it easier to define ad hoc, on-the-fly sorts of functions. For example, in JavaScript, it's common to use ~map~ to perform an operation on all elements of a list:

#+BEGIN_SRC javascript
  let arr = [12, 2, 56].map(function(x) {
      return divideBy(2, x);
  });

  // There's also Function.prototype.bind to make this sort of thing
  // easier, but, because JavaScript, it kind of makes it uglier.
  let halve = divideBy.bind(null, 2);
  let arr = [12, 2, 56].map(halve);
#+END_SRC

~map~ takes a function, and a common way to provide this function is to define an anonymous function (a "lambda") right there. But it's quite tedious when all we want to do is re-use a given function with some arguments already fixed. This is so common in Elm that we don't have to do anything special:

#+BEGIN_SRC elm
  halveAll : List Int -> List Int
  halveAll l =
      List.map (divideBy 2) l

  -- or, equivalently
  halveAll : List Int -> List Int
  halveAll =
      List.map (divideBy 2)
#+END_SRC

By calling ~divideBy~ with just one argument, we get a function accepts the second argument and uses it along with the "remembered" first argument. Elm creates this second function for us automatically.

This is why the type signature is written ~divideBy : Int -> Int -> Int~. In a real sense, ~divideBy~ is a function that takes one argument, and which returns a function that takes the second argument.
*** Type inference
We've said that Elm *typechecks* our programs while compiling them. What does this mean? How does it do that? Knowing this can be helpful when trying to figure out why some code generated an error, and it can help guide your thinking when you're trying to write a solution.

Let's imagine we have some Elm code like this:

#+BEGIN_SRC elm
  type alias User =
      { name : String
      , team : Color
      }

  colorName : Color -> String
  colorName = -- ....


  nameIsLegal : String -> Bool
  nameIsLegal = -- ...


  describeUser u =
      if nameIsLegal u.name
      then "User " ++ u.name ++ " with color " ++ u.color
      else Nothing
#+END_SRC

Let's say Elm is trying to typecheck ~describeUser~. What it does is it writes down as many facts as it can infer from this code. For example, ~describeUser~ is clearly a function of one argument. The return type of ~describeUser~ is going to be the return type of the ~if~ statement. An ~if~ statement has a condition which has to be ~Bool~ and the return type which is the same in both ~then~ and ~else~ cases. And so on. So it might put together something that looks like this: (Note: not real Elm code)

#+BEGIN_SRC elm
  describeUser : d1 -> d2
  if : Bool -> t -> e
  t = e
  d2 = t = e
  (nameIsLegal u.name) = Bool
  (++) : String -> String -> String
  "User " : String
  " with color " : String
  t = String    -- it's the output of the ++
#+END_SRC

Already Elm can tell quite a lot about our code! If there's no contradictions so far, it has to typecheck each subexpression. This can generate more facts. For example, ~nameIsLegal u.name~ means we're calling ~nameIsLegal~ with a single argument ~u.name~. In order for that to be OK, ~nameIsLegal~ has to be a function, and it has to take at least one argument, and the first argument has to be the same type as ~u.name~. Well actually we don't know what type ~u.name~ is because ~u~ doesn't have a type yet. But if we're doing ~u.name~, then ~u~ must be a record with a ~name~ field. So we keep writing down facts and trying to put them together with other facts:

#+BEGIN_SRC elm
  nameIsLegal : n1 -> Bool
  u : d1
  d1 = { name : n1, ....? }
  nameIsLegal : String -> Bool   -- from the type signatures I wrote above
  d1 = { name : String, ....? }
  ("User " ++ u.name) : String   -- this is OK because u.name is a String
  ("User " ++ u.name ++ " with color ") : String
  ("User " ++ u.name ++ " with color " ++ u.color) : String
  -- This must mean:
  u.color : String   -- which is probably not what we wanted!
  d1 : { name : String, color : String }   -- wait, that's not User!
  describeUser : { name : String, color : String } -> d2
#+END_SRC

So this part successfully typechecked, and Elm inferred something (although not the thing we had in mind). But what about the return type of ~describeUser~? Well, it should be the return type of the ~if~. The condition part of the ~if~ checked out, but the ~then~ seems to have type ~String~. What about the ~else~ part? We wrote ~else Nothing~. ~Nothing~ is a constructor for ~Maybe a~. (We don't know what the ~a~ is yet -- we don't have enough to go on.) Elm knows that the ~if~ has to have the same types for the ~then~ and the ~else~, and they're clearly already different, so it will reject this code.

The name for this algorithm is [[https://en.wikipedia.org/wiki/Unification_(computer_science)][unification]], and the type inference algorithm is called [[https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner][Hindley-Milner]]. You don't have to know a lot about it but it can be helpful to try to simulate it by hand sometimes when trying to sort out a tricky compiler error.

Here are some built-in rules for generating facts:

- When typechecking a function, the arguments of the function must have the types indicated by the corresponding types in the function signature.

- If a function ~f~ is being called with an argument ~x~, then ~f~ must be a function and its first argument must be the same as the type of ~x~.

- If we have ~case x of~, then each alternative constructor must be the same type as ~x~.

- Each matched constructor can introduce new variables. For example ~Cons d remainder~ creates the variables ~d~ and ~remainder~. Their types correspond to the types in the constructor declaration in the type definition.

- If we have ~if c then t else e~, then ~c~ must have type ~Bool~; ~t~ and ~e~ must have the same type; the type of the if statement must be the type of ~t~ / ~e~.

- If we have ~let x = z in e~, then every time we see ~x~ in ~e~, it must have the type of ~z~.

- If we have a list literal like ~[ a, b, c ]~, then ~a~, ~b~ and ~c~ must have the same types (let's call it ~A~), and the type of the list is ~List A~.

- If we see ~x.field~, then ~x~ must be a record, and it must have a field named ~field~, and the type of ~x.field~ is the type of the field in the record type.

The Elm REPL can sometimes be helpful for asking about what type a certain smaller expression is. In the repl, if you type an expression like ~modBy 12~, it will reply ~<function> : Int -> Int~.
*** Vocabulary notes
- We no longer have *classes*; now we have *types*. Instead of *objects* of classes, we have *values* of those types.

- We still have *constructors*, although they work a little differently.

https://www.destroyallsoftware.com/compendium/types?share_key=baf6b67369843fa2 is a good link to discuss different kinds of type systems if that's interesting to you.
*** Exercises
https://ellie-app.com/5PtVRcXHyJqa1
** Elm: garbage
*** Imports
Type aliases get imported by themselves -- no constructors. (At some point the Elm compiler gave really shitty errors if you did this.)
With types, you can import/export either the type by itself, or the type with constructors. (You can't import only some constructors.)
*** Updating records
{ foo | ... }. Doesn't support { model.foo | ... }
*** More operators
We said above that function application binds tightest. There are some fun operators that you can use instead of writing oodles of parentheses. ~|>~ is sometimes called a "pipe" -- it lets you feed arguments through functions:

#+BEGIN_SRC elm
  distance : Float -> Float -> Float
  distance x y =
      x * x + y * y
          |> sqrt
#+END_SRC

Which is the same as

#+BEGIN_SRC elm
  distance : Float -> Float -> Float
  distance x y =
      sqrt (x * x + y * y)
#+END_SRC

There's also ~<|~, which serves to let you delimit the rest of an expression. So another way to write the above is as

#+BEGIN_SRC elm
  distance : Float -> Float -> Float
  distance x y =
      sqrt <| x * x + y * y
#+END_SRC

There are also "function composition" operators ~<<~ and ~>>~. ~(f << g) x~ is the same as ~f (g x)~. ~(f >> g) x~ is the same as ~g (f x)~. Combined with partial application, these can save you from writing lots of simple boilerplate functions, although it's possible to get too clever with it. Here's an example:

#+BEGIN_SRC elm
  removeEmpty : List String -> List String
  removeEmpty strings =
      List.filter (not << String.isEmpty) strings
#+END_SRC

This (equivalent) function is perhaps a touch too clever:

#+BEGIN_SRC elm
  removeEmpty : List String -> List String
  removeEmpty =
      List.filter (not << String.isEmpty)
#+END_SRC

You can also define an anonymous function using this syntax: ~\x -> x * 2~. The backslash represents the Greek letter [[https://en.wikipedia.org/wiki/Lambda_calculus][lambda]]. You can take multiple arguments too: ~\x y -> x + y~.
*** Entity types (to avoid using Maybe)
*** Exercises
Things that frustrated learners:

- if/then/else in Elm, especially nested if/then/else. Some learners analyze JS nested conditionals as if () { ... } else if () { ... } else {}, and there's no obvious "else if ... else" in Elm.

- Difference between types and values. You may need a ~Maybe a~ somewhere, but you can't just put ~Maybe a~! In particular, constructors vs. types here is a bit of a leap. Constructors are *described* using types but *used* using values.

- Need to emphasize the utility of constantly asking "What is the type of this thing?" Can ask type at repl, although only for "builtin" stuff.
** Elm, part 2: the runtime and The Elm Architecture
So far we've learned about the Elm language and how to write functions and type signatures. But up till now, there's always been some scaffolding that we haven't talked about -- we haven't seen a complete program yet. This is the first time we'll put everything together and see a little bit about how a real Elm program works. This is called "The Elm Architecture", and it may remind you a little bit of how things work in React.
*** A complete Elm app
OK, let's look at some actually useful code: https://guide.elm-lang.org/architecture/buttons.html

This is an example of a complete, if simple, Elm application. When defining an Elm application, you define a *model*, which contains the state of your entire application. Then, your application consists of:

- An initial value for your model.
- A "view function", which describes how to turn your state into HTML.
- An "update function", which lets us respond to user actions. More about this in a second.

The view function is responsible for producing HTML, which in Elm is represented using an ~Html msg~ type. We remember from earlier that ~msg~ is a variable. In this case, the ~Html~ type is the type of HTML that can generate messages. Messages are how user action is represented. We define our message type to represent all the different user actions we understand.

In Elm, nothing can have side effects. How, then, can anything ever change? The answer is that the Elm environment manages some side effects for us. In particular, it keeps track of our model, and lets us produce a new one when "something happens" -- in other words, for each message. This done by writing an ~update~ function, which takes the current model and the message and produces the new model.

This three-part structure (model, view, update) is called "The Elm Architecture", and is at the heart of all Elm applications.

In this particular example, the model is just an ~Int~ (representing how many times the button has been clicked), and the possible actions are just ~Increment~ and ~Decrement~.
*** A more complicated state
A slightly more complicated, but still silly, little program: https://ellie-app.com/5pb8Ndv36Q4a1

Read it over and note anything that doesn't make sense to you.
**** Record types
This example makes use of record types, which we've seen before. As a reminder, a record is a type that has a fixed number of fields, each with a name and its own type. This type is "complete" on its own, so you can use it directly in type signatures if you want:

#+BEGIN_SRC elm
  birthday : { name : String, age : Int, weight : Int } -> Int
  birthday person =
      person.age + 1
#+END_SRC

However, usually it's a better idea to give the type a name using ~type alias~:

#+BEGIN_SRC elm
  type alias User =
      { name : String
      , age : Int
      , weight : Int
      }
#+END_SRC

Again, we use ~type alias~ instead of ~type~ because the record type is "complete" on its own.

You can access fields of a record, as above, using ~person.age~ (or similar). You can also destructure it. You don't need to destructure every field in the record. You can create a new record by "updating" an existing one:

#+BEGIN_SRC elm
  birthday : User -> User
  birthday user =
      { user | age = user.age + 1 }
#+END_SRC

Of course, this doesn't modify ~user~ (that would be a side effect!); it just creates a new record with most of the same fields.

Now, normally a record type doesn't have/need a constructor. However, it's convenient to have one in certain situations (including decoding JSON), so Elm has a rule that if you have a type alias for a record type, it creates a constructor for it using the name of the alias. In this example, it creates ~User~ which is of type ~String -> Int -> Int -> User~. The first argument is the name, the second the age, etc. in order of declaration.
**** Let
This example also uses ~let~ expressions, which let us define several variables for use in subsequent expressions. This is a pretty common feature of functional languages and helps us break up a really large function into smaller pieces.

For unknown reasons, the Elm compiler will not let you create mutually-referential variables in a ~let~ expression. If you need to do this in 0.19, you have to make them module-level definitions.
*** Forms
This example uses a form to collect user input: https://guide.elm-lang.org/architecture/text_fields.html

Read this one over too. There isn't any new syntax here, but there are a few new tricks about The Elm Architecture.
**** Events.onInput
We previously saw ~Events.onClick~, which we used on buttons, and causes that button (when clicked) to produce a message that we handle in ~update~. In terms of static types, ~Events.onClick~ takes a ~msg~ and produces an ~Attribute msg~, which is then given to ~button~ to produce an ~Html msg~. The ~msg~ lets us distinguish which button was clicked.

~<input>~ elements are a little different from buttons. Buttons don't have any information in them, but inputs do. How can we access the information "in" the inputs? In JavaScript, we could access the ~.value~ of the ~<input>~ -- but we can't do that in Elm, because ~.value~ would have a different result every time we called it, which means it's impure. Instead, Elm sets things up so that the event -- in other words, the message -- carries the current value.

~Events.onInput~ is used for handling a change in an ~<input>~ element. In the example, we see ~onInput Change~. Here, ~Change~ is a constructor. We see from the definition of the ~Msg~ type that ~Change~ takes a ~String~. This ~String~ is provided by Elm from the JavaScript event, and deconstructing the ~Change~ event is how we get the current value from the input.

Once we have the input's value, we use it in the view as the input's ~value~. This may seem a little redundant -- after all, we just got the value from the input! -- but it's an essential part of The Elm Architecture. Because of this, we ensure that the HTML is a pure function of the model. This enables some neat tricks, such as time travel debugging. (Ellie supports this -- type some stuff in, click on the "Debug" tab, click on an earlier state, and then jump back to "Output".)

Let's break down this construct into its pieces and their types. ~Change~ is not ~Msg~ but instead has type ~String -> Msg~. ~Events.onInput~ takes ~Change~, so it must be of type ~(String -> Msg) -> Attribute Msg~.
*** Exercises
Write an Elm program similar to the "text fields" example. It should allow the user to put in a name, a street address, a city, a state, and a zip code, and display it as a mailing address.

- For now, just accept the state as another ~<input>~. (As an exercise, you can try to convert it to a ~<select>~.)

- Although a zip code is written with digits, you should not try to treat it as a number. (In general, you should treat ~<input>~ as corresponding to a ~String~, because that is how to best represent user input.)
** Elm part 3: advanced topics (~Cmd~, JSON)
*** Side effects
We said that because Elm is pure, it forbids side effects. And that's true as far as it goes. But, in the words of [[https://www.youtube.com/watch?v=iSmkqocn0oQ][Simon Peyton Jones]], a programming language with no side effects whatsoever is useless -- it can't read input nor produce output. In particular, there are lots of operations a web application will want to perform that embody side effects. A good example is making an HTTP request. That request can return different results at different times, which is a huge tip-off that it is impure.

Elm offers a mechanism for performing these operations. Like a lot of things in Elm, this mechanism centers around a type. You can call (e.g.) ~Http.get~, which returns a ~Cmd msg~ (or sometimes ~Task~, which is related). If you define your program using ~Browser.element~ instead of ~Browser.sandbox~, you can return this ~Cmd~ from your ~update~ function. When you do this, the Elm runtime will perform the ~Cmd~. Each ~Cmd~ can report its result by producing a message, which is then handled (as normal) using your update function.

Although we say that the Elm programming language is pure, what we mean is that you can't write a function that has a side effect. Instead what we do is write a pure function that returns a ~Cmd~, and will always return the same ~Cmd~ given the same output. The Elm "runtime" is responsible for actually performing this side effect. This may seem like sleight-of-hand but it's actually very important because it makes it obvious (and machine-enforceable) which parts of the program can (or cannot) have side effects.

An example of making an HTTP request is at https://guide.elm-lang.org/effects/http.html.

Up until now, we've defined types that correspond very closely to our data. For example, when you see ~Maybe Int~, you might think to yourself, "Oh, unless it's ~Nothing~, it has an ~Int~ inside it", and you know that you can pattern match to get the ~Int~ out. Some learners then see ~Cmd Int~, and reason, "Well, it has an ~Int~ inside it. How do I get the ~Int~ out?" You should *not* think "it has an ~Int~ inside it". There is no ~Int~ at all! Instead, a ~Cmd Int~ is sort of like a blueprint or recipe that, if followed, would *produce* an ~Int~. You can't get the ~Int~ out because it isn't there. The only things you can do with it are: return it from ~update~ (so that the Elm runtime will follow the recipe), or use the recipe in a bigger recipe (using e.g. ~Cmd.map~) to produce something else with that ~Int~.
*** Demo
We'll go through the effort of converting Evan's "text input" example into a ~Browser.element~ program.
*** Parsing JSON
In JavaScript, accessing a JSON object is super easy -- just data.user.name or whatever. However, it's generally best practice to define some kind of "schema" that you use to validate that incoming data is of the form you expect, to give you one specific place to handle invalid data and to simplify the rest of your code (since it can assume the data is valid).

In Elm, this schema validation process is mandatory because you have to turn "untyped" JSON into your own strong types. This can be very frustrating for learners, and the library you use to do it can be a bit daunting, so we're going to spend some extra time on it.

The Elm package for handling JSON is [[https://package.elm-lang.org/packages/elm/json/latest/][elm/json]]. It has two parts -- converting from Elm values to JSON structures ("encoding") and converting from JSON structures to Elm values ("decoding"). The package also defines a ~Value~ type, which represents a JSON value, but its details aren't exposed, so you can't pattern match on it directly.

Instead, if you want to decode JSON, you define a ~Decoder~. A ~Decoder a~ is the type of something that takes a JSON value and produces ~a~ (or fails with an error message). There are some basic decoders already defined -- ~string : Decoder String~, ~bool : Decoder Bool~, ~int : Decoder Int~, ~float : Decoder Float~.

You can also retrieve fields from a JSON object using ~field~ or ~at~.

The real trick is in combining decoders. Let's say you want to decode users like this:

#+BEGIN_SRC javascript
  {
      "name": "Ethan",
      "location": "Brooklyn"
  }
#+END_SRC

Into Elm structures like this:

#+BEGIN_SRC elm
  type alias User =
      { name : String
      , location : String
      }
#+END_SRC

We can retrieve the ~name~ field using ~field "name" string~ and the ~location~ field using ~field "location" string~. We want to put them together. For this we use ~map2~:

#+BEGIN_SRC elm
  decodeUser : Decoder User
  decodeUser =
      map2 User
          (field "name" string)
          (field "location" string)
#+END_SRC

We can use any function of type ~String -> String -> User~, but we already have one in the ~User~ constructor created by the type alias.

Note that we don't have to do anything special to indicate that we want the ~User~ to correspond to an object. If it weren't an object, the ~field~ decoders would fail.

Writing these decoders is kind of tedious, but Evan thinks it's not that big a deal, and doesn't want to commit to any automatic mechanism just yet. There are some libraries that aim to streamline it a little bit: https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/ is pretty common, and some people have tried to make it safer by writing both the encode and decode functions at the same time: https://package.elm-lang.org/packages/prozacchiwawa/elm-json-codec/latest/.
*** Modeling
There's an idea in the ML/Haskell/Elm communities which says "Make illegal states unrepresentable" (attributed to Yaron Minsky). This is a very powerful idea with ramifications throughout how you design your types/data structures.

First, there are obvious cases. If you have a traffic light, there are only three legal states: red, yellow, and green. Representing this using a string is problematic because there are many more strings than the three we actually want. (This is one of Evan's examples, taken from [[https://guide.elm-lang.org/appendix/types_as_sets.html][Types as Sets]].)

Another, subtler case is about overuse of ~Maybe~. ~Maybe~ is a good way to express "We cannot know in advance whether this will be present", but sometimes that just means "I personally don't know whether this will be present". There are sometimes alternatives that lead to a cleaner type system. One example is the ~Entity~ pattern. (This is an idea that I first saw in the Yesod framework for Haskell -- see https://www.yesodweb.com/book/persistent#persistent_insert.)

Stuff in a relational database looks like a table, something like this:

| Id | Name    | Location  |
|  1 | Ethan   | Brooklyn  |
|  2 | Mike    | Atlanta   |
|  3 | Francis | Asheville |

If we wanted to model this in Elm, we might come up with this:

#+BEGIN_SRC elm
  type alias User =
      { id : Int
      , name : String
      , location : String
      }
#+END_SRC

But what happens when we want to insert a new User? We would have to provide an ~id~, but we probably can't know off the top of our heads what ID is good. We really want to not provide an ID when we're inserting a new user, so that the database can give us the next available ID. But when we get a user back, we definitely want the ID to come back with it. So we might try something like this:

#+BEGIN_SRC elm
  type alias User =
      { id : Maybe Int
      , name : String
      , location
      }
#+END_SRC

i.e. make the ~id~ field a ~Maybe~. Lots of frameworks take this approach -- Django, for instance, would have you model ~User~ as a class, and a given ~User~ might have ~id~ of ~None~ if it had never been saved, and you would call ~user.save()~ to insert/update a user, and if the user hadn't been saved before, this would set its ~id~. But in Elm we can't update the user's ID in-place (that would be a side effect). Instead we can separate the ~User~ type into two types:

#+BEGIN_SRC elm
  type alias User =
      { name : String
      , location : String
      }

  type alias UserEntity =
      { id : Int
      , user : User
      }
#+END_SRC

This way, we can create our ~User~ values without reference to how they would be stored in the database. These are what we would ~insert~. But at the same time, we can talk about ~UserEntity~ values, which *must* have been stored in the database. These two different types make it clear the cases where we will, or will not, have IDs.
*** Exercise
Remember the FCC "weather viewer" project? That project used the HTML5 Geolocation API, which we don't have access to in Elm. But let's use https://fcc-weather-api.glitch.me/ to get the current weather for latitude 40.65 and longitude -73.95 (i.e. somewhere in Brooklyn) and then display it.
