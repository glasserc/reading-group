#+HTML_HEAD: <style type="text/css">pre.src { background-color: #333; color: #fff; }</style>
* Reading group
** Modeling
Ground rule: If you don't understand something, ask as soon as possible -- it's probably my fault for not explaining it well. If there's something that it's OK not to understand, I'll say so, so assume that everything I said, I was trying to make you understand, and if I didn't succeed, I would like to know that.

The Django tutorial I linked to isn't super great for beginners -- it's kind of targeted at experienced web developers. The goal for these first few weeks is to get us to a place where we have *something* up and running, so for now, it's OK not to understand all of that document. That said, I would love for people to learn/get practice with reading technical documentation. It's something of an art!

The first part of building a web application in Django is defining the structure of your database, so we're going to spend some time talking about that today.
*** What is a web application?
At it's most fundamental level, a website is basically some HTML and some images. Some of you have probably already studied a little HTML and it's not really that interesting. In particular, it's static. It will keep staying the same until you write new HTML.

A web application is a program that generates HTML when you visit, so that it can be *dynamic*, or have the potential for change. This makes it something that a user can interact with, without having to write HTML themselves.

Django (and most similar software) anticipate that you will want to base your application on some data, and that application can manipulate that data, and that data is what the user sees and interacts with by interacting with your application. So it's: User <-> Application <-> Data.

In order to make it easy for your application to manipulate data, it's stored in a database.
*** What is a database?
A database is another piece of software which is in charge of storing and organizing data[1]. We are going to be using a kind of database called a "relational" database (specifically we're going to start by using SQLite, but most databases that have "SQL" in the name function similarly).

You can think of a relational database as kind of like an Excel workbook. A relational database has "tables", which are like sheets in a workbook. Each table is a collection of rows, each of which has the same set of columns. So you might have a "people" table that looks like this:

| Person  | Number of pets | Signed up date |
| Ethan   |              1 |     2015-05-01 |
| Rita    |              0 |     2015-05-18 |
| Francis |              1 |     2015-05-08 |

And you might have another table that stores hobbies:

| Person  | Hobby        |
| Ethan   | Chiptune     |
| Rita    | British rock |
| Francis | Death metal  |
| Ethan   | Baking       |
| Francis | Kendo        |
| Rick    | Beer         |

If you had this data stored in a relational database, it would be possible to ask it to "put it together" and generate a table like this:

| Person  | Number of pets | Number of hobbies |
| Ethan   |              1 |                 2 |
| Rita    |              0 |                 1 |
| Francis |              1 |                 2 |

"Relational" is a long word so I'll probably use it interchangeably with "SQL" (pronounced "sequel"), even though technically the two things aren't exactly the same.

[1] This is a wild oversimplification, but "database" is a term that gets used a lot in a lot of contexts with subtly different meanings.
*** Modeling
When you're using Django (and probably when you're developing any kind of application), the first thing you do is think about what are the entities that you're going to have in your application, and how they relate to one another. For example, in a hospital management system, you might have patients and doctors and rooms, and patients stay in rooms and doctors visit patients (but doctors don't stay in rooms). Once you have a clear idea of what the entities are, you structure your database to support that. In Django, you write the structure of your database in a file called "models.py". You translate this structure into your actual database using the "python manage.py migrate" command.

In the tutorial, they take the example of a "poll", which they define as being a "question" with a variable number of "answers". ("Variable" meaning that one question might have two answers, and another question might have three answers.)

[Side note: Let's say I created my table to be like this:

| Question text | Publication date | Choice 1 text | Choice 1 votes | Choice 2 text | Choice 2 votes | Choice 3 text | Choice 3 votes |
| What's up?    |       2015-05-01 | Not much      |              0 | The sky       |              0 | Just hacking  | 0              |

In doing this, I'm asserting that EVERY question have exactly 3 choices! Clearly they can't have more choices because there's no where to put them, but it's also true that they can't have less choices because what will I put in the 3rd choice?

In other words, notice that columns are *constant* in a relational model, so if you want to have a variable number of something, you have to turn those somethings into rows somehow.]
*** Demo
Once you have your models set up, you can create Python objects and make them go into the database, and similarly you can get things out of the database as Python objects. This might not be impressive, but it's the same thing your application is going to do when users interact with it.

You can access the database your program created using the "sqlite3" command (which you might have to install using apt-get or yum or something). This part isn't super important because Django mostly insulates you from it, but I thought it might be interesting to see what's going on "underneath the hood", and sometimes this is useful for debugging.

To open your database in sqlite, you can type "sqlite3 db.sqlite3". In sqlite, you can do .tables to show the tables. A table was created for "polls_question" and another for "polls_choice". You can see what the "schema" (table structure) for a table was using e.g. ".schema polls_question". You can also see what is in your database using a SELECT statement.

#+begin_src
sqlite> select * from polls_question;
1|What's new?|2015-05-18 04:33:32.860786
2|Should I go to work today?|2015-05-18 04:34:51.572901

sqlite> .schema polls_choice
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id"));
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

sqlite> select * from polls_choice;
1|Not much|0|1
2|The sky|0|1
3|Just hacking again|0|1
4|Yes|0|2
5|No|0|2
#+end_src

So, we see that each choice has FOUR attributes -- an ID for itself, a text, a count of votes, and the ID of the question to which it is associated.

Note that each choice uses the question ID -- in my example above, I used people's names, but using an ID is more natural. For one thing, it lets people change their names without having to change it in a lot of places, and I don't have to worry about them being spelled slightly wrong. For another, names aren't unique, but IDs are.
*** Many-to-many relationships
The example in the tutorial defines a many-to-one relationship -- one choice belongs with one question, but one question has many choices. This kind of relationship, as well as the even simpler one-to-one relationship, is generally implemented by putting the ID of the related object in the table.

There's another kind of relationship between entities called a many-to-many relationship. The relationship between people and hobbies is a good example. Each person has many hobbies, and each hobby can be associated with many people. Traditionally, this is implemented using a "join table" -- a table that just tracks the IDs of both objects. So you might have:

A "people" table:

| ID | Name    | Number of Pets |
|  1 | Ethan   |              1 |
|  2 | Rita    |              0 |
|  3 | Francis |              2 |

A "hobbies" table:

| ID | Hobby        |
|  1 | Chiptune     |
|  2 | British rock |
|  3 | Death metal  |

The "person-to-hobbies link table":

| Person ID | Hobby ID |
| 1         | 1        |
| 2         | 2        |
| 3         | 3        |
| 3         | 1        |

Django can handle this for you too, but you'll have to read more documentation: https://docs.djangoproject.com/en/1.8/topics/db/examples/many_to_many/.
*** Homework
- Let's start small -- instead of a whole dollhouse, let's just design a schema for a paper doll application. A paper doll has a name (e.g. "Princess" or "Zoe") and some articles of clothing. Each article of clothing has a filename (e.g. "gloves.png") and a location (e.g. arms, torso, legs, head). What should the tables look like?

- Go through the tutorial again and try to create another application in your existing site. Call it "paperdolls". Try to define the models the same way they do in the tutorial. To test them, try going into the shell and create objects the way they did (although using your models instead of the polls one). Post any error you get to the mailing list, along with the contents of your models.py.
** Views pt 1
*** Homework review
Here are my solutions:

**** Solution 1
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    doll = models.ForeignKey(Doll)

    filename = models.CharField(max_length=200)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Doll ID | Filename      | Location |
|  1 |       1 | gloves.png    |        2 |
|  2 |       1 | red-dress.png |        0 |
|  3 |       1 | sandals.png   |        3 |
|  4 |       2 | tiara.png     |        1 |
|  5 |       2 | lab-coat.png  |        0 |

**** Solution 2
#+begin_src python
class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class Doll(models.Model):
    name = models.CharField(max_length=200)
    torso_item = models.ForeignKey(ClothingItem)
    head_item = models.ForeignKey(ClothingItem)
    arms_item = models.ForeignKey(ClothingItem)
    legs_item = models.ForeignKey(ClothingItem)
#+end_src

Dolls table:
| ID | Name     | Torso | Head | Arms | Legs |
|  1 | Princess |     2 | ???  |    1 |    3 |
|  2 | Zoe      |     5 | 4    |  ??? |  ??? |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

**** Solution 3
#+begin_src python
class Doll(models.Model):
    name = models.CharField(max_length=200)

class ClothingItem(models.Model):
    filename = models.CharField(max_length=200)

class DollWearsClothing(models.Model):
    doll = models.ForeignKey(Doll)
    clothing_item = models.ForeignKey(ClothingItem)
    # torso = 0, head = 1, arms = 2, legs = 3
    # FIXME: this is kind of ugly
    location = models.IntegerField(default=0)
#+end_src

Dolls table:
| ID | Name     |
|  1 | Princess |
|  2 | Zoe      |

Clothing table:
| ID | Filename      |
|  1 | gloves.png    |
|  2 | red-dress.png |
|  3 | sandals.png   |
|  4 | tiara.png     |
|  5 | lab-coat.png  |

Doll Wears Clothing table:

| ID | Clothing ID | Doll ID | Location |
|  1 |           1 |       1 |        2 |
|  2 |           2 |       1 |        0 |
|  3 |           3 |       1 |        3 |
|  4 |           4 |       2 |        1 |
|  5 |           5 |       2 |        0 |
|  6 |           3 |       2 |        3 |
*** Syntax
Syntax refers to the structure of a language. In English, the sentence "The dog bit the man" is well-formed according to English syntax. The sentence "The bit dog man the" has invalid syntax. The sentence "The man bit the dog" has valid syntax but questionable semantics. In programming languages, we sometimes use "syntax" as an umbrella term for all the rules of the language that give it sense to the computer, which also include semantics.

Depending on how far you've gotten in the Django tutorials, you've seen lots of different syntax so far:

- =from foo import bar= at the beginning of a bunch of different files
- =class Foo():= for models
- =blah = models.CharField()= for fields in those models
- =def __str__():= when defining models
- =INSTALLED_APPS = (...)= when "activating" models
- ='words'= and sometimes ="words"=
- =def foo():= for views
- =urlpatterns = [...]= when setting up views
- =url(r'...', foo)= when setting up views
- =%= in some views

I'm going to touch on the essentials of the most important parts of the most important ones of these, and mention a few details about some of the others, because the goal is to get us up and running as fast as possible without wearing you down with details that aren't important yet. These are just simplistic summaries!
*** Django settings: variables
In almost any programming language, you can do stuff like this:

#+NAME: print_variables
#+begin_src python :results output
x = 5
print(x)
print(x + 3)

x = 6
print(x)
print(x + 3)
#+end_src

If I run this program, it will show:

#+RESULTS: print_variables
: 5
: 8
: 6
: 9

What's going on is that when Python sees the line =x = 5=, it creates a thing called =x=. Wherever it sees =x=, it checks the last value it got for =x=, which in this case is 5. =x= is called a variable, and you can think of it as like a box in the computer's memory that has some "value" inside of it. When Python then sees the line =x = 6=, it will take the 5 out of the box and put the 6 in.

There are many different kinds of values that we can put into a variable.[1] In the above example, =x= is an integer (in Python, we say =x= is an =int=). You can also have bits of words and sentences in variables: just do =x = 'hello'= or =x = "hello"= (they're equivalent). These bits of text are called "strings" (in Python, we say they are =str=). You can have truth values =True= and =False=, which are called Booleans (in Python, =bool=). You can also have lists, which are written =x = [1, 2, 3]= (in Python these are called =list=\ s, but in other languages they're called arrays or vectors). There's also something called a tuple, which is written =x = (1, 2, 3)=, but for now we're going to say it's the same as a list.

There are a bunch of places where you get to customize how Django does some things. We've already seen that we need to update =INSTALLED_APPS= when we add a new app. =INSTALLED_APPS= is an ordinary variable that Django gives some special meaning to. Most of these variables are written in all uppercase, but some (like =urlpatterns=) aren't, and you just have to know that they're special.

[1] In some languages, each variable has to be "declared" to hold only some types of values. Python isn't like that; instead it uses "dynamic typing", which means that any variable can hold any value, and even change from one type of value to another. This has advantages and disadvantages.
*** def foo(): functions/methods
Any time you see =def foo(...)=, we are defining a function. A function is a part of a program. Like a program, a function has some operands, which are called parameters or arguments, and a result, which is called the "return value". Here's an example:

#+begin_src python
def check_password(password):
    if password == 'stairs_are_history!':
        return True
    elif password == 'swordfish':
        return True
    else:
        return False
#+end_src

Here's how you might use it:

#+begin_src python
user_password = input()
password_correct = check_password(user_password)
if password_correct:
    print("Welcome back!!")
else:
    print("Incorrect password")
#+end_src

So when you see the code =check_password(user_password)=, that's saying "Begin doing the stuff under =def check_password=. Also, when doing those things, the variable =password= is going to have the value that =user_password= does.[2][3]" Then, Python goes through line after line, doing what that line says, until it either gets to the end of the =def= or it hits a =return=. If it hits a =return=, the function immediately ends and the value after the =return= is sent to wherever the =check_password()= line was.

Using a function is a nice way to group some commands together and use them many times in different places. For this reason, Django uses them to represent views.

The syntax for a function is:

#+begin_src python
def FUNCTION_NAME(PARAM1, PARAM2, ....):
    STATEMENT1
    STATEMENT2
    ...
#+end_src

N.B. A function definition ALWAYS has a colon (=:=) after the parameter list, and the statements in the function are ALWAYS "indented" by four spaces. Some of those statements might have their own sub-statements, which might be inset by another four spaces, and so on. The function continues until Python sees a non-blank line that isn't indented by four spaces.[4]

To use the function, you write the name of the function, plus the things you want the function to operate on. Then Python will start doing the various statements, one after the other. If the function is going to return something, you can put a variable in front of it, or use it in another function, or whatever.

As a general rule, using a function looks almost exactly like using an entity or a class, but functions usually have lowercase names and entities and classes have Capitalized names.

You can also define functions inside classes; these are called methods and we'll talk more about them several weeks from now. In the first part of the tutorial, you defined one called =was_published_recently=.

=__str__()= is a special method that is used whenever an object needs to be displayed. We won't dwell on it right now.

[2] Again, it isn't necessary to specify a type for =password=; like any variable, it can take any value.

[3] =password= is what's called a "local" variable; it will disappear as soon as the function is over.

[4] Some of you have been using TABs instead of spaces. In the Python community, this is discouraged -- it should always be 4 spaces. If you're lucky, you can set up your text editor to insert 4 spaces when you press the TAB key. For instance, on =gedit=, I was able to find a thing on the bottom of the window that says "Tab width: 8 spaces"; clicking on it let me set it to 4 spaces and "use spaces instead of tabs".
*** import
In Python, when we want to use models, functions, or variables from another file, we use the =import= command. There are many different ways to import things, none of which we're going to discuss now. If you forget to import something, you'll usually get a =NameError= saying that something wasn't defined.
*** . ("dot")
*** Homework
Go through all the files in your site so far. Find examples of the following:
- functions being used
- stuff being imported
- a list
- a tuple

Press on and try to get to the end of part 3 of the tutorial. Hopefully by now we are starting to see how Django lets us build a web application.
** TODO add to email
Solution 1 is what I expected most of you to come up with. It lets you match clothing with dolls. One nice advantage to this system is that we can have multiple articles of clothing on the same doll in the same place. (So, socks and then sneakers, for example.) Similarly, you can have 0 articles of clothing on a part of the doll. Of course, if your requirements don't need/forbid this, that might be a disadvantage.

Solution 2 is kind of like a straw man, devil's advocate thing. Last week I said this isn't really possible because we don't know what to put in the =???= places. In fact, there is a way -- there's a thing called =NULL= which is like an empty space. Some people say =NULL= [[http://c2.com/cgi/wiki?NullsAndRelationalModel]["violates the relational model"]], which might or might not mean anything, but it certainly can make your life difficult if you expect something to never be =NULL= when in fact it sometimes is. For this reason, all fields in Django are not allowed to be =NULL= (this is also enforced by the database). If you want to change this, you can use the [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#blank][blank]] and [[https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.Field.null][null]] options in your fields.

Solution 2 doesn't let you have multiple articles in the same place, but it does have one nice advantage which is that it's easy to "share" an article of clothing between two dolls -- you just re-use the ID. In Solution 1, this would require duplicating the filename, which is error-prone. (If you move the filename and forget to update it everywhere, you will have a data consistency problem.)

Solution 3 has the advantages of both solution 1 and solution 2 -- you can share clothing, plus you can have multiple clothing in the same place. But there's something weird in it, which is that the location of the same article of clothing can be different for different dolls.

Any of these solutions might be OK depending on what your requirements are, but I'd probably go with solution 3, but move =location= to the Clothing table, and I'd add a column to the Wear table that specifies order (so that socks always go under sneakers).
** office hours
*** exercise 1: change your index view to say "This is the paper dolls index"
*** exercise 2: make it show your index view when you go to polls/hello
*** exercise 3: create a new view that says "I finished exercise 3!" when you go to /ex3
** urlpattern exercises feedback
- /blog was intentional; the goal was to hammer in the point that the name of the files on-disk don't have to correspond to the names in the URLs.
- In exercise 4, when we want to match any player's name, we can use the dot character ('.') in the pattern to match anything at all.
- You can use the name of a view directly in the site's urlpatterns -- you don't have to include a file if you don't want to. You can just give the path to the view and Django will import it for you.
- Yes, in fact, you can make this work -- the Drupal CMS is set up like this. Everything is just a "node" and depending on what kind of node you get out of the database, you then do something different with it. Yes, this is kind of backwards, and nobody sane does it. Drupal is written in PHP, so you can safely consider them insane.
** Views pt 2
Outstanding questions: what is this .format() business?

It's a pretty common situation where you want to have a string built from text and variables. Here's the "simple" way to do that in Python:

#+begin_src python
x = 5
y = 10
s = "The sum of " + str(x) + " and " + str(y) + " is " + str(x + y)
#+end_src

Kinda wordy. So most recent languages offer something called "string interpolation", which is a mechanism whereby the language can help "fill in" the string with other bits of text.

Python actually has two string interpolation mechanisms. The tutorial uses this form:

#+begin_src python
x = 5
y = 10
s = "The sum of %s and %s is %s" % (x, y, x+y)
#+end_src

In the exercises, I used this form:

#+begin_src python
x = 5
y = 10
s = "The sum of {} and {} is {}".format(x, y, x+y)
#+end_src

The first format is older, and inspired by older mechanisms like C's ~printf~. The second one is newer and more powerful. For instance, if you forget which one is supposed to be x and which one is supposed to be y, you can do this:

#+begin_src python
x = 5
y = 10
s = "The sum of {x} and {y} is {xplusy}".format(x=x, y=y, xplusy=x+y)
#+end_src

The full details are available in https://docs.python.org/3.5/library/string.html#format-string-syntax.
*** Recap to this point:
We've actually learned a lot of "mini-languages", including SQL, regular expressions and format strings. We're actually going to learn another three or four in the near future -- today's is the Django template system.
*** Templates
So far we've written views that just produce responses. But an actual web page is an enormous blob of HTML, some of which is shared between pages and some of which is completely different. Dumping all of that into your ~views.py~ file would rapidly become unmaintainable.[1] So most web frameworks offer a notion of "templates", which are another mini-language that make it easier to generate HTML.

Here's a template (let's pretend we saved it as ~polls/some-template.html~:

#+begin_src jinja
Hello, {{ thing }}!
#+end_src

In Django, the usual way to use a template is to turn it into an HttpResponse, like this:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

The ~render~ function takes three arguments -- the request, the name of the template, and any arguments for the template. These arguments are sometimes called a /context/. The template can access anything in the context. Together, the above should produce:

#+begin_example
Hello, world!
#+end_example

Templates help institute a division between code and presentation. Typically front-end engineers work on templates (and CSS and JS), and back-end engineers work on code that provides stuff to those templates. We're going to be working a little bit on all of these.

[1] Maintainability refers to the property of software to be maintained, i.e. understood, debugged, updated and changed to do new things or to do them better. Maintainability is a big deal for software engineers. Usually maintainable code beats fast-to-write code, and fast-to-write code usually beats fast-to-run code, but this depends on what section of software you're in.
*** Template language
**** Default is to output
Most template languages are geared towards producing output. In fact, to produce output, you don't even need to give a command -- you just write text. Anything you write will be copied to the output.

Example:

#+begin_src jinja
This is some text without anything special going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {"thing": "world"})
#+end_src

Produces:

#+begin_example
This is some text without anything special going on.
#+end_example

Note that when you're looking at your template, you're looking at plain text, but the template is being rendered as HTML, which is a bit different. In particular, blank lines in text are just spaces in HTML.
**** You can use variables
To access things from the context, you can write two curly braces, then the name of the thing in the context, and then two curly braces.

Example:

#+begin_src jinja
This is some {{ field }} without anything {{ adjective }} going on.
#+end_src

With:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "field": "words", "adjective": "unusual", "name": "Ethan"
        })
#+end_src

Produces:

#+begin_example
This is some words without anything unusual going on.
#+end_example

As the example shows, you don't have to use everything in the context, but if you use something that *isn't* in the context, it's an error.

You can also access attributes the same way you do in Python. So let's say you have some object in your context, like this:

#+begin_src python
def my_view(request):
    q = Question(id=1, question_text="What's up?")
    return render(request, "polls/some-template.html", {
        "question": q
        })
#+end_src

You can get the text "What's up" using:

#+BEGIN_EXAMPLE
Please answer the question: {{ q.question_text }}
#+END_EXAMPLE

Of course, you can access attributes of attributes of attributes, more or less the same way you do in Python:

#+BEGIN_EXAMPLE
You chose {{ c.choice_text }} for {{ c.question.question_text }}
#+END_EXAMPLE
**** Conditionals
Sometimes you have two different things you might want to do. For example, if polling has closed on a question, then maybe you don't want to let people vote, but if it hasn't closed yet, then you do.

#+BEGIN_SRC jinja
{% if q.was_published_recently %}
  OK, you can vote on this question.
{% else %}
  Sorry, polling has closed on this question.
{% endif %}
#+END_SRC

This is very similar to if statements in Python, which I think we saw a little bit of already, so I won't dwell on it. As in Python, you can write some (limited expressions) as the "condition". For example, here's how you could check if a choice hadn't received any votes yet.

#+BEGIN_SRC jinja
{% if c.num_votes == 0 %}
  Nobody has voted for this choice yet!
{% endif %}
#+END_SRC

N.B. The ~if~ command in Django templates is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~! Don't confuse the two!
**** Looping
So far we haven't talked much about types, but hopefully you remember that ~[1, 2, 3]~ is a list. If you have a list of things, you can do something with each element. So let's say we have:

#+begin_src python
def my_view(request):
    return render(request, "polls/some-template.html", {
        "numbers": [1, 1, 2, 3, 5, 8]
        })
#+end_src

And the template:

#+BEGIN_SRC jinja
Do you notice anything about these numbers?

{% for number in numbers %}
  {{ number }} ...
{% endfor %}
#+END_SRC

This will produce:

#+BEGIN_EXAMPLE
Do you notice anything about these numbers?

  1 ...
  1 ...
  2 ...
  3 ...
  5 ...
  8 ...
#+END_EXAMPLE

This structure is called a *loop*. We haven't had to use it in Python, but it exists there and is very similar. Lots of things produce lists or other loop-able structures. How it works is, first ~number~ is set to the first thing in ~numbers~. Then, everything between ~{% for .... %}~ and ~{% endfor %}~ is run. Then, we go back to the top. ~number~ gets set to the *next* thing in ~numbers~, and then everything between ~{% for ... %}~ and ~{% endfor %}~ is run again. And so on, until there's nothing left in ~numbers~.

N.B. The ~for~ command, like the ~if~ command and most other commands in Django templates, is written using ~{%~ and ~%}~ instead of ~{{~ and ~}}~.
**** Filters
Certain other operations are allowed using a concept known as a "filter". For example, you can get the length of a list using:

#+BEGIN_SRC jinja
There are {{ numbers|length }} numbers.
#+END_SRC

You can select the first element of a list using:

#+BEGIN_SRC jinja
The first number is {{ numbers|first }}.
#+END_SRC

If you have a string you can convert it to lowercase using:

#+BEGIN_SRC jinja
When I am feeling blue, I sign my name as {{ name|lower }}.
#+END_SRC

There's even a "pluralize" filter that helps apply the rules for English pluralization (use a singular if n = 1, otherwise use plural). This isn't safe for international websites, but it's a useful shortcut otherwise.
#+BEGIN_SRC jinja
Here are your item{{ num_items|pluralize }}:
#+END_SRC

You can chain filters too, so if you want the first letter of a string, converted to lower-case, you can do:

#+BEGIN_SRC jinja
Not everyone's name can begin with {{ name|lower|first }}.
#+END_SRC
**** Summary
Django templates are actually tightly limited in scope. The designers of Django wanted to prevent people writing templates from having the ability to break a site by writing a bad template. However, the operations available in a template are specialized for generating text, so despite the limitations, they are still more useful than writing HTML in Python files.

A complete summary of the "built-in" functionality in the template system is available at https://docs.djangoproject.com/en/1.8/ref/templates/builtins/.
*** Database access
We've already agreed that a web application stores its data in a database, and so Django has to provide some mechanism that our websites can use to get data into and out of our database. We saw some of this in part 1 of the Django tutorial, but now is when we can really apply it. We need objects to give to our templates, and these objects are often going to come from the database, so let's review how we can do that.
**** Retrieving an object
Access to objects in the "database", rather than just a single object, or the model itself, is done through an ~objects~ field. If you have a model called ~Question~ and want to retrieve the one with ID 5, you can do:

#+BEGIN_SRC python
q = Question.objects.get(pk=5)
#+END_SRC
**** All objects
You can get access to all objects using the ~all()~ method:

#+BEGIN_SRC python
qs = Question.objects.all()
#+END_SRC
**** Filters and field lookups
What if you want only some of them? For example, you might want to get all the ~Questions~ that have a ~pub_date~ that is already passed, or you might want to get all the ~Choices~ with no votes. In this case, you add a filter using the ~filter~ method. Some examples:

#+BEGIN_SRC python
now = timezone.now()
qs = Question.objects.filter(pub_date__lte=now)
choices = Choice.objects.filter(votes__exact=0)
#+END_SRC

The parameters to ~filter~ are known as "field lookups". You can add as many as you like in a call to ~filter~. Each one expresses some criteria of the objects you are looking for.  These "lookups" are composed of (1) the field name that you are concerned with, (2) a double underscore (~__~), (3) some comparison you want to make with that field, (4) an equals sign (~=~), and (5) something to compare against. So, in the above, we see ~pub_date__lte=now~; ~pub_date~ is the field, and we are looking for the cases where that is ~lte~ (less than or equal to) whatever we have as ~now~. Similarly, ~votes__exact=0~ means to find all choices where the ~votes~ field is ~exact~ (exactly equal to) the value ~0~.

All fields are the ones we defined as fields in the model. However, if the field you want to use is a foreign key, you have to add a ~_id~ to the field name. So if we want to get all the choices for ~Question~ with ID 5, we write:

#+BEGIN_SRC python
choices = Choice.objects.filter(question_id=5)
#+END_SRC

There's one short-cut with field lookups -- if you don't specify a comparison, it's assumed to be ~exact~. So we can instead write:

#+BEGIN_SRC python
choices = Choice.objects.filter(votes=0)
#+END_SRC

(In fact, this is how the ~pk=5~ example above works too.)
**** Full documentation
A complete reference is available at https://docs.djangoproject.com/en/1.8/topics/db/queries/. Field lookups are also documented more extensively at https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups.
** Comments on the exercises
*** Types of model object
We've seen three different kinds of object:

- Model class. These are usually written in capitals (a.k.a. CamelCase) like ~BlogPost~. Model classes define fields, but don't themselves have those fields, so you can't do ~BlogPost.post_text~.
- An *instance* or object of this model class, like ~BlogPost.objects.get(pk=5)~. These are usually put in variables with lower-case-with-underscores names (a.k.a. snake_case, named for Python). If you have ~blog_post = BlogPost.objects.get(pk=5)~, then you can access its fields using ~blog_post.post_text~.
- There's also a "manager", which is the thing you see at  ~BlogPost.objects~. You go from the model class to the manager, and the manager provides access to the objects.
- There's also another type, which is "list of objects":
~BlogPost.objects.all()~ or ~BlogPost.objects.filter(...)~. If you have a list of blog post objects, each one of them will have those fields, but the list itself won't.

Model classes are like cookie cutters, and instances are like the cookies they've cut out. The model class defines the shape of the objects, and how they get made, but isn't itself one of them.
*** RequestContext
For the purposes of this exercise, we don't really need a ~RequestContext~ -- we could use the simpler ~Context~, which doesn't need access to the request -- but we may as well use the ~RequestContext~ everywhere. It's only actually used in a few cases -- the ~LocaleMiddleware~ tries to guess what language the user speaks, which is used when you use ~{% trans %}~ in a template, and there's a thing called *CSRF* which requires sending something to the user when you render templates.
*** for loops
A for loop repeats some set of operations for each object in a list. So, you have to have a list.

#+BEGIN_SRC jinja
{% for blog_post in my_list_of_blog_posts %}
  {{ blog_post.post_text }}
{% endfor %}
#+END_SRC

This means to take the first object in my_list_of_blog_posts, and then do everything "inside" the for loop, with ~blog_post~ being that object. Then, go back to the top and repeat, with ~blog_post~ being the *second* object, and so on.
*** What goes in a view vs. a template?
Django structures stuff according to a paradigm called "model-view-template" (MVT). (Other frameworks work similarly but with different names for the different layers.) This division allocates responsibilities as follows:

- Models: the one "source of truth" for how your data should look and behave.
- Views: responsible for actually responding to user requests and translating that into access to models
- Templates: responsible for presenting the output of the views to a user -- this is the "user experience" part.

What goes in which area is a little bit inexact, and reasonable people can disagree, but most people agree with this vague division.

In these particular exercises, the question of where to put the logic that fetches a blog post's comments could be argued either way. You could put it in the template if you think it's a user interface concern how, if, and whether we display comment information. You could put it in the view if you believe that the main concern here is deciding what data to fetch and how to fetch it. In particular, there are some optimizations you can make if you do the fetching all at once in the view rather than post-by-post in the template. It's also a little surprising if you "accidentally" do database queries in the template, because that might eventually impact performance.

FIXME: The above isn't 100% since fetching in the view is probably correct but it's an optimization that doesn't change how the template looks.

About templates in particular, a good rule of thumb is that you've done a good job dividing stuff between your view and your template if you only have to change your template when someone comes to you and says "Actually, the way we're presenting this information isn't what we want. Can we present it this other way?" (But don't get dogmatic! It's always better to be inconsistent than to have unmaintainable code.)
*** Limits of Django templates
Because of the above division, Django templates are written to be *very* limited. You can't even call functions in a template! There's one exception to this: if you have a "method" like ~obj.foo()~, you can write that in a Django template like ~{{ obj.foo }}~, without the parentheses. Yes, this is crazy, but you might need this to access all the comments for a blog post.
*** Length of a list
In regular Python, you would write ~len(my_list)~. In Django templates, you have to write ~{{ my_list|length }}~.

Different languages and environments have different names for this operation -- ~size~, ~count~, ~length~ are all common. Python's a little unique in that it writes ~len(my_list)~ instead of ~my_list.len~. (This is for historical reasons.)
*** Formatting/style
Software engineers *love* to argue about formatting of source code, often to the detriment of actual engineering. I try to stay limber about these sorts of things and I'd encourage you to as well, at least until you originate a project from scratch and can bend people to your will.

Some "meta-guidelines":

- When in Rome, do as the Romans do. Your code should look like code in the same file, or the same project, or code that works with the same framework.
- Languages often define standards for how code should look. In Python, the standard to follow is PEP8. I don't know of a standard for Django templates.
- Break the rules if it makes something easier to read.

Some generic guidelines:

- When lines get too long, break them into several. "Too long" varies by taste; I prefer about 120 characters, but a lot of people still prefer 80 characters.
- When you find yourself repeating something, turn it into a variable or a function.
- Naming things is really hard, but really important.
- Similar things should go together. Different things should go apart. (This might mean separate functions, separate parts of a file, separate files, or separate projects.)
** CSS pt 1
Reading for this week:
https://www.girldevelopit.com/materials/html-intro, specifically class 2

https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Color (don't feel obligated to read the rest of the tutorial, or earlier parts)

https://docs.djangoproject.com/en/1.8/intro/tutorial06/, use as a reference to try to get your CSS into a page

http://media.mediatemple.netdna-cdn.com/wp-content/uploads/images/css3-cheat-sheet/css3-cheat-sheet.pdf list of a whole bunch of different CSS properties; see also https://developer.mozilla.org/en-US/docs/Web/CSS/Reference which is linked to good references for them
*** Overview
CSS is yet another language that we use to apply style to our pages.

In CSS, you write *rules* which apply to your HTML elements. Each rule changes some properties of the elements in question.

#+BEGIN_SRC html
  <html>
    <body>
      <p>This is the first paragraph</p>
      <ul>
        <li>This is item 1</li>
        <li class="special-list-item">This is item 2</li>
        <li class="special-list-item warning">This is <em>item</em> 3</li>
      </ul>
      <p class="final-paragraph">This is another paragraph</p>
    </body>
  </html>
#+END_SRC

#+BEGIN_SRC css
  p {
    color: #f00;
  }

  .final-paragraph {
    color: #ff0;
    background-color: #000;
  }

  li {
    text-decoration: underline;
  }

  .special-list-item {
    text-transform: uppercase;
  }

  .warning {
    background-color: #f00;
  }

  em {
    font-style: italic;
  }
#+END_SRC

This will cause the first paragraph to have red text, and the last to have yellow text with a black background; list items will be underlined, and the second and third will be written in uppercase, and the third will have a red background; the last word "item" will be italicized.

CSS rules apply to multiple elements, and each element can be affected by multiple rules. When this happens, there is a "cascade", which merges properties according to certain rules (which we'll get to later; for now, let's just say later rules override earlier rules).

HTML elements can have "classes" and "ids" that serve no purpose other than to "hook up" to CSS rules. Accordingly, you can use whatever classes and IDs you like. Stylistically, classes and IDs are often separated with hyphens (which isn't even possible in Python).

To debug CSS rules, you can use your browser's development tools. For example, you can right click on an element and select "Inspect element" to look at what the browser believes the HTML is and what rules apply to it.

Generally, we try to maintain a consistent "look and feel" throughout our site, which includes consistent templates and style; we'll touch more on that in future weeks.
** Future topics
Local variables
Methods
Dynamic typing
Tuples and how they differ from lists
The "dot" syntax for looking up fields in models or calling methods
